{
    "componentChunkName": "component---src-pages-d-3-js-weekly-heatmap-tsx",
    "path": "/d3js/weekly-heatmap/",
    "result": {"pageContext":{"demoInfo":{"dataFiles":["data.tsv"],"docs":[["d3-selection API reference","https://github.com/d3/d3-selection#api-reference"],["d3-selection Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-selection/index.d.ts"],["d3-scale API reference","https://github.com/d3/d3-scale#api-reference"],["d3-scale Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-scale/index.d.ts"],["d3-fetch API reference","https://github.com/d3/d3-fetch#api-reference"],["d3-fetch Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-fetch/index.d.ts"]],"isCompleted":true,"name":"Weekly Heatmap","notes":[],"sources":["http://bl.ocks.org/tjdecke/5558084"],"summary":["This chart is a grid of days and hours using a quantile to group the data values by nine colors. The number of groups is directly tied to the colors array, so removing or adding colors to the array also affects the number of groups."],"category":"d3js","files":{"demoCSS":[{"content":".weeklyHeatmapChart {\n  rect.bordered {\n    stroke: #e6e6e6;\n    stroke-width: 2px;\n  }\n\n  text.mono {\n    fill: #aaa;\n    font-family: Consolas, courier, sans-serif;\n    font-size: 9pt;\n  }\n\n  text.axisBold {\n    fill: #333;\n    font-weight: bold;\n  }\n}\n","filePath":"src/demos/weekly-heatmap/weekly-heatmap.module.css"}],"demoTS":[{"content":"import { HeatmapChart } from \"./weekly-heatmap-chart\"\nimport {\n  CONTAINER_ID,\n  TimeItem,\n  UPDATE_BUTTON_ID,\n  createChartConfig,\n  fetchData,\n} from \"./weekly-heatmap-data\"\n\nconst main = async () => {\n  const weeklyData = await fetchData()\n  const chartConfig = createChartConfig(weeklyData)\n\n  const heatmap = HeatmapChart.renderChart<TimeItem>(chartConfig)\n\n  document.getElementById(UPDATE_BUTTON_ID)?.addEventListener(\"click\", () => {\n    weeklyData.forEach((weeklyDataItem) => {\n      const shouldUpdate = Math.random() > 0.85\n\n      if (shouldUpdate) {\n        weeklyDataItem.arbitraryMetric += Math.random() * 100 + 30\n      }\n    })\n    heatmap.refresh()\n  })\n}\n\nexport { CONTAINER_ID, UPDATE_BUTTON_ID }\n\nexport default main\n","filePath":"src/demos/weekly-heatmap/weekly-heatmap.ts"},{"content":"import {\n  D3DragEvent,\n  Selection,\n  drag as dragD3,\n  max as maxD3,\n  scaleQuantile,\n  select,\n} from \"d3\"\n\nimport * as styles from \"./weekly-heatmap.module.css\"\n\nconst colors = [\n  \"#ffffd9\",\n  \"#edf8b1\",\n  \"#c7e9b4\",\n  \"#7fcdbb\",\n  \"#41b6c4\",\n  \"#1d91c0\",\n  \"#225ea8\",\n  \"#253494\",\n  \"#081d58\",\n]\nconst { length: buckets } = colors\n\nconst margin = {\n  bottom: 100,\n  left: 50,\n  right: 50,\n  top: 50,\n}\nconst minHeight = 250\nconst minWidth = 850\n\nconst rectRadiusSize = 100\nconst extraHeight = 60\nconst axisOffset = -6\n\nconst legendStroke = \"#ccc\"\n\ntype ChartConfig<ChartData> = Readonly<{\n  getIsHorizontalLabelBold: (label: string, labelIndex: number) => boolean\n  getIsVerticalLabelBold: (label: string, labelIndex: number) => boolean\n  getItemHorizontalIndex: (cell: ChartData) => number\n  getItemTooltip: (cell: ChartData) => string\n  getItemValue: (cell: ChartData) => number\n  getItemVerticalIndex: (cell: ChartData) => number\n  getLegendText: (cellValue: number) => string\n  horizontalLabels: string[]\n  rootElId: string\n  verticalLabels: string[]\n  weeklyData: ChartData[]\n}>\n\ntype ChartElements<ChartData> = Readonly<{\n  cellsSel: Selection<SVGGElement, ChartData, SVGGElement, unknown>\n  gSel: Selection<SVGGElement, unknown, HTMLElement, unknown>\n  legendSel: Selection<SVGGElement, number, SVGGElement, unknown>\n  svgDragSel: Selection<SVGGElement, unknown, HTMLElement, unknown>\n  svgSel: Selection<SVGSVGElement, unknown, HTMLElement, unknown>\n}>\n\ntype ChartClasses = Readonly<{\n  cell: string\n  legend: string\n}>\n\nclass HeatmapChart<ChartData> {\n  private readonly config: ChartConfig<ChartData>\n  private readonly elements: ChartElements<ChartData>\n  private readonly classes: ChartClasses\n  private readonly state = {\n    drag: {\n      x: 0,\n      y: 0,\n    },\n    width: 0,\n  }\n\n  private constructor(chartConfig: ChartConfig<ChartData>) {\n    this.config = chartConfig\n\n    const { rootElId } = chartConfig\n\n    const svgSel = select(`#${rootElId}`).append(\"svg\")\n    const svgDragSel = svgSel.append(\"g\")\n    const gSel = svgDragSel.append(\"g\")\n\n    const chartClasses = {\n      cell: \"cell\",\n      legend: \"legend\",\n    }\n\n    this.classes = chartClasses\n\n    this.elements = {\n      get cellsSel() {\n        return gSel.selectAll<SVGGElement, ChartData>(`.${chartClasses.cell}`)\n      },\n      gSel,\n      get legendSel() {\n        return gSel.selectAll<SVGGElement, number>(`.${chartClasses.legend}`)\n      },\n      svgDragSel,\n      svgSel,\n    }\n\n    this.render()\n\n    window.addEventListener(\"resize\", this.handleResize)\n  }\n\n  public static renderChart<ChartData>(chartConfig: ChartConfig<ChartData>) {\n    return new HeatmapChart<ChartData>(chartConfig)\n  }\n\n  public teardown() {\n    window.removeEventListener(\"resize\", this.handleResize)\n  }\n\n  public refresh() {\n    this.render()\n  }\n\n  private render() {\n    const { config, elements } = this\n    const { horizontalLabels, rootElId, verticalLabels, weeklyData } = config\n    const rootEl = document.getElementById(rootElId) as HTMLElement\n\n    rootEl.classList.add(styles.weeklyHeatmapChart)\n\n    const fullWidth =\n      rootEl.getBoundingClientRect().width - margin.left - margin.right\n    const width = Math.max(fullWidth, minWidth)\n\n    this.state.width = fullWidth\n\n    const height = Math.max(\n      Math.ceil((width * 10) / horizontalLabels.length) -\n        margin.top -\n        margin.bottom +\n        extraHeight,\n      minHeight\n    )\n    const cellSize = Math.floor(width / horizontalLabels.length)\n    const legendElementWidth = cellSize * 2\n\n    const max = maxD3(weeklyData, (cell) => config.getItemValue(cell))\n\n    const colorScale = scaleQuantile<string>()\n      .domain([0, buckets - 1, max])\n      .range(colors)\n\n    elements.svgSel\n      .attr(\"height\", height + margin.top + margin.bottom)\n      .attr(\"width\", width + margin.left + margin.right)\n\n    elements.gSel.attr(\"transform\", `translate(${margin.left},${margin.top})`)\n\n    elements.gSel\n      .selectAll(\".verticalLabel\")\n      .data(verticalLabels)\n      .enter()\n      .append(\"text\")\n      .attr(\n        \"class\",\n        (...[label, labelIndex]) =>\n          `verticalLabel ${styles.mono} axis${\n            config.getIsVerticalLabelBold(label, labelIndex)\n              ? ` ${styles.axisBold}`\n              : \"\"\n          }`\n      )\n\n    elements.gSel\n      .selectAll<SVGTextElement, string>(\".verticalLabel\")\n      .text((label) => label)\n      .attr(\"transform\", `translate(${axisOffset},${cellSize / 1.5})`)\n      .attr(\"x\", 0)\n      .attr(\"y\", (...[, labelIndex]) => labelIndex * cellSize)\n      .style(\"text-anchor\", \"end\")\n\n    elements.gSel\n      .selectAll(\".horizontalLabel\")\n      .data(horizontalLabels)\n      .enter()\n      .append(\"text\")\n      .text((label) => label)\n      .style(\"text-anchor\", \"middle\")\n      .attr(\n        \"class\",\n        (...[label, labelIndex]) =>\n          `horizontalLabel ${styles.mono} axis${\n            config.getIsHorizontalLabelBold(label, labelIndex)\n              ? ` ${styles.axisBold}`\n              : \"\"\n          }`\n      )\n\n    elements.gSel\n      .selectAll<SVGTextElement, string>(\".horizontalLabel\")\n      .attr(\"transform\", `translate(${cellSize / 2}, ${axisOffset})`)\n      .attr(\"x\", (...[, labelIndex]) => labelIndex * cellSize)\n      .attr(\"y\", 0)\n\n    elements.cellsSel\n      .data(weeklyData)\n      .enter()\n      .append(\"rect\")\n      .attr(\"class\", `${this.classes.cell} ${styles.bordered}`)\n      .style(\"fill\", colors[0])\n\n    elements.cellsSel\n      .transition()\n      .duration(2000)\n      .style(\"fill\", (cellItem) => colorScale(config.getItemValue(cellItem)))\n\n    elements.cellsSel\n      .attr(\"height\", cellSize)\n      .attr(\"rx\", rectRadiusSize)\n      .attr(\"ry\", rectRadiusSize)\n      .attr(\"width\", cellSize)\n      .attr(\n        \"x\",\n        (cellItem) => config.getItemHorizontalIndex(cellItem) * cellSize\n      )\n      .attr(\"y\", (cellItem) => config.getItemVerticalIndex(cellItem) * cellSize)\n      .attr(\"title\", config.getItemTooltip)\n\n    $(`.${this.classes.cell}`).tooltip()\n\n    const legendData = [0].concat(colorScale.quantiles())\n\n    const legendNew = elements.legendSel\n      .data(legendData)\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", this.classes.legend)\n\n    legendNew\n      .append(\"rect\")\n      .style(\"fill\", (...[, valueIndex]) => colors[valueIndex])\n      .style(\"stroke\", legendStroke)\n\n    legendNew\n      .append(\"text\")\n      .attr(\"class\", styles.mono)\n      .style(\"text-anchor\", \"middle\")\n\n    elements.legendSel.each(function handleLegendItem(\n      ...[valueItem, valueIndex]\n    ) {\n      select(this)\n        .selectAll(\"rect\")\n        .attr(\"x\", legendElementWidth * valueIndex)\n        .attr(\"y\", height)\n        .attr(\"width\", legendElementWidth)\n        .attr(\"height\", cellSize / 2)\n\n      select(this)\n        .selectAll<SVGTextElement, unknown>(`.${styles.mono}`)\n        .attr(\"x\", legendElementWidth * valueIndex + legendElementWidth / 2)\n        .text(config.getLegendText(valueItem))\n        .attr(\"y\", height + cellSize)\n    })\n\n    this.setupDrag()\n  }\n\n  private setupDrag() {\n    const { elements } = this\n\n    const updateDrag = () => {\n      this.elements.svgDragSel.attr(\n        \"transform\",\n        `translate(${this.state.drag.x},${this.state.drag.y})`\n      )\n    }\n\n    const canUseDrag = this.state.width < minWidth\n\n    const dragHandler = (\n      dragEvent: D3DragEvent<SVGSVGElement, unknown, unknown>\n    ) => {\n      if (!canUseDrag) {\n        return\n      }\n\n      this.state.drag.x += dragEvent.dx\n      this.state.drag.y += dragEvent.dy\n\n      updateDrag()\n    }\n\n    const dragBehavior = dragD3<SVGSVGElement, unknown>().on(\n      \"drag\",\n      dragHandler\n    )\n\n    elements.svgSel.style(\"cursor\", canUseDrag ? \"move\" : \"default\")\n\n    if (!canUseDrag) {\n      this.state.drag = { x: 0, y: 0 }\n    }\n\n    elements.svgSel.call(dragBehavior).on(\"drag\", dragHandler)\n\n    updateDrag()\n  }\n\n  private readonly handleResize = () => {\n    this.render()\n  }\n}\n\nexport { HeatmapChart, ChartConfig }\n","filePath":"src/demos/weekly-heatmap/weekly-heatmap-chart.ts"},{"content":"import { tsv } from \"d3\"\n\nimport { ChartConfig } from \"./weekly-heatmap-chart\"\n\nconst CONTAINER_ID = \"chart\"\nconst UPDATE_BUTTON_ID = \"update-random\"\n\ntype TimeItem = {\n  arbitraryMetric: number\n  day: number\n  hour: number\n}\n\ntype TimeItemOriginal = {\n  day: number\n  hour: number\n  value: number // eslint-disable-line id-denylist\n}\n\nconst days = [\"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\", \"Su\"]\n\nconst hours = Array.from({ length: 24 }).map(\n  (...[, hourIndex]: [unknown, number]) => {\n    const normalizedHour = hourIndex % 12\n\n    return `${normalizedHour + 1}${\n      hourIndex >= 11 && hourIndex !== 23 ? \"pm\" : \"am\"\n    }`\n  }\n)\n\nconst workingHourMin = 7\nconst workingHourMax = 16\nconst workingDayMin = 0\nconst workingDayMax = 4\n\nconst fetchData = async (): Promise<TimeItem[]> => {\n  const weeklyTSVData = (await tsv(\n    `${ROOT_PATH}data/d3js/weekly-heatmap/data.tsv`\n  )) as unknown as TimeItemOriginal[]\n\n  return weeklyTSVData.map((timeItem) => ({\n    arbitraryMetric: +timeItem.value,\n    day: +timeItem.day,\n    hour: +timeItem.hour,\n  }))\n}\n\ntype Config = ChartConfig<TimeItem>\n\nconst getItemValue: Config[\"getItemValue\"] = (timeItem) =>\n  timeItem.arbitraryMetric\n\nconst getItemTooltip: Config[\"getItemTooltip\"] = (timeItem) =>\n  `Arbitrary Metric: ${timeItem.arbitraryMetric.toFixed(2)}`\n\nconst getItemHorizontalIndex: Config[\"getItemHorizontalIndex\"] = (timeItem) =>\n  timeItem.hour - 1\n\nconst getItemVerticalIndex: Config[\"getItemVerticalIndex\"] = (timeItem) =>\n  timeItem.day - 1\n\nconst getIsHorizontalLabelBold: Config[\"getIsHorizontalLabelBold\"] = (\n  ...[, hourIndex]\n) => hourIndex >= workingHourMin && hourIndex <= workingHourMax\n\nconst getIsVerticalLabelBold: Config[\"getIsVerticalLabelBold\"] = (\n  ...[, dayIndex]\n) => dayIndex >= workingDayMin && dayIndex <= workingDayMax\n\nconst getLegendText: Config[\"getLegendText\"] = (arbitraryMetric) =>\n  `≥ ${arbitraryMetric.toFixed(2)}`\n\nconst createChartConfig = (weeklyData: TimeItem[]): Config => ({\n  getIsHorizontalLabelBold,\n  getIsVerticalLabelBold,\n  getItemHorizontalIndex,\n  getItemTooltip,\n  getItemValue,\n  getItemVerticalIndex,\n  getLegendText,\n  horizontalLabels: hours,\n  rootElId: CONTAINER_ID,\n  verticalLabels: days,\n  weeklyData,\n})\n\nexport {\n  CONTAINER_ID,\n  TimeItem,\n  UPDATE_BUTTON_ID,\n  createChartConfig,\n  fetchData,\n}\n","filePath":"src/demos/weekly-heatmap/weekly-heatmap-data.ts"}],"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps, JQUERYUI } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main, {\n  CONTAINER_ID,\n  UPDATE_BUTTON_ID,\n} from \"@/demos/weekly-heatmap/weekly-heatmap\"\n\nconst WeeklyHeatmap = ({ pageContext }: DemoPageProps) => (\n  <Demo\n    links={[JQUERYUI.STYLE]}\n    main={main}\n    pageContext={pageContext}\n    scripts={[JQUERYUI.SCRIPT]}\n  >\n    <form style={{ marginBottom: 20 }}>\n      <button className=\"btn btn-info\" id={UPDATE_BUTTON_ID} type=\"button\">\n        Update Random\n      </button>\n    </form>\n    <div id={CONTAINER_ID} />\n  </Demo>\n)\n\nexport default WeeklyHeatmap\n","type":"tsx"}},"key":"weekly-heatmap"},"meta":{"description":"Heatmap chart example using D3.js, very similar to the one displayed in the GitHub site, with a few additions from the original."}}},
    "staticQueryHashes": []}