{"componentChunkName":"component---src-pages-d-3-js-trend-line-js","path":"/d3js/trend-line/","result":{"pageContext":{"demoInfo":{"data":["data.tsv"],"name":"Trend line","notes":["Added both line animations","Changed y scale domain"],"sources":["http://codepen.io/arundhaj/pen/ouyjd","http://big-elephants.com/2014-06/unrolling-line-charts-d3js/"],"category":"d3js","files":{"js":"const main = () => {\n  const animationTime = 2000\n\n  const linearRegression = function (data) {\n    const lr = {}\n    const n = data.length\n\n    let sumX = 0\n    let sumY = 0\n    let sumXY = 0\n    let sumXX = 0\n    let sumYY = 0\n\n    data.forEach((d) => {\n      sumX += d.occurred.getTime()\n      sumY += d.value\n      sumXX += d.occurred.getTime() * d.occurred.getTime()\n      sumYY += d.value * d.value\n      sumXY += d.occurred.getTime() * d.value\n    })\n    lr.slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX)\n    lr.intercept = (sumY - lr.slope * sumX) / n\n    lr.r2 = Math.pow(\n      (n * sumXY - sumX * sumY) /\n        Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY)),\n      2\n    )\n\n    return lr\n  }\n\n  const getInterpolation = function (data, line) {\n    const interpolate = d3.scale\n      .quantile()\n      .domain([0, 1])\n      .range(d3.range(1, data.length + 1))\n\n    return function (t) {\n      const interpolatedLine = data.slice(0, interpolate(t))\n\n      return line(interpolatedLine)\n    }\n  }\n\n  return d3.tsv(\"/data/d3js/trend-line/data.tsv\", (_error, data) => {\n    const margin = {\n      bottom: 50,\n      left: 50,\n      right: 50,\n      top: 50,\n    }\n    const width = $(\"#chart\").innerWidth() - margin.left - margin.right\n    const height = 500 - margin.top - margin.bottom\n    const timeFormat = d3.time.format(\"%Y-%m-%d\").parse\n\n    data.forEach((d) => {\n      d.occurred = timeFormat(d.occurred)\n      d.value = +d.value\n    })\n\n    const renderGraph = function () {\n      const zoomed = d3.select('input[value=\"zoom\"]')[0][0].checked\n      const svg = d3\n        .select(\"#chart\")\n        .text(\"\")\n        .append(\"svg\")\n        .attr({\n          height: height + margin.top + margin.bottom,\n          width: width + margin.left + margin.right,\n        })\n        .append(\"g\")\n        .attr(\"transform\", `translate(${margin.left},${margin.right})`)\n\n      const x = d3.time.scale().range([0, width])\n      const y = d3.scale.linear().range([height, 0])\n      const xAxis = d3.svg.axis().scale(x).orient(\"bottom\")\n      const yAxis = d3.svg.axis().scale(y).orient(\"left\")\n\n      const line = d3.svg\n        .line()\n        .x((d) => x(d.occurred))\n        .y((d) => y(d.value))\n\n      x.domain(d3.extent(data, (d) => d.occurred))\n      y.domain([\n        (function () {\n          if (zoomed) {\n            return d3.min(data, (d) => d.value)\n          }\n\n          return 0\n        })(),\n        d3.max(data, (d) => d.value),\n      ])\n      svg\n        .append(\"g\")\n        .attr(\"class\", \"x axis\")\n        .attr(\"transform\", `translate(0,${height})`)\n        .call(xAxis)\n      svg.append(\"g\").attr(\"class\", \"y axis\").call(yAxis)\n      svg\n        .append(\"path\")\n        .datum(data)\n        .transition()\n        .duration(animationTime)\n        .attrTween(\"d\", () => getInterpolation(data, line))\n        .attr(\"class\", \"line\")\n\n      const lr = linearRegression(data)\n\n      const regressionLine = d3.svg\n        .line()\n        .x((d) => x(d.occurred))\n        .y((d) => {\n          const tmp = lr.intercept + lr.slope * d.occurred\n\n          return y(tmp)\n        })\n\n      svg\n        .append(\"path\")\n        .datum(data)\n        .transition()\n        .delay(animationTime)\n        .duration(animationTime)\n        .attrTween(\"d\", () => getInterpolation(data, regressionLine))\n        .attr(\"class\", \"rline\")\n\n      return svg\n        .append(\"text\")\n        .attr(\"transform\", `translate(${width * 0.7},${height * 0.7})`)\n        .style(\"opacity\", 0)\n        .transition(1000)\n        .delay(animationTime * 2)\n        .text(`Slope: ${lr.slope.toExponential(3)}`)\n        .style(\"opacity\", 1)\n    }\n\n    renderGraph()\n\n    return d3.selectAll('input[name=\"mode\"]').on(\"change\", renderGraph)\n  })\n}\n\nexport default main\n","page":"import React from \"react\"\n\nimport Demo from \"@/components/demo\"\n\nimport main from \"@/demos/trend-line/trend-line\"\n\nimport \"@/demos/trend-line/trend-line.styl\"\n\nconst TrendLine = ({ pageContext: { demoInfo } }) => (\n  <Demo\n    demoInfo={demoInfo}\n    main={main}\n    scripts={[\"/vendors/d3/d3.min.js\", \"/js/d3js-utils.js\"]}\n  >\n    <form>\n      <label>\n        <input checked name=\"mode\" type=\"radio\" value=\"zoom\" /> Zoom\n      </label>\n      <label>\n        <input name=\"mode\" type=\"radio\" value=\"normal\" /> Normal\n      </label>\n    </form>\n    <div className=\"trend-line-chart\" id=\"chart\" />\n  </Demo>\n)\n\nexport default TrendLine\n","styl":".trend-line-chart\n  .axis \n    font: 10px sans-serif;\n  \n\n  .axis path,line \n    fill: none;\n    stroke: #000;\n    shape-rendering: crispEdges;\n  \n\n  .line \n    fill: none;\n    stroke: steelblue;\n    stroke-width: 1.5px;\n  \n\n  .rline \n    fill: none;\n    stroke: red;\n    stroke-dasharray: 5,5;\n    stroke-width: 1.5px;","ts":null},"key":"trend-line"}}},"staticQueryHashes":[]}