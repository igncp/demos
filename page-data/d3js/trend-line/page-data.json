{"componentChunkName":"component---src-pages-d-3-js-trend-line-js","path":"/d3js/trend-line/","result":{"pageContext":{"demoInfo":{"data":["data.tsv"],"name":"Trend line","notes":["Added both line animations","Changed y scale domain"],"sources":["http://codepen.io/arundhaj/pen/ouyjd","http://big-elephants.com/2014-06/unrolling-line-charts-d3js/"],"category":"d3js","files":{"d3utils":null,"demo":{"content":"import {\n  Line,\n  axisBottom,\n  axisLeft,\n  extent,\n  line as d3Line,\n  max,\n  min,\n  range,\n  scaleLinear,\n  scaleQuantile,\n  scaleTime,\n  select,\n  selectAll,\n  timeParse,\n  tsv,\n} from \"d3\"\n\ntype InitialDataItem = {\n  occurred: string\n  value: string\n}\n\ntype DataItem = {\n  occurred: Date\n  value: number\n}\n\nconst fetchData = async (): Promise<DataItem[]> => {\n  const result = (await tsv(\n    `${ROOT_PATH}data/d3js/trend-line/data.tsv`\n  )) as InitialDataItem[]\n\n  const timeFormat = timeParse(\"%Y-%m-%d\")\n\n  const data = result.map((d) => ({\n    occurred: timeFormat(d.occurred) as Date,\n    value: +d.value,\n  }))\n\n  return data\n}\n\nconst margin = {\n  bottom: 50,\n  left: 50,\n  right: 50,\n  top: 50,\n}\n\nconst height = 500 - margin.top - margin.bottom\n\nconst animationTime = 2000\n\nconst getInterpolation = (data: DataItem[], line: Line<DataItem>) => {\n  const interpolate = scaleQuantile()\n    .domain([0, 1])\n    .range(range(1, data.length + 1))\n\n  return (t: number): any => {\n    const interpolatedLine = data.slice(0, interpolate(t))\n\n    return line(interpolatedLine)\n  }\n}\n\nconst linearRegression = (data: DataItem[]) => {\n  const lr: { slope?: number; intercept?: number; r2?: number } = {}\n  const n = data.length\n\n  let sumX = 0\n  let sumY = 0\n  let sumXY = 0\n  let sumXX = 0\n  let sumYY = 0\n\n  data.forEach((d) => {\n    sumX += d.occurred.getTime()\n    sumY += d.value\n    sumXX += d.occurred.getTime() * d.occurred.getTime()\n    sumYY += d.value * d.value\n    sumXY += d.occurred.getTime() * d.value\n  })\n  lr.slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX)\n  lr.intercept = (sumY - lr.slope * sumX) / n\n  lr.r2 = Math.pow(\n    (n * sumXY - sumX * sumY) /\n      Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY)),\n    2\n  )\n\n  return lr\n}\n\nconst renderGraph = ({\n  data,\n  rootElId,\n}: {\n  data: DataItem[]\n  rootElId: string\n}) => {\n  const width =\n    (document.getElementById(rootElId) as HTMLElement).getBoundingClientRect()\n      .width -\n    margin.left -\n    margin.right\n\n  const renderContent = () => {\n    const zoomed = (document.querySelector(\n      'input[value=\"zoom\"]'\n    ) as HTMLInputElement).checked\n\n    const svg = select(`#${rootElId}`)\n      .text(\"\")\n      .append(\"svg\")\n      .attr(\"height\", height + margin.top + margin.bottom)\n      .attr(\"width\", width + margin.left + margin.right)\n      .append(\"g\")\n      .attr(\"transform\", `translate(${margin.left},${margin.right})`)\n\n    const x = scaleTime().range([0, width])\n    const y = scaleLinear().range([height, 0])\n    const xAxis = axisBottom(x)\n    const yAxis = axisLeft(y)\n\n    const line = d3Line<DataItem>()\n      .x((d) => x(d.occurred))\n      .y((d) => y(d.value))\n\n    x.domain(extent(data, (d) => d.occurred) as [Date, Date])\n    y.domain([\n      zoomed ? (min(data, (d) => d.value) as number) : 0,\n      max(data, (d) => d.value) as number,\n    ])\n\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\"transform\", `translate(0,${height})`)\n      .call(xAxis)\n    svg.append(\"g\").attr(\"class\", \"y axis\").call(yAxis)\n\n    svg\n      .append(\"path\")\n      .datum(data)\n      .transition()\n      .duration(animationTime)\n      .attrTween(\"d\", () => getInterpolation(data, line))\n      .attr(\"class\", \"line\")\n\n    const lr = linearRegression(data)\n\n    const regressionLine = d3Line<DataItem>()\n      .x((d) => x(d.occurred))\n      .y((d) => {\n        const tmp = lr.intercept! + lr.slope! * +d.occurred\n\n        return y(tmp)\n      })\n\n    svg\n      .append(\"path\")\n      .datum(data)\n      .transition()\n      .delay(animationTime)\n      .duration(animationTime)\n      .attrTween(\"d\", () => getInterpolation(data, regressionLine))\n      .attr(\"class\", \"rline\")\n\n    svg\n      .append(\"text\")\n      .attr(\"transform\", `translate(${width * 0.7},${height * 0.7})`)\n      .style(\"opacity\", 0)\n      .transition()\n      .delay(animationTime * 2)\n      .text(`Slope: ${lr.slope!.toExponential(3)}`)\n      .style(\"opacity\", 1)\n  }\n\n  renderContent()\n\n  selectAll('input[name=\"mode\"]').on(\"change\", renderContent)\n}\n\nconst main = async () => {\n  const rootElId = \"chart\"\n  const data = await fetchData()\n\n  renderGraph({\n    data,\n    rootElId,\n  })\n}\n\nexport default main\n","type":"ts"},"page":"import React from \"react\"\n\nimport Demo from \"@/components/demo\"\n\nimport main from \"@/demos/trend-line/trend-line\"\n\nimport \"@/demos/trend-line/trend-line.styl\"\n\nconst TrendLine = ({ pageContext: { demoInfo } }) => (\n  <Demo demoInfo={demoInfo} main={main}>\n    <form>\n      <label>\n        <input defaultChecked name=\"mode\" type=\"radio\" value=\"zoom\" /> Zoom\n      </label>\n      <label>\n        <input name=\"mode\" type=\"radio\" value=\"normal\" /> Normal\n      </label>\n    </form>\n    <div className=\"trend-line-chart\" id=\"chart\" />\n  </Demo>\n)\n\nexport default TrendLine\n","styl":".trend-line-chart\n  .axis\n    font: 10px sans-serif;\n\n\n  .axis path,line\n    fill: none;\n    stroke: #000;\n    shape-rendering: crispEdges;\n\n\n  .line\n    fill: none;\n    stroke: steelblue;\n    stroke-width: 1.5px;\n\n\n  .rline\n    fill: none;\n    stroke: red;\n    stroke-dasharray: 5,5;\n    stroke-width: 1.5px;\n"},"key":"trend-line"}}},"staticQueryHashes":[]}