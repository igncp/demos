{
    "componentChunkName": "component---src-pages-d-3-js-spain-map-tsx",
    "path": "/d3js/spain-map/",
    "result": {"pageContext":{"demoInfo":{"dataFiles":["data.json"],"docs":[],"isCompleted":true,"name":"Spanish Map","notes":[],"sources":["http://www.diva-gis.org/datadown"],"summary":[],"category":"d3js","files":{"demoCSS":[],"demoTS":[{"content":"import { NMapChart } from \"./n-map-chart\"\nimport {\n  CONTAINER_ID,\n  Properties,\n  UPDATE_BUTTON_ID,\n  createChartConfig,\n  fetchAreasData,\n} from \"./spain-map-chart-data\"\n\nconst main = async () => {\n  const areasData = await fetchAreasData()\n  const chartConfig = createChartConfig(areasData)\n\n  const mapChart = NMapChart.renderChart<Properties>(chartConfig)\n\n  document.getElementById(UPDATE_BUTTON_ID)?.addEventListener(\"click\", () => {\n    mapChart.clearMarked()\n  })\n}\n\nexport { CONTAINER_ID, UPDATE_BUTTON_ID }\n\nexport default main\n","filePath":"src/demos/spain-map/spain-map.ts"},{"content":"import {\n  BaseType,\n  D3DragEvent,\n  GeoPath,\n  GeoPermissibleObjects,\n  GeoProjection,\n  Selection,\n  drag as dragD3,\n  geoMercator,\n  geoPath,\n  range,\n  scaleLinear,\n  select,\n} from \"d3\"\nimport { GeoJsonProperties } from \"geojson\"\nimport { feature } from \"topojson-client\"\nimport { Objects, Topology } from \"topojson-specification\"\nimport { v1 as uuidv1 } from \"uuid\"\n\nconst colorsScheme = [\"#323247\", \"#7c7cc9\", \"#72b66c\", \"#429742\"]\nconst height = 500\nconst margin = {\n  bottom: 20,\n  top: 50,\n}\nconst strokeWidth = 0.4\n\ntype Bounds = [[number, number], [number, number]]\n\nconst calculateBounds = ({\n  featuresData,\n  projectionPath,\n}: {\n  featuresData: any[] // eslint-disable-line @typescript-eslint/no-explicit-any\n  projectionPath: GeoPath\n}) =>\n  featuresData.reduce<Bounds>(\n    (...[acc, featureData]) => {\n      const dataBounds = projectionPath.bounds(featureData)\n\n      acc[0][0] = Math.min(acc[0][0], dataBounds[0][0])\n      acc[0][1] = Math.min(acc[0][1], dataBounds[0][1])\n      acc[1][0] = Math.max(acc[1][0], dataBounds[1][0])\n      acc[1][1] = Math.max(acc[1][1], dataBounds[1][1])\n\n      return acc\n    },\n    [\n      [Infinity, Infinity],\n      [-Infinity, -Infinity],\n    ]\n  )\n\ntype AreasData = Topology<Objects<GeoJsonProperties>>\n\ntype ChartConfig<Properties> = Readonly<{\n  areasData: AreasData\n  getTitleText: (properties: Properties) => string\n  projectionsCenters: Array<[number, number]>\n  rootElId: string\n  widths: number[]\n}>\n\ntype DataShape<Properties> = GeoPermissibleObjects & {\n  areaIndex: number\n  properties: Properties\n}\n\ntype ChartElements = Readonly<{\n  divsSel: Selection<HTMLDivElement, unknown, HTMLElement, unknown>\n  innerGroupsSel: Selection<SVGGElement, unknown, HTMLElement, unknown>\n  rootSel: Selection<HTMLDivElement, unknown, HTMLElement, unknown>\n  svgsDragsSel: Selection<SVGGElement, unknown, HTMLElement, unknown>\n  svgsSel: Selection<SVGSVGElement, unknown, HTMLElement, unknown>\n}>\n\nconst addDropShadowFilter = <Parent extends BaseType | null>({\n  deviation,\n  id,\n  slope,\n  svg,\n}: {\n  deviation: number\n  id: number\n  slope: number\n  svg: Selection<SVGGElement, unknown, Parent, unknown>\n}) => {\n  const defs = svg.append(\"defs\")\n  const filter = defs.append(\"filter\").attr(\"id\", `drop-shadow-${id}`)\n\n  filter\n    .append(\"feGaussianBlur\")\n    .attr(\"in\", \"SourceAlpha\")\n    .attr(\"stdDeviation\", deviation)\n\n  filter.append(\"feOffset\").attr(\"dx\", 1).attr(\"dy\", 1)\n  filter\n    .append(\"feComponentTransfer\")\n    .append(\"feFuncA\")\n    .attr(\"slope\", slope)\n    .attr(\"type\", \"linear\")\n\n  const feMerge = filter.append(\"feMerge\")\n\n  feMerge.append(\"feMergeNode\")\n\n  feMerge.append(\"feMergeNode\").attr(\"in\", \"SourceGraphic\")\n}\n\nclass NMapChart<Properties> {\n  private readonly config: ChartConfig<Properties>\n  private readonly elements: ChartElements\n  private readonly regionClass: string\n  private readonly state: {\n    drags: Array<{ x: number; y: number }>\n    // Shared marks between all subcharts, could also have different marks per\n    // subchart although UX seems better like this\n    marks: Record<string, boolean>\n  } = {\n    drags: [],\n    marks: {},\n  }\n\n  private constructor(chartConfig: ChartConfig<Properties>) {\n    this.config = chartConfig\n\n    const { areasData, rootElId } = chartConfig\n\n    this.regionClass = `region-${uuidv1().slice(0, 6)}`\n\n    const {\n      objects: { data1: dataRoot },\n    } = areasData\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const { features: dataGeo } = feature(areasData, dataRoot) as any\n\n    const dataGeoParsed = dataGeo.map(\n      (...[areaData, areaIndex]: [DataShape<Properties>, number]) => ({\n        ...areaData,\n        areaIndex,\n      })\n    )\n\n    const rootSel = select<HTMLDivElement, unknown>(`#${rootElId}`)\n\n    const divsSel = rootSel\n      .selectAll(\"div\")\n      .data<unknown>(chartConfig.projectionsCenters)\n      .enter()\n      .append(\"div\")\n      .style(\"border\", \"1px dashed #777\")\n      .style(\"margin\", \"5px\")\n    const svgsSel = divsSel.append(\"svg\")\n    const svgsDragsSel = svgsSel.append(\"g\")\n    const innerGroupsSel = svgsDragsSel.append(\"g\")\n\n    const colorFn = this.areaFillColor.bind(this)\n    const toggleMark = this.toggleMark.bind(this)\n    const refreshAllColors = this.refreshAllColors.bind(this)\n\n    const generateAreas = <Parent extends BaseType | null>({\n      filterId,\n      path,\n      svgComp,\n    }: {\n      filterId: number\n      path: GeoPath<SVGPathElement>\n      svgComp: Selection<SVGGElement, unknown, Parent, unknown>\n    }) => {\n      const svgUpdateSel = svgComp\n        .selectAll(\".area\")\n        .data<DataShape<Properties>>(dataGeoParsed)\n\n      svgUpdateSel.exit().remove()\n      svgUpdateSel\n        .enter()\n        .append(\"path\")\n        .style(\"stroke\", \"#fff\")\n        .style(\"cursor\", \"pointer\")\n        .style(\"filter\", `url(#drop-shadow-${filterId})`)\n        .attr(\"title\", (areaData) =>\n          this.config.getTitleText(areaData.properties)\n        )\n        .attr(\"class\", `${this.regionClass} area`)\n        .call(() => {\n          $(`.${this.regionClass}`).tooltip({\n            track: true,\n          })\n        })\n        .on(\"click\", function handleClick(...[, area]) {\n          toggleMark(area)\n          select<SVGPathElement, DataShape<Properties>>(this).style(\n            \"fill\",\n            colorFn\n          )\n\n          requestAnimationFrame(() => {\n            // Reflect in both charts\n            refreshAllColors()\n          })\n        })\n        .on(\"mouseover\", function onMouseOver() {\n          select(this).style(\"fill\", \"#ffb61a\").style(\"stroke-width\", \"1px\")\n        })\n        .on(\"mouseleave\", function onMouseLeave() {\n          select<SVGPathElement, DataShape<Properties>>(this)\n            .style(\"fill\", colorFn)\n            .style(\"stroke-width\", strokeWidth)\n        })\n\n      svgComp\n        .selectAll<SVGPathElement, DataShape<Properties>>(\".area\")\n        .attr(\"d\", path)\n        .style(\"fill\", colorFn)\n        .style(\"stroke-width\", strokeWidth)\n    }\n\n    const generateProjection = (...[center]: [[number, number], number]) => {\n      // Keep the same scale for all dimensions to improve render performance\n      const scale = 2400\n\n      return geoMercator().center(center).scale(scale)\n    }\n\n    const generatePath = (projection: GeoProjection) =>\n      geoPath().projection(projection)\n\n    const areasPaths = this.config.projectionsCenters\n      .map(generateProjection)\n      .map(generatePath)\n\n    const boundsList = areasPaths.map((projectionPath) =>\n      calculateBounds({\n        featuresData: dataGeoParsed,\n        projectionPath,\n      })\n    )\n\n    innerGroupsSel\n      .data(boundsList)\n      .attr(\n        \"transform\",\n        (bounds) =>\n          `translate(${(bounds[1][0] - bounds[0][0]) / 2},${\n            (bounds[1][1] - bounds[0][1]) / 2\n          })`\n      )\n\n    innerGroupsSel.each(function setupFilter(...[, groupIndex]) {\n      const svgItem = select(this)\n\n      addDropShadowFilter({\n        deviation: 2,\n        id: groupIndex + 1,\n        slope: 0.3,\n        svg: svgItem,\n      })\n\n      generateAreas({\n        filterId: groupIndex + 1,\n        path: areasPaths[groupIndex],\n        svgComp: svgItem,\n      })\n    })\n\n    this.elements = {\n      divsSel,\n      innerGroupsSel,\n      rootSel,\n      svgsDragsSel,\n      svgsSel,\n    }\n\n    this.render()\n    this.setupDrag()\n\n    window.addEventListener(\"resize\", this.handleResize)\n  }\n\n  public static renderChart<Properties>(chartConfig: ChartConfig<Properties>) {\n    return new NMapChart(chartConfig)\n  }\n\n  public teardown() {\n    window.removeEventListener(\"resize\", this.handleResize)\n  }\n\n  public clearMarked() {\n    this.state.marks = {}\n    this.refreshAllColors()\n  }\n\n  private areaFillColor(area: DataShape<Properties>): string {\n    const {\n      config: { areasData },\n    } = this\n    const {\n      objects: { data1: dataRoot },\n    } = areasData\n    const colorScale = scaleLinear()\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      .domain([0, (dataRoot as any).geometries.length])\n      .range([0, 1])\n\n    const colorScaleConversion = scaleLinear<string>()\n      .domain(range(0, 1, 1.0 / colorsScheme.length))\n      .range(colorsScheme)\n\n    if (this.state.marks[area.areaIndex]) {\n      return \"#f00\"\n    }\n\n    return colorScaleConversion(colorScale(area.areaIndex))\n  }\n\n  private refreshAllColors() {\n    const {\n      elements: { innerGroupsSel },\n    } = this\n\n    innerGroupsSel\n      .selectAll<SVGPathElement, DataShape<Properties>>(\".area\")\n      .style(\"fill\", (area) => this.areaFillColor(area))\n  }\n\n  private render() {\n    const {\n      config: { rootElId, widths },\n      elements: { divsSel, rootSel, svgsSel },\n    } = this\n\n    const widthsTotal = widths.reduce((...[acc, curr]) => acc + curr, 0)\n\n    const { width: chartWidth } = (\n      document.getElementById(rootElId) as HTMLElement\n    ).getBoundingClientRect()\n\n    const isSmallDevice = chartWidth < 600\n\n    const getSubChartWidth = (width: number) => {\n      if (isSmallDevice) {\n        return chartWidth\n      }\n\n      return (width / widthsTotal) * chartWidth\n    }\n\n    rootSel\n      .style(\"width\", `100%`)\n      .style(\"justify-content\", \"space-evenly\")\n      .style(\"display\", isSmallDevice ? \"flex\" : \"inline-flex\")\n      .style(\"flex-direction\", isSmallDevice ? \"column\" : \"\")\n\n    divsSel\n      .data(widths)\n      .style(\"display\", \"inline-block\")\n      .style(\"height\", `${height + margin.top + margin.bottom}px`)\n      .style(\"width\", (width) => `${getSubChartWidth(width)}px`)\n\n    svgsSel\n      .data(widths)\n      .attr(\"width\", (width) => getSubChartWidth(width))\n      .attr(\"height\", height + margin.top + margin.bottom)\n  }\n\n  private toggleMark(area: DataShape<Properties>) {\n    this.state.marks[area.areaIndex] = !this.state.marks[area.areaIndex]\n  }\n\n  private updateDrags() {\n    const {\n      elements: { svgsDragsSel },\n    } = this\n\n    const getTranslate = (chartIndex: number) =>\n      `translate(${this.state.drags[chartIndex].x},${this.state.drags[chartIndex].y})`\n\n    svgsDragsSel.each(function updateDrag(...[, chartIndex]) {\n      select(this).attr(\"transform\", getTranslate(chartIndex))\n    })\n  }\n\n  private setupDrag() {\n    const {\n      elements: { svgsSel },\n    } = this\n\n    const getDragHandler =\n      (chartIndex: number) =>\n      (dragEvent: D3DragEvent<SVGSVGElement, unknown, unknown>) => {\n        this.state.drags[chartIndex].x += dragEvent.dx\n        this.state.drags[chartIndex].y += dragEvent.dy\n\n        this.updateDrags()\n      }\n\n    const addDrag = (chartIndex: number) => {\n      this.state.drags[chartIndex] = {\n        x: 0,\n        y: 0,\n      }\n    }\n\n    svgsSel.each(function handleSVG(...[, chartIndex]) {\n      addDrag(chartIndex)\n\n      const handler = getDragHandler(chartIndex)\n      const dragBehavior = dragD3<SVGSVGElement, unknown>().on(\"drag\", handler)\n\n      select(this)\n        .style(\"cursor\", \"move\")\n        .call(dragBehavior)\n        .on(\"drag\", handler)\n    })\n  }\n\n  private readonly handleResize = () => {\n    this.render()\n  }\n}\n\nexport { AreasData, ChartConfig, NMapChart }\n","filePath":"src/demos/spain-map/n-map-chart.ts"},{"content":"import { json } from \"d3\"\n\nimport { AreasData, ChartConfig } from \"./n-map-chart\"\n\nconst CONTAINER_ID = \"chart\"\nconst UPDATE_BUTTON_ID = \"update-button\"\n\ntype Properties = {\n  ENGTYPE_3: string // e.g. Comarca\n  HASC_3: string\n  ID_0: number\n  ID_1: number\n  ID_2: number\n  ID_3: number\n  ISO: string // e.g. ESP\n  NAME_0: string // e.g. Spain\n  NAME_1: string // e.g. Castilla y Leon\n  NAME_2: string // e.g. Leon\n  NAME_3: string // Sometimes not defined, with 'n.a.'\n  NL_NAME_3: string\n  REMARKS_3: string\n  Shape_Area: number // eslint-disable-line camelcase\n  Shape_Leng: number // eslint-disable-line camelcase\n  TYPE_3: string // e.g. Comarca\n  VALIDFR_3: string\n  VALIDTO_3: string\n}\n\ntype Config = ChartConfig<Properties>\n\nconst getTitleText: Config[\"getTitleText\"] = (areaProperties) =>\n  [\n    (areaProperties.NAME_3 || \"\").includes(\"n.a.\") ? \"\" : areaProperties.NAME_3,\n    areaProperties.NAME_2,\n    areaProperties.NAME_1,\n  ]\n    .filter((v) => !!v)\n    .join(\", \")\n\nconst widths: Config[\"widths\"] = (() => {\n  const widthPeninsula = 0.8\n  const widthCanarias = 0.3\n\n  return [widthPeninsula, widthCanarias]\n})()\n\nconst projectionsCenters: Config[\"projectionsCenters\"] = [\n  [12, 31.5],\n  [4, 20],\n]\n\nconst createChartConfig = (areasData: AreasData): Config => ({\n  areasData,\n  getTitleText,\n  projectionsCenters,\n  rootElId: CONTAINER_ID,\n  widths,\n})\n\nconst fetchAreasData = () =>\n  json(\n    `${ROOT_PATH}data/d3js/spain-map/data.json`\n  ) as unknown as Promise<AreasData>\n\nexport {\n  CONTAINER_ID,\n  Properties,\n  UPDATE_BUTTON_ID,\n  createChartConfig,\n  fetchAreasData,\n}\n","filePath":"src/demos/spain-map/spain-map-chart-data.ts"}],"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps, JQUERYUI } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main, {\n  CONTAINER_ID,\n  UPDATE_BUTTON_ID,\n} from \"@/demos/spain-map/spain-map\"\n\nconst SpainMap = ({ pageContext }: DemoPageProps) => (\n  <Demo\n    links={[JQUERYUI.STYLE]}\n    main={main}\n    pageContext={pageContext}\n    scripts={[JQUERYUI.SCRIPT]}\n  >\n    <form style={{ marginBottom: 20 }}>\n      <button className=\"btn btn-info\" id={UPDATE_BUTTON_ID} type=\"button\">\n        Clear Clicked Regions\n      </button>\n    </form>\n    <div id={CONTAINER_ID} />\n  </Demo>\n)\n\nexport default SpainMap\n","type":"tsx"}},"key":"spain-map"},"meta":{"description":"Example of a geographic map using D3.js, where some styles have been added to give it a 3D effect."}}},
    "staticQueryHashes": []}