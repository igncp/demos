{
    "componentChunkName": "component---src-pages-d-3-js-expenses-chord-tsx",
    "path": "/d3js/expenses-chord/",
    "result": {"pageContext":{"demoInfo":{"dataFiles":["data.json"],"docs":[],"isCompleted":false,"name":"Expenses Chord","notes":["TODO: Review checklist for remaining refactors","TODO: add textPath: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/textPath","performance is not great when displaying all elements due to the large number of elements, canvas may be a better solution"],"sources":["https://datos.gob.es/en/catalogo/ea0010587-distribucion-del-gasto-en-destino-de-cada-pais-de-residencia-segun-comunidad-autonoma-gdve-identificador-api-37671","https://observablehq.com/@d3/directed-chord-diagram"],"summary":[],"category":"d3js","files":{"demoCSS":[{"content":".chartWrapper {\n  border: solid 1px black;\n  overflow: hidden;\n}\n\n.chordGroup {\n  cursor: pointer;\n}\n\n.countriesSelect {\n  margin-right: 20px;\n}\n\n.groupText {\n  fill: black;\n  user-select: none;\n}\n\n.ribbon {\n  cursor: pointer;\n  mix-blend-mode: multiply;\n}\n\ndiv.sliderTime {\n  background: #c4dcf9;\n  margin: 20px 0;\n}\n\n.automaticTime {\n  margin-left: 10px;\n  margin-right: 5px;\n}\n","filePath":"src/demos/expenses-chord/expenses-chord.module.css"}],"demoTS":[{"content":"import { renderChart } from \"./expenses-chord-chart\"\nimport {\n  AUTOMATIC_TIME_ID,\n  CONTAINER_ID,\n  COUNTRIES_SELECT_ID,\n  REGIONS_SELECT_ID,\n  SLIDER_TIME_ID,\n  createChartConfig,\n  createInitialState,\n  setupChartForm,\n} from \"./expenses-chord-chart-data\"\nimport { Expenses } from \"./expenses-chord-data-model\"\n\nconst main = async () => {\n  const expenses = await Expenses.fetchAndCreate()\n\n  const state = createInitialState()\n  const chartConfig = createChartConfig({\n    expenses,\n    state,\n  })\n\n  const { renderItems } = renderChart(chartConfig)\n\n  setupChartForm({\n    expenses,\n    renderItems,\n    state,\n  })\n}\n\nexport {\n  AUTOMATIC_TIME_ID,\n  CONTAINER_ID,\n  COUNTRIES_SELECT_ID,\n  REGIONS_SELECT_ID,\n  SLIDER_TIME_ID,\n}\n\nexport default main\n","filePath":"src/demos/expenses-chord/expenses-chord.ts"},{"content":"import { ChartConfig, DisplayType, RibbonType } from \"./expenses-chord-chart\"\nimport { Expenses } from \"./expenses-chord-data-model\"\n\ntype State = {\n  selectedCountry: string\n  selectedRegion: string\n  timeIndex: number\n}\n\nconst CONTAINER_ID = \"chart\"\nconst AUTOMATIC_TIME_ID = \"automatic-time\"\nconst SLIDER_TIME_ID = \"slider-time\"\nconst COUNTRIES_SELECT_ID = \"countries-select\"\nconst REGIONS_SELECT_ID = \"regions-select\"\n\nconst createInitialState = (): State => ({\n  selectedCountry: Expenses.ALL_ID,\n  selectedRegion: Expenses.ALL_ID,\n  timeIndex: 0,\n})\n\nclass CheckboxHandler {\n  private readonly checkbox: HTMLInputElement\n  private readonly onChecked: () => void\n  private readonly onUnchecked: () => void\n\n  public constructor({\n    onChecked,\n    onUnchecked,\n  }: {\n    onChecked: CheckboxHandler[\"onChecked\"]\n    onUnchecked: CheckboxHandler[\"onUnchecked\"]\n  }) {\n    this.onChecked = onChecked\n    this.onUnchecked = onUnchecked\n    this.checkbox = document.getElementById(\n      AUTOMATIC_TIME_ID\n    ) as HTMLInputElement\n  }\n\n  public init() {\n    this.checkbox.setAttribute(\"checked\", \"checked\")\n    this.onChecked()\n    this.checkbox.addEventListener(\"change\", () => {\n      if (this.checkbox.checked) {\n        this.onChecked()\n      } else {\n        this.onUnchecked()\n      }\n    })\n  }\n\n  public uncheck() {\n    this.checkbox.checked = false\n    this.onUnchecked()\n  }\n}\n\nconst createChartConfig = ({\n  expenses,\n  state,\n}: {\n  expenses: Expenses\n  state: State\n}): ChartConfig => {\n  const getChordMatrix: ChartConfig[\"getChordMatrix\"] = () =>\n    expenses.getRelationsMatrix({\n      countryFilter: state.selectedCountry,\n      regionFilter: state.selectedRegion,\n      timeIndexFilter: state.timeIndex,\n    })\n\n  const allNames = expenses.getAllNames()\n\n  const getChordTitle: ChartConfig[\"getChordTitle\"] = (\n    ...[sourceIndex, targetIndex, sourceValue]\n  ) =>\n    `People from \"${allNames[sourceIndex]}\" spend into \"${allNames[targetIndex]}\": ${sourceValue}`\n\n  const getChordGroupTitle: ChartConfig[\"getChordGroupTitle\"] = (\n    chordItemLabel\n  ) => chordItemLabel\n\n  const getRibbonGroupIdColor: ChartConfig[\"getRibbonGroupIdColor\"] = (\n    ...[sourceGroupId, targetGroupId]\n  ) =>\n    state.selectedRegion === Expenses.ALL_ID ? targetGroupId : sourceGroupId\n\n  const getDisplayTypeOnGroupClick: ChartConfig[\"getDisplayTypeOnGroupClick\"] =\n    (chordGroupId) =>\n      expenses.getCountriesList().includes(chordGroupId)\n        ? DisplayType.Source\n        : DisplayType.Target\n\n  const getRibbonType: ChartConfig[\"getRibbonType\"] = () =>\n    state.selectedCountry !== Expenses.ALL_ID &&\n    state.selectedRegion !== Expenses.ALL_ID\n      ? RibbonType.Common\n      : RibbonType.Arrow\n\n  return {\n    chordGroupsIds: allNames,\n    getChordGroupTitle,\n    getChordMatrix,\n    getChordTitle,\n    getDisplayTypeOnGroupClick,\n    getRibbonGroupIdColor,\n    getRibbonType,\n    rootElId: CONTAINER_ID,\n  }\n}\n\nconst setupChartForm = ({\n  expenses,\n  renderItems,\n  state,\n}: {\n  expenses: Expenses\n  renderItems: () => void\n  state: State\n}) => {\n  const sliderMaxValue = expenses.getTimeFramesNumber()\n\n  $(`#${SLIDER_TIME_ID}`).slider({\n    change: (...[, { value: timeValue }]) => {\n      if (timeValue === 3) {\n        // @TODO: error in this case, find why\n        return\n      }\n\n      state.timeIndex = timeValue!\n      renderItems()\n    },\n    max: sliderMaxValue,\n    min: 0,\n  })\n\n  const setupSelect = ({\n    id,\n    onChange,\n    selectOptions,\n  }: {\n    id: string\n    onChange: (v: string) => void\n    selectOptions: string[]\n  }) => {\n    const selectEl = document.getElementById(id) as HTMLSelectElement\n\n    ;[Expenses.ALL_ID].concat(selectOptions).forEach((selectOption) => {\n      const option = document.createElement(\"option\")\n\n      option.setAttribute(\"value\", selectOption)\n      option.innerText = selectOption\n\n      selectEl.appendChild(option)\n    })\n\n    selectEl.addEventListener(\"change\", () => {\n      onChange(selectEl.value)\n    })\n  }\n\n  setupSelect({\n    id: COUNTRIES_SELECT_ID,\n    onChange: (newSelected: string) => {\n      state.selectedCountry = newSelected\n      renderItems()\n    },\n    selectOptions: expenses.getCountriesList(),\n  })\n  setupSelect({\n    id: REGIONS_SELECT_ID,\n    onChange: (newSelected: string) => {\n      state.selectedRegion = newSelected\n      renderItems()\n    },\n    selectOptions: expenses.getRegionsList(),\n  })\n\n  let timeoutId: number | null = null\n  const checkboxHandler = new CheckboxHandler({\n    onChecked: () => {\n      clearInterval(timeoutId!)\n      timeoutId = window.setInterval(() => {\n        const currentValue = $(`#${SLIDER_TIME_ID}`).slider(\"value\")\n        const nextValue = currentValue + 1\n\n        $(`#${SLIDER_TIME_ID}`).slider(\"value\", nextValue)\n\n        if (nextValue >= sliderMaxValue) {\n          checkboxHandler.uncheck()\n        }\n      }, 2000)\n    },\n    onUnchecked: () => {\n      clearInterval(timeoutId!)\n    },\n  })\n\n  checkboxHandler.init()\n}\n\nexport {\n  AUTOMATIC_TIME_ID,\n  CONTAINER_ID,\n  COUNTRIES_SELECT_ID,\n  REGIONS_SELECT_ID,\n  SLIDER_TIME_ID,\n  createChartConfig,\n  createInitialState,\n  setupChartForm,\n}\n","filePath":"src/demos/expenses-chord/expenses-chord-chart-data.ts"},{"content":"import {\n  BaseType,\n  Chord,\n  ChordGroup,\n  D3DragEvent,\n  Selection,\n  arc as arcD3,\n  chordDirected,\n  descending as descendingD3,\n  drag,\n  easeCircle,\n  interpolate,\n  ribbonArrow as ribbonArrowD3,\n  ribbon as ribbonD3,\n  scaleOrdinal,\n  schemeTableau10,\n  select,\n} from \"d3\"\nimport { v1 as uuid } from \"uuid\"\n\nimport * as styles from \"./expenses-chord.module.css\"\n\nconst height = 800\nconst elementDefaultOpacity = 0.7\n\nenum DisplayType {\n  Source = \"source\",\n  Target = \"target\",\n}\n\nenum RibbonType {\n  Arrow = \"arrow\",\n  Common = \"common\",\n}\n\ntype ChartState = {\n  lastFocused: string | null\n}\n\nconst durations = {\n  ribbonAnimation: 1000,\n  zoom: 500,\n} as const\n\nconst easingFn = easeCircle\n\nconst applyOpacityEffect = <ContainerEl extends BaseType, Datum>(\n  elementsSelection: Selection<ContainerEl, Datum, BaseType, unknown>\n) => {\n  elementsSelection\n    .style(\"opacity\", elementDefaultOpacity)\n    .on(\"mouseenter\", function onMouseEnter() {\n      select(this).style(\"opacity\", 1)\n    })\n    .on(\"mouseleave\", function onMouseLeave() {\n      select(this).style(\"opacity\", elementDefaultOpacity)\n    })\n}\n\nconst filterBlackOpacity = ({\n  deviation,\n  id,\n  slope,\n  svg,\n}: {\n  deviation: number\n  id: string\n  slope: number\n  svg: Selection<SVGSVGElement, unknown, HTMLElement, unknown>\n}) => {\n  const defs = svg.append(\"defs\")\n  const filter = defs\n    .append(\"filter\")\n    .attr(\"height\", \"500%\")\n    .attr(\"id\", `drop-shadow-${id}`)\n    .attr(\"width\", \"500%\")\n    .attr(\"x\", \"-200%\")\n    .attr(\"y\", \"-200%\")\n\n  filter\n    .append(\"feGaussianBlur\")\n    .attr(\"in\", \"SourceAlpha\")\n    .attr(\"stdDeviation\", deviation)\n\n  filter.append(\"feOffset\").attr(\"dx\", 1).attr(\"dy\", 1)\n  filter\n    .append(\"feComponentTransfer\")\n    .append(\"feFuncA\")\n    .attr(\"slope\", slope)\n    .attr(\"type\", \"linear\")\n\n  const feMerge = filter.append(\"feMerge\")\n\n  feMerge.append(\"feMergeNode\")\n\n  feMerge.append(\"feMergeNode\").attr(\"in\", \"SourceGraphic\")\n}\n\n// @TODO: setup drag with zoom\nconst setupDrag = ({\n  svgDrag,\n  svgTop,\n}: {\n  svgDrag: Selection<SVGGElement, unknown, HTMLElement, unknown>\n  svgTop: Selection<SVGSVGElement, unknown, HTMLElement, unknown>\n}) => {\n  const draggedState = {\n    s: 1,\n    x: 0,\n    y: 0,\n  }\n\n  const setupTransform = () => {\n    svgDrag.attr(\n      \"transform\",\n      `translate(${draggedState.x},${draggedState.y}) scale(${draggedState.s})`\n    )\n  }\n\n  const dragHandler = drag<SVGSVGElement, unknown>().on(\n    \"drag\",\n    (dragEvent: D3DragEvent<SVGSVGElement, unknown, unknown>) => {\n      draggedState.x += dragEvent.dx\n      draggedState.y += dragEvent.dy\n\n      setupTransform()\n    }\n  )\n\n  setupTransform()\n\n  svgTop\n    .style(\"cursor\", \"move\")\n    .call(dragHandler)\n    .on(\"wheel\", (wheelEvent: WheelEvent) => {\n      wheelEvent.preventDefault()\n\n      draggedState.s += -wheelEvent.deltaY / 1000\n\n      setupTransform()\n    })\n}\n\ntype ChartConfig = {\n  chordGroupsIds: string[]\n  getChordGroupTitle: (groupId: string) => string\n  getChordMatrix: () => number[][]\n  getChordTitle: (\n    sourceIndex: number,\n    targetIndex: number,\n    sourceValue: number,\n    targetValue: number\n  ) => string\n  getDisplayTypeOnGroupClick: (chordGroupId: string) => DisplayType\n  getRibbonGroupIdColor: (\n    sourceGroupId: string,\n    targetGroupId: string\n  ) => string\n  getRibbonType: () => RibbonType\n  rootElId: string\n}\n\nconst renderChart = (chartConfig: ChartConfig) => {\n  const { rootElId } = chartConfig\n\n  const chartState: ChartState = {\n    lastFocused: null,\n  }\n\n  const { chordGroupsIds } = chartConfig\n\n  const color = scaleOrdinal(chordGroupsIds, schemeTableau10)\n\n  const { width } = (\n    document.getElementById(rootElId) as HTMLElement\n  ).getBoundingClientRect()\n\n  const innerRadius = Math.min(width, height) * 0.5 - 20\n  const outerRadius = innerRadius + 20\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const ribbonCommon = (ribbonType: any) =>\n    ribbonType.radius(innerRadius - 0.5).padAngle(1 / innerRadius)\n\n  const ribbonArrow = ribbonCommon(ribbonArrowD3())\n  const ribbon = ribbonCommon(ribbonD3())\n\n  const totalHeight = height + 50\n\n  const svgTop = select(`#${rootElId}`)\n    .attr(\"class\", styles.chartWrapper)\n    .append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", totalHeight)\n\n  filterBlackOpacity({\n    deviation: 2,\n    id: \"groups\",\n    slope: 0.5,\n    svg: svgTop,\n  })\n\n  const svgCenter = svgTop\n    .append(\"g\")\n    .attr(\"transform\", `translate(${width / 2}, ${totalHeight / 2})`)\n\n  const svgG = svgCenter.append(\"g\").attr(\"class\", \"svg-drag\")\n\n  setupDrag({\n    svgDrag: svgG,\n    svgTop,\n  })\n\n  // this rect is to allow zooming\n  svgG\n    .append(\"rect\")\n    .attr(\"fill\", \"#fff\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"transform\", `translate(-${width / 2}, -${totalHeight / 2})`)\n\n  const textId = uuid()\n\n  const chord = chordDirected()\n    .padAngle(12 / innerRadius)\n    .sortSubgroups(descendingD3)\n    .sortChords(descendingD3)\n\n  svgG\n    .append(\"path\")\n    .attr(\"fill\", \"none\")\n    .attr(\"id\", textId)\n    .attr(\n      \"d\",\n      arcD3()({\n        endAngle: 2 * Math.PI,\n        innerRadius: 0,\n        outerRadius,\n        startAngle: 0,\n      }) as string\n    )\n\n  const arc = arcD3<d3.ChordGroup>()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  const ribbonContainer = svgG.append(\"g\")\n  const groupContainer = svgG\n    .append(\"g\")\n    .attr(\"font-family\", \"sans-serif\")\n    .attr(\"font-size\", 10)\n\n  const getRibbonKey = (ribbonNode: Chord) =>\n    `${ribbonNode.source.index}_${ribbonNode.target.index}`\n\n  const renderItems = () => {\n    const usedRibbon =\n      chartConfig.getRibbonType() === RibbonType.Common ? ribbon : ribbonArrow\n\n    const matrix = chartConfig.getChordMatrix()\n    const chords = chord(matrix)\n\n    const initialRibbonsData = ribbonContainer\n      .selectAll<SVGPathElement, Chord>(`.${styles.ribbon}`)\n      .data()\n      .reduce<{ [k: string]: Chord | undefined }>((...[acc, ribbonNode]) => {\n        acc[getRibbonKey(ribbonNode)] = ribbonNode\n\n        return acc\n      }, {})\n\n    const fillRibbon = (chordItem: Chord) =>\n      color(\n        chartConfig.getRibbonGroupIdColor(\n          chordGroupsIds[chordItem.source.index],\n          chordGroupsIds[chordItem.target.index]\n        )\n      )\n\n    const ribbons = ribbonContainer\n      .selectAll<SVGPathElement, Chord>(`.${styles.ribbon}`)\n      .data<Chord>(chords, (chordItem) => getRibbonKey(chordItem))\n      .join(\n        (enter) => {\n          const enterSelection = enter\n            .append(\"path\")\n            .attr(\"class\", styles.ribbon)\n            .attr(\"fill\", fillRibbon)\n\n          applyOpacityEffect(enterSelection)\n\n          return enterSelection\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .attrTween(\"d\", (finalRibbon) => {\n              const initialRibbon = {\n                source: {\n                  endAngle: 0,\n                  startAngle: 0,\n                },\n                target: {\n                  endAngle: 0,\n                  startAngle: 0,\n                },\n              }\n              const interpolateSource = interpolate(\n                initialRibbon.source,\n                finalRibbon.source\n              )\n              const interpolateTarget = interpolate(\n                initialRibbon.target,\n                finalRibbon.target\n              )\n\n              return (t) => {\n                const interpolated = {\n                  source: interpolateSource(t),\n                  target: interpolateTarget(t),\n                }\n\n                return usedRibbon(interpolated)\n              }\n            })\n        },\n        (update) => {\n          update\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .attr(\"fill\", fillRibbon)\n            .attrTween(\"d\", (finalRibbon) => {\n              const { [getRibbonKey(finalRibbon)]: initialRibbon } =\n                initialRibbonsData\n\n              if (!initialRibbon) {\n                return () => usedRibbon(finalRibbon)\n              }\n\n              const interpolateSource = interpolate(\n                initialRibbon.source,\n                finalRibbon.source\n              )\n              const interpolateTarget = interpolate(\n                initialRibbon.target,\n                finalRibbon.target\n              )\n\n              return (t) => {\n                const interpolated = {\n                  source: interpolateSource(t),\n                  target: interpolateTarget(t),\n                }\n\n                return usedRibbon(interpolated)\n              }\n            })\n\n          return update\n        }\n      )\n\n    ribbons\n      .attr(\"title\", (chordItem) =>\n        chartConfig.getChordTitle(\n          chordItem.source.index,\n          chordItem.target.index,\n          chordItem.source.value,\n          chordItem.target.value\n        )\n      )\n      .on(\"click\", function onChordClick(...[, chordItem]) {\n        const chordSelection = select(this)\n        const chordGroupId = `${chordGroupsIds[chordItem.source.index]}_${\n          chordGroupsIds[chordItem.target.index]\n        }`\n\n        if (chartState.lastFocused === chordGroupId) {\n          ribbons.attr(\"display\", \"block\")\n          chartState.lastFocused = null\n        } else {\n          ribbons.attr(\"display\", \"none\")\n          chordSelection.attr(\"display\", \"block\")\n          chartState.lastFocused = chordGroupId\n        }\n      })\n\n    $(`.${styles.ribbon}`).tooltip({\n      track: true,\n    })\n\n    const getGroupText = (chordItem: ChordGroup) => {\n      if (chordItem.endAngle - chordItem.startAngle < 0.07) {\n        return \"\"\n      }\n\n      return chartConfig.getChordGroupTitle(chordGroupsIds[chordItem.index])\n    }\n\n    const initialGroupData = groupContainer\n      .selectAll(`.${styles.chordGroup}`)\n      .data()\n\n    groupContainer\n      .selectAll<SVGGElement, ChordGroup>(`.${styles.chordGroup}`)\n      .data<ChordGroup>(chords.groups, (chordGroup) => chordGroup.index)\n      .join(\n        (enter) => {\n          const groupSelection = enter\n            .append(\"g\")\n            .attr(\"class\", styles.chordGroup)\n            .attr(\"title\", (groupItem) =>\n              chartConfig.getChordGroupTitle(chordGroupsIds[groupItem.index])\n            )\n            .style(\"filter\", \"url(#drop-shadow-groups)\")\n\n          applyOpacityEffect(groupSelection)\n\n          groupSelection\n            .append(\"path\")\n            .attr(\"class\", \"group-path\")\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .ease(easingFn)\n            .attrTween(\"d\", (finalGroup) => {\n              const interpolateFn = interpolate<ChordGroup>(\n                {\n                  ...finalGroup,\n                  endAngle: 0,\n                  startAngle: 0,\n                },\n                finalGroup\n              )\n\n              return (t) => arc(interpolateFn(t))!\n            })\n            .attr(\"fill\", (groupItem) => color(chordGroupsIds[groupItem.index]))\n            .attr(\"stroke\", \"#fff\")\n\n          groupSelection\n            .append(\"text\")\n            .attr(\"dy\", -3)\n            .append(\"textPath\")\n            .attr(\"xlink:href\", `#${textId}`)\n            .attr(\"class\", styles.groupText)\n            .text(getGroupText)\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .ease(easingFn)\n            .attr(\n              \"startOffset\",\n              (groupItem) => groupItem.startAngle * outerRadius\n            )\n\n          groupSelection.on(\"click\", (...[, groupItem]) => {\n            const { [groupItem.index]: chordGroupId } = chordGroupsIds\n            const latestRibbons = ribbonContainer.selectAll<\n              SVGPathElement,\n              Chord\n            >(`.${styles.ribbon}`)\n\n            if (chartState.lastFocused === chordGroupId) {\n              latestRibbons.attr(\"display\", () => \"block\")\n              chartState.lastFocused = null\n\n              return\n            }\n\n            chartState.lastFocused = chordGroupId\n\n            if (\n              chartConfig.getDisplayTypeOnGroupClick(chordGroupId) ===\n              DisplayType.Source\n            ) {\n              latestRibbons.attr(\"display\", (otherGroupItem) =>\n                otherGroupItem.source.index === groupItem.index\n                  ? \"block\"\n                  : \"none\"\n              )\n\n              return\n            }\n\n            latestRibbons.attr(\"display\", (otherGroupItem) =>\n              otherGroupItem.target.index === groupItem.index ? \"block\" : \"none\"\n            )\n          })\n\n          $(`.${styles.chordGroup}`).tooltip({\n            track: true,\n          })\n\n          return groupSelection\n        },\n        (update) => {\n          update\n            .select(\".group-path\")\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .attrTween(\"d\", (...[finalGroup, finalGroupIndex]) => {\n              const { [finalGroupIndex]: initialGroup } = initialGroupData\n              const interpolateFn = interpolate(initialGroup, finalGroup)\n\n              return (t) => arc(interpolateFn(t)) as string\n            })\n\n          update\n            .select(`.${styles.groupText}`)\n            .text(getGroupText)\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .attr(\n              \"startOffset\",\n              (groupItem) => groupItem.startAngle * outerRadius\n            )\n\n          return update\n        },\n        (exit) => exit.remove()\n      )\n      .attr(\"class\", styles.chordGroup)\n  }\n\n  renderItems()\n\n  return {\n    renderItems,\n  }\n}\n\nexport { DisplayType, RibbonType, ChartConfig, renderChart }\n","filePath":"src/demos/expenses-chord/expenses-chord-chart.ts"},{"content":"import { json } from \"d3\"\n\ntype DataItem = {\n  value: number | null // eslint-disable-line id-denylist\n  year: number\n}\n\n/**\n * The data types are encapsulated and not shared\n */\ntype ExpensesData = {\n  [country: string]: {\n    [region: string]: DataItem[]\n  }\n}\n\nclass Expenses {\n  public static ALL_ID = \"All\"\n\n  private readonly countries: string[]\n  private readonly expensesData: ExpensesData\n  private readonly names: string[]\n  private readonly regions: string[]\n\n  private constructor(expensesData: ExpensesData) {\n    const countries = Object.keys(expensesData).sort()\n\n    this.countries = countries\n    this.regions = Object.keys(expensesData[countries[0]]).sort()\n    this.expensesData = expensesData\n    this.names = countries.concat(this.regions)\n  }\n\n  public static async fetchAndCreate(): Promise<Expenses> {\n    const expensesData = (await (json(\n      `${ROOT_PATH}data/d3js/expenses-chord/data.json`\n    ) as unknown)) as ExpensesData\n\n    return new Expenses(expensesData)\n  }\n\n  public getRelationsMatrix({\n    countryFilter,\n    regionFilter,\n    timeIndexFilter,\n  }: {\n    countryFilter: string\n    regionFilter: string\n    timeIndexFilter: number\n  }): number[][] {\n    const { expensesData, names } = this\n\n    return names.map((maybeCountry) => {\n      if (!expensesData[maybeCountry] as unknown) {\n        return names.map(() => 0)\n      }\n\n      if (![Expenses.ALL_ID, maybeCountry].includes(countryFilter)) {\n        return names.map(() => 0)\n      }\n\n      return names.map((maybeRegion) => {\n        const {\n          [maybeCountry]: { [maybeRegion]: dataItem },\n        } = expensesData\n\n        if (!dataItem as unknown) {\n          return 0\n        }\n\n        if (![Expenses.ALL_ID, maybeRegion].includes(regionFilter)) {\n          return 0\n        }\n\n        return dataItem[timeIndexFilter].value\n      })\n    }) as number[][]\n  }\n\n  public getTimeFramesNumber(): number {\n    const { countries, expensesData, regions } = this\n\n    return expensesData[countries[0]][regions[0]].length - 1\n  }\n\n  public getCountriesList(): Expenses[\"countries\"] {\n    return this.countries.slice()\n  }\n\n  public getRegionsList(): Expenses[\"regions\"] {\n    return this.regions.slice()\n  }\n\n  public getAllNames(): Expenses[\"names\"] {\n    return this.names.slice()\n  }\n}\n\nexport { Expenses }\n","filePath":"src/demos/expenses-chord/expenses-chord-data-model.ts"}],"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps, JQUERYUI } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main, {\n  AUTOMATIC_TIME_ID,\n  CONTAINER_ID,\n  COUNTRIES_SELECT_ID,\n  REGIONS_SELECT_ID,\n  SLIDER_TIME_ID,\n} from \"@/demos/expenses-chord/expenses-chord\"\nimport * as styles from \"@/demos/expenses-chord/expenses-chord.module.css\"\n\nconst ExpensesChord = ({ pageContext }: DemoPageProps) => (\n  <Demo\n    links={[JQUERYUI.STYLE]}\n    main={main}\n    pageContext={pageContext}\n    scripts={[JQUERYUI.SCRIPT]}\n  >\n    <div>Time Item:</div>\n    <div className={styles.sliderTime} id={SLIDER_TIME_ID} />\n    <p>\n      <span>Countries:</span>\n      <select className={styles.countriesSelect} id={COUNTRIES_SELECT_ID} />\n      <span>Regions:</span>\n      <select id={REGIONS_SELECT_ID} />\n      <span className={styles.automaticTime}>Automatic Time Change:</span>\n      <input id={AUTOMATIC_TIME_ID} type=\"checkbox\" />\n    </p>\n    <div id={CONTAINER_ID} />\n  </Demo>\n)\n\nexport default ExpensesChord\n","type":"tsx"}},"key":"expenses-chord"},"meta":{"description":""}}},
    "staticQueryHashes": []}