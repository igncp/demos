{
    "componentChunkName": "component---src-pages-d-3-js-concentric-circles-tsx",
    "path": "/d3js/concentric-circles/",
    "result": {"pageContext":{"demoInfo":{"dataFiles":[],"docs":[],"isCompleted":true,"name":"Concentric Circles","notes":["Data of baby names in New York 2012","Custom color scale","Added box shadow filter"],"sources":["http://codepen.io/notno/pen/wgyAz","http://bl.ocks.org/cpbotha/5200394","http://stackoverflow.com/questions/17671252/d3-create-a-continous-color-scale-with-many-strings-inputs-for-the-range-and-dy"],"summary":[],"category":"d3js","files":{"demoCSS":[],"demoTS":[{"content":"import {\n  Selection,\n  csv,\n  extent,\n  max,\n  range,\n  scaleLinear,\n  scalePow,\n  select,\n} from \"d3\"\n\nconst CONTAINER_ID = \"chart\"\n\ntype NamesMetric = {\n  count: string\n  name: string\n  sex: string\n  year: string\n}\ntype NamesMetrics = NamesMetric[]\ntype SVG = Selection<SVGGElement, unknown, HTMLElement, unknown>\n\nconst fetchData = async (): Promise<NamesMetrics> => {\n  const response = await csv(\n    `${ROOT_PATH}data/d3js/concentric-circles/data.csv`\n  )\n\n  return response as unknown as NamesMetrics\n}\n\nconst colours = [\"#7C7CC9\", \"#52D552\", \"#337233\", \"#323247\"]\n\nconst margin = {\n  bottom: 20,\n  left: 20,\n  right: 20,\n  top: 20,\n}\nconst strokeWidth = \"2px\"\n\nconst addFilter = (svg: SVG) => {\n  const defs = svg.append(\"defs\")\n  const filter = defs.append(\"filter\")\n\n  filter.attr(\"id\", \"drop-shadow\")\n  filter\n    .append(\"feGaussianBlur\")\n    .attr(\"in\", \"SourceAlpha\")\n    .attr(\"stdDeviation\", 9)\n  filter.append(\"feOffset\").attr(\"dx\", 5).attr(\"dy\", 5)\n  filter\n    .append(\"feComponentTransfer\")\n    .append(\"feFuncA\")\n    .attr(\"slope\", \".3\")\n    .attr(\"type\", \"linear\")\n\n  const feMerge = filter.append(\"feMerge\")\n\n  feMerge.append(\"feMergeNode\")\n  feMerge.append(\"feMergeNode\").attr(\"in\", \"SourceGraphic\")\n}\n\ntype AddDescription = (options: {\n  height: number\n  svg: SVG\n  width: number\n}) => void\n\nconst addDescription: AddDescription = ({ height, svg, width }) => {\n  svg\n    .append(\"text\")\n    .text(\n      \"Circles radius are proportional to the count of times the name appears\"\n    )\n    .attr(\"transform\", `translate(${width / 2},${height - 10})`)\n    .attr(\"width\", \"20px\")\n}\n\ntype RenderChart = (chartConfig: {\n  namesMetrics: NamesMetrics\n  rootElId: string\n}) => void\n\nconst renderChart: RenderChart = ({ namesMetrics, rootElId }) => {\n  const c = scaleLinear()\n    .domain(\n      extent(namesMetrics, (namesMetric) => +namesMetric.count) as [\n        number,\n        number\n      ]\n    )\n    .range([0, 1])\n\n  const heatmapColour = scaleLinear<string>()\n    .domain(range(0, 1, 1.0 / colours.length))\n    .range(colours)\n\n  const colorize = (namesMetric: NamesMetric) => {\n    const colorNormalized = c(+namesMetric.count)\n\n    return heatmapColour(colorNormalized)\n  }\n\n  const rootEl = document.getElementById(rootElId) as HTMLElement\n  const { width: elWidth } = rootEl.getBoundingClientRect()\n\n  const width = elWidth - margin.left - margin.right\n  const height =\n    (max(namesMetrics, (namesMetric) => +namesMetric.count) as number) * 2.5\n\n  const svg: SVG = select(`#${rootElId}`)\n    .append(\"svg\")\n    .attr(\"width\", width + margin.left + margin.right)\n    .attr(\"height\", height + margin.left + margin.right)\n    .append(\"g\")\n\n  addFilter(svg)\n\n  const circleGroup = svg\n    .selectAll<SVGGElement, NamesMetric>(\"g\")\n    .data(namesMetrics, (namesMetric: NamesMetric) => namesMetric.name)\n    .enter()\n    .append(\"g\")\n\n  const circles = circleGroup.append<SVGCircleElement>(\"svg:circle\")\n  const rScale = scalePow()\n    .exponent(0.9)\n    .range([5, 300])\n    .domain(\n      extent(namesMetrics, (namesMetric) => +namesMetric.count) as [\n        number,\n        number\n      ]\n    )\n\n  const getTitle = (namesMetric: NamesMetrics[number]) =>\n    `${namesMetric.name}: ${namesMetric.count}`\n  const dataMax = max(\n    namesMetrics,\n    (namesMetric) => +namesMetric.count\n  ) as number\n\n  circles\n    .attr(\"cx\", width / 2)\n    .attr(\"cy\", height / 2)\n    .attr(\"r\", (namesMetric) => rScale(+namesMetric.count))\n    .attr(\"class\", \"name-circle\")\n    .attr(\"title\", getTitle)\n    .style(\"fill\", \"#fff\")\n    .style(\"stroke\", (namesMetric) => colorize(namesMetric))\n    .style(\"stroke-width\", strokeWidth)\n    .style(\"filter\", (namesMetric) => {\n      if (+namesMetric.count > dataMax / 2.5) {\n        return \"url(#drop-shadow)\"\n      }\n\n      return \"\"\n    })\n    .on(\"mouseover\", function onMouseOver() {\n      select(this).style(\"stroke\", \"#D88021\").style(\"stroke-width\", \"10px\")\n    })\n    .on(\"mouseleave\", function onMouseLeave() {\n      select<SVGCircleElement, NamesMetric>(this)\n        .style(\"stroke\", (namesMetric) => colorize(namesMetric))\n        .style(\"stroke-width\", strokeWidth)\n    })\n\n  $(\".name-circle\").tooltip({\n    track: true,\n  })\n\n  addDescription({\n    height,\n    svg,\n    width,\n  })\n}\n\nconst main = async () => {\n  const namesMetrics = await fetchData()\n\n  renderChart({\n    namesMetrics,\n    rootElId: CONTAINER_ID,\n  })\n}\n\nexport { CONTAINER_ID }\n\nexport default main\n","fileName":"concentric-circles.ts"}],"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps, JQUERYUI } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main, {\n  CONTAINER_ID,\n} from \"@/demos/concentric-circles/concentric-circles\"\n\nconst ConcentricCircles = ({ pageContext }: DemoPageProps) => (\n  <Demo\n    links={[JQUERYUI.STYLE]}\n    main={main}\n    pageContext={pageContext}\n    scripts={[JQUERYUI.SCRIPT]}\n  >\n    <div id={CONTAINER_ID} />\n  </Demo>\n)\n\nexport default ConcentricCircles\n","type":"tsx"}},"key":"concentric-circles"},"meta":{"description":"Concentric circles example using D3.js, with a non repeated series of data and with a new style that heavily uses the svg drop-shadow type filter."}}},
    "staticQueryHashes": []}