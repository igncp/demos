{
    "componentChunkName": "component---src-pages-d-3-js-concentric-circles-tsx",
    "path": "/d3js/concentric-circles/",
    "result": {"pageContext":{"demoInfo":{"dataFiles":[],"docs":[],"isCompleted":true,"name":"Concentric Circles","notes":["Data of baby names in New York 2012","Custom color scale","Added box shadow filter"],"sources":["http://codepen.io/notno/pen/wgyAz","http://bl.ocks.org/cpbotha/5200394","http://stackoverflow.com/questions/17671252/d3-create-a-continous-color-scale-with-many-strings-inputs-for-the-range-and-dy"],"summary":[],"category":"d3js","files":{"demoCSS":[],"demoTS":[{"content":"import { CirclesChart } from \"./circles-chart\"\nimport {\n  CONTAINER_ID,\n  ZOOM_SLIDER_ID,\n  fetchData,\n  getChartConfig,\n} from \"./concentric-circles-config\"\n\nconst main = async () => {\n  const namesMetrics = await fetchData()\n  const { defaultZoom } = CirclesChart\n\n  const chartConfig = getChartConfig({\n    namesMetrics,\n  })\n\n  const chart = CirclesChart.renderChart(chartConfig)\n\n  $(`#${ZOOM_SLIDER_ID}`).slider({\n    change: (...[, { value: zoomValue }]) => {\n      chart.setZoom(zoomValue as number)\n    },\n    max: 100,\n    min: defaultZoom,\n    value: defaultZoom, // eslint-disable-line id-denylist\n  })\n}\n\nexport { CONTAINER_ID, ZOOM_SLIDER_ID }\n\nexport default main\n","filePath":"src/demos/concentric-circles/concentric-circles.ts"},{"content":"import {\n  D3DragEvent,\n  Selection,\n  drag,\n  interpolateCool,\n  max,\n  scaleLinear,\n  scaleOrdinal,\n  select,\n} from \"d3\"\nimport { v1 as uuidv1 } from \"uuid\"\n\nconst margin = {\n  bottom: 20,\n  left: 20,\n  right: 20,\n  top: 20,\n}\n\n// https://stackoverflow.com/questions/2916081/zoom-in-on-a-point-using-scale-and-translate\nconst getNewDrag = ({\n  baseZoom,\n  newZoom,\n  prevDragX,\n  prevDragY,\n  prevZoom,\n  zoomPoint,\n}: {\n  baseZoom: number\n  newZoom: number\n  prevDragX: number\n  prevDragY: number\n  prevZoom: number\n  zoomPoint: { x: number; y: number }\n}) => {\n  const scalechange = (newZoom - prevZoom) / baseZoom\n  const offsetX = -(zoomPoint.x * scalechange)\n  const offsetY = -(zoomPoint.y * scalechange)\n\n  return {\n    x: prevDragX + offsetX,\n    y: prevDragY + offsetY,\n  }\n}\n\ntype ChartConfig<ChartData> = Readonly<{\n  chartDescription: string\n  circlesData: ChartData[]\n  getCircleId: (circle: ChartData) => string\n  getCircleTitle: (circle: ChartData) => string\n  getCircleValue: (circle: ChartData) => number\n  rootElId: string\n}>\n\ntype ChartElements<ChartData> = Readonly<{\n  descriptionSel: Selection<SVGTextElement, ChartData, HTMLElement, unknown>\n  dragSel: Selection<SVGGElement, ChartData, HTMLElement, unknown>\n  gSel: Selection<SVGGElement, ChartData, HTMLElement, unknown>\n  rootSel: Selection<HTMLElement, ChartData, HTMLElement, unknown>\n  svgSel: Selection<SVGSVGElement, ChartData, HTMLElement, unknown>\n}>\n\nclass CirclesChart<ChartData> {\n  public static defaultZoom = 10\n\n  private readonly config: ChartConfig<ChartData>\n  private readonly elements: ChartElements<ChartData>\n  private readonly circleClass: string\n  private readonly state: {\n    dragX: number\n    dragY: number\n    selectedCircles: Record<string, boolean>\n    zoom: number\n  } = {\n    dragX: 0,\n    dragY: 0,\n    selectedCircles: {},\n    zoom: CirclesChart.defaultZoom,\n  }\n\n  private constructor(config: ChartConfig<ChartData>) {\n    this.config = config\n\n    const rootSel = select<HTMLElement, ChartData>(`#${config.rootElId}`)\n    const svgSel = rootSel.append(\"svg\")\n    const dragSel = svgSel.append(\"g\")\n    const gSel = dragSel.append(\"g\")\n    const descriptionSel = gSel\n      .append(\"text\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"width\", \"20px\")\n\n    this.circleClass = `name-circle-${uuidv1().slice(0, 6)}`\n\n    this.elements = {\n      descriptionSel,\n      dragSel,\n      gSel,\n      rootSel,\n      svgSel,\n    }\n\n    this.setupDrag()\n    this.render()\n\n    window.addEventListener(\"resize\", this.handleResize)\n  }\n\n  public static renderChart<ChartData>(config: ChartConfig<ChartData>) {\n    return new CirclesChart(config)\n  }\n\n  public teardown() {\n    window.removeEventListener(\"resize\", this.handleResize)\n  }\n\n  public setZoom(zoom: number) {\n    const { height, width } = this.getDimensions()\n\n    const newDrag = getNewDrag({\n      baseZoom: CirclesChart.defaultZoom,\n      newZoom: zoom,\n      prevDragX: this.state.dragX,\n      prevDragY: this.state.dragY,\n      prevZoom: this.state.zoom,\n      zoomPoint: { x: width / 2, y: height / 2 },\n    })\n\n    this.state.zoom = zoom\n    this.state.dragX = newDrag.x\n    this.state.dragY = newDrag.y\n\n    this.updateDrag()\n  }\n\n  private updateDrag() {\n    const {\n      elements: { dragSel },\n    } = this\n\n    dragSel.attr(\n      \"transform\",\n      `translate(${this.state.dragX},${this.state.dragY}) scale(${\n        this.state.zoom / CirclesChart.defaultZoom\n      })`\n    )\n  }\n\n  private setupDrag() {\n    const {\n      elements: { svgSel },\n    } = this\n\n    const dragHandler = drag<SVGSVGElement, ChartData>().on(\n      \"drag\",\n      (dragEvent: D3DragEvent<SVGSVGElement, unknown, unknown>) => {\n        this.state.dragX += dragEvent.dx\n        this.state.dragY += dragEvent.dy\n\n        this.updateDrag()\n      }\n    )\n\n    svgSel.style(\"cursor\", \"move\").call(dragHandler).on(\"wheel\", null)\n  }\n\n  private getDimensions() {\n    const {\n      config: { circlesData, getCircleValue, rootElId },\n    } = this\n    const rootEl = document.getElementById(rootElId) as HTMLElement\n    const { width: elWidth } = rootEl.getBoundingClientRect()\n\n    const width = elWidth - margin.left - margin.right\n    const height = max(circlesData, getCircleValue)! * 2.5\n\n    return {\n      height,\n      width,\n    }\n  }\n\n  private render() {\n    const {\n      config: {\n        chartDescription,\n        circlesData,\n        getCircleId,\n        getCircleTitle,\n        getCircleValue,\n      },\n      elements,\n    } = this\n\n    this.updateDrag()\n\n    const maxValue = max(circlesData, getCircleValue) as number\n    const colorScale = scaleOrdinal<number, number>()\n      .domain([0, maxValue])\n      .range([0, 0.5])\n    const clickedColor = \"orange\"\n\n    const colorize = (circle: ChartData) => {\n      const circleId = getCircleId(circle)\n\n      if (this.state.selectedCircles[circleId]) {\n        return clickedColor\n      }\n\n      const circleValue = getCircleValue(circle)\n\n      const normalized = colorScale(circleValue)\n\n      return interpolateCool(normalized)\n    }\n\n    const { height, width } = this.getDimensions()\n\n    elements.svgSel\n      .attr(\"width\", width + margin.left + margin.right)\n      .attr(\"height\", height + margin.left + margin.right)\n\n    // It sorts from bigger to smaller value for the hover to work\n    const sortedData = circlesData\n      .slice(0)\n      .sort(\n        (...[circleA, circleB]) =>\n          getCircleValue(circleB) - getCircleValue(circleA)\n      )\n\n    const groupUpdates = elements.gSel\n      .selectAll<SVGGElement, ChartData>(\".circle-group\")\n      .data(sortedData, getCircleId)\n\n    groupUpdates\n      .enter()\n      .append(\"g\")\n      .attr(\"class\", \"circle-group\")\n      .append(\"circle\")\n      .attr(\"class\", this.circleClass)\n\n    groupUpdates.exit().remove()\n\n    const maxRadius = Math.min(height / 2, width / 2)\n    const scaleRadius = scaleLinear()\n      .domain([0, maxValue])\n      .range([0, maxRadius])\n\n    const circles = elements.gSel.selectAll<SVGCircleElement, ChartData>(\n      `.${this.circleClass}`\n    )\n\n    const {\n      state: { selectedCircles },\n    } = this\n\n    const bigStroke = \"4px\"\n\n    const getStrokeWidth = (circle: ChartData) => {\n      const id = getCircleId(circle)\n\n      return selectedCircles[id] ? bigStroke : \"2px\"\n    }\n\n    circles\n      .attr(\"cx\", width / 2)\n      .attr(\"cy\", height / 2)\n      .style(\"fill\", \"rgba(0, 0, 0, 0)\")\n      .style(\"stroke\", colorize)\n      .style(\"stroke-width\", getStrokeWidth)\n      .attr(\"r\", (circle) => scaleRadius(getCircleValue(circle)))\n      .on(\"mouseenter\", function handleMouseEnter() {\n        select<SVGCircleElement, ChartData>(this)\n          .style(\"stroke\", clickedColor)\n          .style(\"stroke-width\", bigStroke)\n      })\n      .on(\"mouseleave\", function handleMouseLeave() {\n        select<SVGCircleElement, ChartData>(this)\n          .style(\"stroke\", colorize)\n          .style(\"stroke-width\", getStrokeWidth)\n      })\n      .on(\"click\", function handleClick(...[, circle]) {\n        const id = getCircleId(circle)\n\n        selectedCircles[id] = !selectedCircles[id]\n\n        select<SVGCircleElement, ChartData>(this)\n          .style(\"stroke\", colorize)\n          .style(\"stroke-width\", getStrokeWidth)\n      })\n      .append(\"title\")\n      .text(getCircleTitle)\n\n    elements.descriptionSel\n      .text(chartDescription)\n      .attr(\"transform\", `translate(${width / 2},${height + 25})`)\n  }\n\n  private readonly handleResize = () => {\n    this.render()\n  }\n}\n\nconst _test = process.env.NODE_ENV === \"test\" ? { getNewDrag } : null\n\nexport { CirclesChart, ChartConfig, _test }\n","filePath":"src/demos/concentric-circles/circles-chart.ts"},{"content":"import { csv } from \"d3\"\n\nimport { ChartConfig } from \"./circles-chart\"\n\nconst CONTAINER_ID = \"chart\"\nconst ZOOM_SLIDER_ID = \"year-slider\"\n\ntype NamesMetric = {\n  count: number\n  name: string\n  year: string\n}\n\ntype NamesMetrics = NamesMetric[]\n\nconst fetchData = async (): Promise<NamesMetrics> => {\n  const response = (await csv(\n    `${ROOT_PATH}data/d3js/concentric-circles/data.csv`\n  )) as unknown as NamesMetrics\n\n  return response.map((nameItem) => ({\n    ...nameItem,\n    count: +nameItem.count,\n  }))\n}\n\ntype Config = ChartConfig<NamesMetric>\n\nconst getCircleValue: Config[\"getCircleValue\"] = (circle) => circle.count\nconst getCircleId: Config[\"getCircleId\"] = (circle) => circle.name\n\nconst getCircleTitle: Config[\"getCircleTitle\"] = (circle) =>\n  `${circle.name}: ${circle.count}`\n\nconst chartDescription =\n  \"Circles radius are proportional to order in the ranking, click to select\"\n\nconst getChartConfig = ({\n  namesMetrics,\n}: {\n  namesMetrics: NamesMetrics\n}): Config => ({\n  chartDescription,\n  circlesData: (() => {\n    const addedNames = new Set()\n\n    return namesMetrics\n      .sort((...[namesObjA, namesObjB]) => namesObjB.count - namesObjA.count)\n      .filter((nameObj) => {\n        if (addedNames.has(nameObj.name)) {\n          return false\n        }\n\n        addedNames.add(nameObj.name)\n\n        return true\n      })\n      .reverse()\n  })(),\n  getCircleId,\n  getCircleTitle,\n  getCircleValue,\n  rootElId: CONTAINER_ID,\n})\n\nexport { CONTAINER_ID, ZOOM_SLIDER_ID, fetchData, getChartConfig }\n","filePath":"src/demos/concentric-circles/concentric-circles-config.ts"}],"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps, JQUERYUI } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main, {\n  CONTAINER_ID,\n  ZOOM_SLIDER_ID,\n} from \"@/demos/concentric-circles/concentric-circles\"\n\nconst ConcentricCircles = ({ pageContext }: DemoPageProps) => (\n  <Demo\n    links={[JQUERYUI.STYLE]}\n    main={main}\n    pageContext={pageContext}\n    scripts={[JQUERYUI.SCRIPT]}\n  >\n    <div style={{ marginBottom: 20 }}>\n      <p>Zoom</p>\n      <div id={ZOOM_SLIDER_ID} />\n    </div>\n    <div id={CONTAINER_ID} />\n  </Demo>\n)\n\nexport default ConcentricCircles\n","type":"tsx"}},"key":"concentric-circles"},"meta":{"description":"Concentric circles example using D3.js, with a non repeated series of data and with a new style that heavily uses the svg drop-shadow type filter."}}},
    "staticQueryHashes": []}