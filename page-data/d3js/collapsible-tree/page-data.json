{"componentChunkName":"component---src-pages-d-3-js-collapsible-tree-tsx","path":"/d3js/collapsible-tree/","result":{"pageContext":{"demoInfo":{"dataFiles":["data.json"],"docs":[],"isCompleted":true,"name":"Collapsible Tree","notes":[],"sources":["http://bl.ocks.org/mbostock/4339083","https://observablehq.com/@d3/collapsible-tree"],"summary":[],"category":"d3js","files":{"demoCSS":[{"content":".collapsibleTreeChart {\n  .node {\n    cursor: pointer;\n  }\n\n  .node circle {\n    fill: #fff;\n    stroke: steelblue;\n    stroke-width: 1.5px;\n  }\n\n  .node text {\n    font: 10px sans-serif;\n  }\n\n  .link {\n    fill: none;\n    stroke: #ccc;\n    stroke-width: 1.5px;\n  }\n}\n","fileName":"collapsible-tree.module.css"}],"demoTS":[{"content":"import {\n  HierarchyNode,\n  HierarchyPointLink,\n  HierarchyPointNode,\n  hierarchy,\n  json,\n  linkHorizontal,\n  select,\n  tree as treeD3,\n} from \"d3\"\n\nimport * as styles from \"./collapsible-tree.module.css\"\n\nconst CONTAINER_ID = \"chart\"\n\ntype DataNode = {\n  _children: Array<HierarchyPointNode<DataNode>> | undefined\n  children: DataNode[]\n  id: number\n  name: string\n  x: number\n  x0: number\n  y: number\n  y0: number\n}\ntype HierarchyDataNode = HierarchyNode<DataNode>\ntype TreeNode = HierarchyPointNode<DataNode>\ntype TreeLink = HierarchyPointLink<DataNode>\n\ntype DiagonalNode = { x: number; y: number }\ntype DiagonalLink = { source: DiagonalNode; target: DiagonalNode }\n\nconst fetchData = async (): Promise<DataNode> =>\n  json(`${ROOT_PATH}data/d3js/collapsible-tree/data.json`) as Promise<DataNode>\n\nconst margin = {\n  bottom: 20,\n  left: 120,\n  right: 120,\n  top: 20,\n}\n\nconst duration = 750\nconst height = 800 - margin.top - margin.bottom\n\ntype RenderChart = (o: { rootData: DataNode; rootElId: string }) => void\n\nconst renderChart: RenderChart = ({ rootData, rootElId }) => {\n  const root = hierarchy<DataNode>(rootData)\n\n  const rootEl = document.getElementById(rootElId) as HTMLElement\n\n  rootEl.classList.add(styles.collapsibleTreeChart)\n\n  const width =\n    rootEl.getBoundingClientRect().width - margin.right - margin.left\n\n  root.data.x0 = height / 2\n  root.data.y0 = 0\n\n  const tree = treeD3<DataNode>().nodeSize([20, 100])\n\n  const rootTree = tree(root)\n\n  rootTree\n    .descendants()\n    .forEach((...[treeNode, treeNodeIndex]: [TreeNode, number]) => {\n      treeNode.data.id = treeNodeIndex\n      treeNode.data._children = treeNode.children\n\n      if (treeNode.depth) {\n        treeNode.children = undefined\n      }\n    })\n\n  const diagonal = linkHorizontal<DiagonalLink, DiagonalNode>()\n    .x((diagonalNode) => diagonalNode.y)\n    .y((diagonalNode) => diagonalNode.x)\n\n  const svg = select<SVGElement, TreeNode>(`#${rootElId}`)\n    .append(\"svg\")\n    .attr(\"width\", width + margin.right + margin.left)\n    .attr(\"height\", height + margin.top + margin.bottom)\n    .append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},${height / 2})`)\n\n  const gLink = svg\n    .append(\"g\")\n    .attr(\"fill\", \"none\")\n    .attr(\"stroke\", \"#555\")\n    .attr(\"stroke-opacity\", 0.4)\n    .attr(\"stroke-width\", 1.5)\n\n  const gNode = svg\n    .append(\"g\")\n    .attr(\"cursor\", \"pointer\")\n    .attr(\"pointer-events\", \"all\")\n\n  const update = function (source: TreeNode) {\n    const nodes = rootTree.descendants().reverse()\n    const links = rootTree.links()\n\n    tree(root)\n\n    let left = root\n    let right = root\n\n    root.eachBefore((node: HierarchyDataNode) => {\n      if (node.data.x < left.data.x) {\n        left = node\n      }\n\n      if (node.data.x > right.data.x) {\n        right = node\n      }\n    })\n\n    const node = gNode\n      .selectAll<SVGGElement, TreeNode>(\"g\")\n      .data(nodes, (treeNode) => treeNode.data.id)\n\n    const nodeEnter = node\n      .enter()\n      .append(\"g\")\n      .attr(\"transform\", () => `translate(${source.data.y0},${source.data.x0})`)\n      .attr(\"fill-opacity\", 0)\n      .attr(\"stroke-opacity\", 0)\n      .on(\"click\", (...[, treeNode]) => {\n        treeNode.children = treeNode.children\n          ? undefined\n          : treeNode.data._children\n\n        update(treeNode)\n      })\n\n    nodeEnter\n      .append(\"circle\")\n      .attr(\"r\", 2.5)\n      .attr(\"fill\", (treeNode) => (treeNode.data._children ? \"#555\" : \"#999\"))\n      .attr(\"stroke-width\", 10)\n\n    nodeEnter\n      .append(\"text\")\n      .attr(\"dy\", \"0.31em\")\n      .attr(\"x\", (treeNode) => (treeNode.data._children ? -6 : 6))\n      .attr(\"text-anchor\", (treeNode) =>\n        treeNode.data._children ? \"end\" : \"start\"\n      )\n      .text((treeNode) => treeNode.data.name)\n      .clone(true)\n      .lower()\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"stroke-width\", 3)\n      .attr(\"stroke\", \"white\")\n\n    node\n      .merge(nodeEnter)\n      .transition()\n      .duration(duration)\n      .attr(\"transform\", (treeNode) => `translate(${treeNode.y},${treeNode.x})`)\n      .attr(\"fill-opacity\", 1)\n      .attr(\"stroke-opacity\", 1)\n\n    node\n      .exit()\n      .transition()\n      .duration(duration)\n      .remove()\n      .attr(\"transform\", () => `translate(${source.y},${source.x})`)\n      .attr(\"fill-opacity\", 0)\n      .attr(\"stroke-opacity\", 0)\n\n    const link = gLink\n      .selectAll<SVGPathElement, TreeLink>(\"path\")\n      .data(links, (treeLink) => treeLink.target.data.id)\n\n    const linkEnter = link\n      .enter()\n      .append(\"path\")\n      .attr(\"d\", () => {\n        const o = {\n          x: source.data.x0,\n          y: source.data.y0,\n        }\n\n        return diagonal({ source: o, target: o })\n      })\n\n    link.merge(linkEnter).transition().duration(duration).attr(\"d\", diagonal)\n\n    link\n      .exit()\n      .transition()\n      .duration(duration)\n      .remove()\n      .attr(\"d\", () => {\n        const o = { x: source.x, y: source.y }\n\n        return diagonal({ source: o, target: o })\n      })\n\n    rootTree.eachBefore((treeNode) => {\n      treeNode.data.x0 = treeNode.x\n      treeNode.data.y0 = treeNode.y\n    })\n  }\n\n  update(rootTree)\n}\n\nconst main = async () => {\n  const rootElId = CONTAINER_ID\n\n  const rootData = await fetchData()\n\n  renderChart({\n    rootData,\n    rootElId,\n  })\n}\n\nexport { CONTAINER_ID }\n\nexport default main\n","fileName":"collapsible-tree.ts"}],"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main, { CONTAINER_ID } from \"@/demos/collapsible-tree/collapsible-tree\"\n\nconst CollapsibleTree = ({ pageContext }: DemoPageProps) => (\n  <Demo main={main} pageContext={pageContext}>\n    <div id={CONTAINER_ID} />\n  </Demo>\n)\n\nexport default CollapsibleTree\n","type":"tsx"}},"key":"collapsible-tree"},"meta":{"description":"Collapsible Tree example using D3.js, with circular nodes and styled links. With transitions, it manages the text placing depending if the node is expanded."}}},"staticQueryHashes":[]}