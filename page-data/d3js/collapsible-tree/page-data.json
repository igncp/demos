{"componentChunkName":"component---src-pages-d-3-js-collapsible-tree-js","path":"/d3js/collapsible-tree/","result":{"pageContext":{"demoInfo":{"data":["data.json"],"name":"Collapsible Tree","notes":[],"sources":["http://bl.ocks.org/mbostock/4339083","https://observablehq.com/@d3/collapsible-tree"],"category":"d3js","files":{"d3utils":null,"demo":{"content":"import * as d3 from \"d3\"\n\nconst fetchData = async () => {\n  const data = await d3.json(`${ROOT_PATH}data/d3js/collapsible-tree/data.json`)\n\n  return data\n}\n\nconst margin = {\n  bottom: 20,\n  left: 120,\n  right: 120,\n  top: 20,\n}\n\nconst duration = 750\nconst height = 800 - margin.top - margin.bottom\n\nconst renderChart = ({ rootElId, rootData }) => {\n  const root = d3.hierarchy(rootData)\n\n  root.descendants().forEach((d, i) => {\n    d.id = i\n    d._children = d.children\n    if (d.depth && d.data.name.length !== 7) d.children = null\n  })\n\n  const width =\n    document.getElementById(rootElId).getBoundingClientRect().width -\n    margin.right -\n    margin.left\n\n  root.x0 = height / 2\n  root.y0 = 0\n\n  const tree = d3.tree().nodeSize([20, 100])\n\n  tree(root)\n\n  const diagonal = d3\n    .linkHorizontal()\n    .x((d) => d.y)\n    .y((d) => d.x)\n\n  const svg = d3\n    .select(`#${rootElId}`)\n    .append(\"svg\")\n    .attr(\"width\", width + margin.right + margin.left)\n    .attr(\"height\", height + margin.top + margin.bottom)\n    .append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},${height / 2})`)\n\n  const gLink = svg\n    .append(\"g\")\n    .attr(\"fill\", \"none\")\n    .attr(\"stroke\", \"#555\")\n    .attr(\"stroke-opacity\", 0.4)\n    .attr(\"stroke-width\", 1.5)\n\n  const gNode = svg\n    .append(\"g\")\n    .attr(\"cursor\", \"pointer\")\n    .attr(\"pointer-events\", \"all\")\n\n  const update = function (source) {\n    const nodes = root.descendants().reverse()\n    const links = root.links()\n\n    tree(root)\n\n    let left = root\n    let right = root\n\n    root.eachBefore((node) => {\n      if (node.x < left.x) left = node\n      if (node.x > right.x) right = node\n    })\n\n    const transition = svg\n      .transition()\n      .duration(duration)\n      .tween(\n        \"resize\",\n        window.ResizeObserver ? null : () => () => svg.dispatch(\"toggle\")\n      )\n    const node = gNode.selectAll(\"g\").data(nodes, (d) => d.id)\n\n    const nodeEnter = node\n      .enter()\n      .append(\"g\")\n      .attr(\"transform\", () => `translate(${source.y0},${source.x0})`)\n      .attr(\"fill-opacity\", 0)\n      .attr(\"stroke-opacity\", 0)\n      .on(\"click\", (_event, d) => {\n        d.children = d.children ? null : d._children\n\n        update(d)\n      })\n\n    nodeEnter\n      .append(\"circle\")\n      .attr(\"r\", 2.5)\n      .attr(\"fill\", (d) => (d._children ? \"#555\" : \"#999\"))\n      .attr(\"stroke-width\", 10)\n\n    nodeEnter\n      .append(\"text\")\n      .attr(\"dy\", \"0.31em\")\n      .attr(\"x\", (d) => (d._children ? -6 : 6))\n      .attr(\"text-anchor\", (d) => (d._children ? \"end\" : \"start\"))\n      .text((d) => (d.data ? d.data.name : d.name))\n      .clone(true)\n      .lower()\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"stroke-width\", 3)\n      .attr(\"stroke\", \"white\")\n\n    node\n      .merge(nodeEnter)\n      .transition(transition)\n      .attr(\"transform\", (d) => `translate(${d.y},${d.x})`)\n      .attr(\"fill-opacity\", 1)\n      .attr(\"stroke-opacity\", 1)\n\n    node\n      .exit()\n      .transition(transition)\n      .remove()\n      .attr(\"transform\", () => `translate(${source.y},${source.x})`)\n      .attr(\"fill-opacity\", 0)\n      .attr(\"stroke-opacity\", 0)\n\n    const link = gLink.selectAll(\"path\").data(links, (d) => d.target.id)\n\n    const linkEnter = link\n      .enter()\n      .append(\"path\")\n      .attr(\"d\", () => {\n        const o = { x: source.x0, y: source.y0 }\n\n        return diagonal({ source: o, target: o })\n      })\n\n    link.merge(linkEnter).transition(transition).attr(\"d\", diagonal)\n\n    link\n      .exit()\n      .transition(transition)\n      .remove()\n      .attr(\"d\", () => {\n        const o = { x: source.x, y: source.y }\n\n        return diagonal({ source: o, target: o })\n      })\n\n    root.eachBefore((d) => {\n      d.x0 = d.x\n      d.y0 = d.y\n    })\n  }\n\n  update(root)\n}\n\nconst main = async () => {\n  const rootElId = \"chart\"\n\n  const rootData = await fetchData()\n\n  renderChart({\n    rootData,\n    rootElId,\n  })\n}\n\nexport default main\n","type":"js"},"page":"import React from \"react\"\n\nimport Demo from \"@/components/demo\"\n\nimport main from \"@/demos/collapsible-tree/collapsible-tree\"\n\nimport \"@/demos/collapsible-tree/collapsible-tree.styl\"\n\nconst CollapsibleTree = ({ pageContext: { demoInfo } }) => (\n  <Demo demoInfo={demoInfo} main={main}>\n    <div className=\"collapsible-tree-chart\" id=\"chart\" />\n  </Demo>\n)\n\nexport default CollapsibleTree\n","styl":".collapsible-tree-chart\n    .node\n      cursor: pointer;\n\n\n    .node circle\n      fill: #fff;\n      stroke: steelblue;\n      stroke-width: 1.5px;\n\n\n    .node text\n      font: 10px sans-serif;\n\n\n    .link\n      fill: none;\n      stroke: #ccc;\n      stroke-width: 1.5px;\n"},"key":"collapsible-tree"}}},"staticQueryHashes":[]}