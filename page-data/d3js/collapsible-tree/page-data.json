{
    "componentChunkName": "component---src-pages-d-3-js-collapsible-tree-tsx",
    "path": "/d3js/collapsible-tree/",
    "result": {"pageContext":{"demoInfo":{"dataFiles":["data.json"],"docs":[],"isCompleted":true,"name":"Collapsible Tree","notes":["Added the option to create and remove nodes dynamically on click"],"sources":["http://bl.ocks.org/mbostock/4339083","https://observablehq.com/@d3/collapsible-tree"],"summary":["In this case there are many files to improve the separation of concerns, minimize dependencies of each module and the data exposes.","There are several important entities in this type of chart: `hierarchy` (which produces `HierarchyNode`), `tree` (which produces `HierarchyPointNode`)."],"category":"d3js","files":{"demoCSS":[{"content":".collapsibleTreeChart {\n  .node {\n    cursor: pointer;\n\n    circle {\n      fill: #fff;\n      stroke: steelblue;\n      stroke-width: 1.5px;\n    }\n\n    text {\n      font: 10px sans-serif;\n    }\n  }\n\n  .link {\n    fill: none;\n    stroke: #ccc;\n    stroke-width: 1.5px;\n  }\n}\n","fileName":"collapsible-tree.module.css"}],"demoTS":[{"content":"import { renderChart } from \"./collapsible-tree-chart\"\nimport {\n  CONTAINER_ID,\n  createChartConfig,\n  fetchData,\n} from \"./collapsible-tree-chart-config\"\n\nconst main = async () => {\n  const rootData = await fetchData()\n\n  const chartConfig = createChartConfig(rootData)\n\n  renderChart(chartConfig)\n}\n\nexport { CONTAINER_ID }\n\nexport default main\n","fileName":"collapsible-tree.ts"},{"content":"import { json } from \"d3\"\n\nimport {\n  ChartConfig,\n  NodeShape,\n  findNode,\n  findParentNode,\n} from \"./collapsible-tree-chart\"\n\nexport const CONTAINER_ID = \"chart\"\n\ntype RawData = {\n  name: string\n}\n\ntype BaseData = RawData & {\n  id: number\n}\n\ntype RawNode = NodeShape<BaseData>\ntype BaseNode = NodeShape<BaseData>\n\nconst getBaseNode = ({\n  context,\n  rawNode,\n}: {\n  context: { id: number }\n  rawNode: RawNode\n}): BaseNode => {\n  const { id: nodeId } = context\n\n  context.id += 1\n\n  return {\n    ...rawNode,\n    children: (rawNode.children ?? []).map((rawNodeChildren) =>\n      getBaseNode({ context, rawNode: rawNodeChildren })\n    ),\n    id: nodeId,\n  }\n}\n\nconst findMaxId = (node: BaseNode): BaseNode[\"id\"] =>\n  (node.children ?? []).reduce(\n    (...[acc, childrenNode]) => Math.max(findMaxId(childrenNode), acc),\n    node.id\n  )\n\nexport const fetchData = async (): Promise<BaseNode> => {\n  const rawNode = (await json(\n    `${ROOT_PATH}data/d3js/collapsible-tree/data.json`\n  )) as RawNode\n\n  return getBaseNode({ context: { id: 0 }, rawNode })\n}\n\ntype Config = ChartConfig<BaseData>\n\nconst getNodeLabel: Config[\"getNodeLabel\"] = (node) => node.name\nconst getNodeId: Config[\"getNodeId\"] = (node) => node.id\nconst canBeRemoved: Config[\"canBeRemoved\"] = (node) => node.id !== 0\n\nexport const createChartConfig = (rootData: BaseNode): Config => {\n  const onNodeAdd: Config[\"onNodeAdd\"] = (clickedNode) => {\n    const maxId = findMaxId(rootData)\n    const baseNode = findNode({\n      getId: (node) => node.id,\n      node: rootData,\n      nodeId: clickedNode.id,\n    })\n\n    if (!baseNode) {\n      throw new Error(\"Node not found\")\n    }\n\n    const newId = maxId + 1\n\n    baseNode.children = baseNode.children ?? []\n\n    const newNode = {\n      id: newId,\n      name: `New Node id: ${newId}`,\n    }\n\n    baseNode.children.push(newNode)\n\n    return newNode\n  }\n\n  const onNodeRemove: Config[\"onNodeRemove\"] = (clickedNode) => {\n    const parentNode = findParentNode({\n      getId: (node) => node.id,\n      node: rootData,\n      nodeId: clickedNode.id,\n    })\n\n    if (!parentNode) {\n      throw new Error(\"No parent node\")\n    }\n\n    const nodeIndex = parentNode.children!.findIndex(\n      (node) => node.id === clickedNode.id\n    )\n\n    parentNode.children!.splice(nodeIndex, 1)\n\n    return parentNode\n  }\n\n  return {\n    canBeRemoved,\n    getNodeId,\n    getNodeLabel,\n    onNodeAdd,\n    onNodeRemove,\n    rootData,\n    rootElId: CONTAINER_ID,\n  }\n}\n","fileName":"collapsible-tree-chart-config.ts"},{"content":"import { BaseType, Selection } from \"d3\"\n\nexport type Point = {\n  x: number\n  y: number\n}\n\nexport type CommonUIProps<Container extends BaseType, NodeDatum> = {\n  container: Selection<Container, NodeDatum, Element, unknown>\n  getInitialPosition: (node: NodeDatum) => Point\n  getPosition: (node: NodeDatum) => Point\n  linkDefaultColor: string\n  openCloseAnimationDuration: number\n}\n","fileName":"collapsible-tree-chart-ui-common.ts"},{"content":"import { BaseType, Link, Selection, linkHorizontal } from \"d3\"\n\nimport { CommonUIProps, Point } from \"./collapsible-tree-chart-ui-common\"\n\nconst treeLinkPathClass = \"tree-link\"\n\ntype DiagonalLink = { source: Point; target: Point }\n\ntype UILinkOpts<Container extends BaseType, NodeDatum> = CommonUIProps<\n  Container,\n  NodeDatum\n>\n\n/**\n * Responsible for handle the UI of the link, without any knowledge of the node\n * tree structure, with a constraint on the link data.\n */\nexport class UILink<\n  Container extends BaseType,\n  LinkDatum extends DiagonalLink,\n  NodeDatum\n> {\n  private readonly initialOpts: UILinkOpts<Container, NodeDatum>\n  private readonly linkG: Selection<SVGGElement, NodeDatum, Element, unknown>\n  private readonly linkPath: Link<unknown, DiagonalLink, Point>\n\n  public constructor(opts: UILinkOpts<Container, NodeDatum>) {\n    this.initialOpts = opts\n\n    this.linkPath = linkHorizontal<DiagonalLink, Point>()\n      .x((diagonalNode) => diagonalNode.y)\n      .y((diagonalNode) => diagonalNode.x)\n\n    this.linkG = opts.container\n      .append(\"g\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", opts.linkDefaultColor)\n      .attr(\"stroke-opacity\", 0.4)\n      .attr(\"stroke-width\", 1.5)\n  }\n\n  public update(opts: {\n    getData: () => [LinkDatum[], (linkData: LinkDatum) => number]\n    source: NodeDatum\n  }) {\n    const {\n      initialOpts: {\n        getInitialPosition,\n        getPosition,\n        openCloseAnimationDuration,\n      },\n      linkG,\n      linkPath,\n    } = this\n    const { getData, source } = opts\n\n    const linkSelection = linkG\n      .selectAll<SVGPathElement, LinkDatum>(\"path\")\n      .data(...getData())\n\n    const linkEnter = linkSelection\n      .enter()\n      .append(\"path\")\n      .attr(\"class\", treeLinkPathClass)\n      .attr(\"d\", () => {\n        const diagonalNode = getInitialPosition(source)\n        const diagonalLink = { source: diagonalNode, target: diagonalNode }\n\n        return linkPath(diagonalLink)\n      })\n\n    linkSelection\n      .merge(linkEnter)\n      .transition()\n      .duration(openCloseAnimationDuration)\n      .attr(\"d\", (link) => linkPath(link))\n\n    linkSelection\n      .exit()\n      .transition()\n      .duration(openCloseAnimationDuration)\n      .remove()\n      .attr(\"d\", () => {\n        const diagonalNode = getPosition(source)\n        const diagonalLink = { source: diagonalNode, target: diagonalNode }\n\n        return linkPath(diagonalLink)\n      })\n  }\n\n  public getSelection() {\n    return this.linkG.selectAll<SVGPathElement, LinkDatum>(\n      `.${treeLinkPathClass}`\n    )\n  }\n}\n","fileName":"collapsible-tree-chart-ui-link.ts"},{"content":"import anime from \"animejs\"\nimport { BaseType, Selection, select } from \"d3\"\n\nimport { CommonUIProps } from \"./collapsible-tree-chart-ui-common\"\nimport { UISmallButton } from \"./collapsible-tree-chart-ui-small-button\"\n\ntype UINodeOpts<Container extends BaseType, Datum> = CommonUIProps<\n  Container,\n  Datum\n> &\n  Readonly<{\n    displayRemoveButton: (nodeData: Datum) => boolean\n    getNodeId: (nodeData: Datum) => number\n    getPointingLinkForNode: (\n      nodeData: Datum\n    ) => Selection<SVGElement, unknown, SVGElement, unknown>\n    getText: (nodeData: Datum) => string\n    hasDescendants: (node: Datum) => boolean\n  }>\n\nconst nodeCircleClass = \"node-circle\"\nconst nodeLabelClass = \"node-label\"\n\n/**\n * Responsible for handle the UI of the node, without any knowledge of the node\n * tree structure (it doesn't know how the children nodes are referenced)\n */\nexport class UINode<Container extends BaseType, Datum> {\n  private readonly initialOpts: UINodeOpts<Container, Datum>\n  private readonly nodeG: Selection<SVGGElement, Datum, Element, unknown>\n  private readonly hoveredItems = new Set<number>()\n\n  private readonly plusButton: UISmallButton<SVGGElement, Datum, SVGGElement>\n  private readonly minusButton: UISmallButton<SVGGElement, Datum, SVGGElement>\n\n  private readonly circleLinkForEffect: Selection<\n    SVGCircleElement,\n    Datum,\n    Element,\n    unknown\n  >\n\n  public constructor(opts: UINodeOpts<Container, Datum>) {\n    this.initialOpts = opts\n\n    this.nodeG = this.initialOpts.container\n      .append(\"g\")\n      .attr(\"pointer-events\", \"all\")\n\n    this.circleLinkForEffect = this.initialOpts.container\n      .insert(\"circle\", \":first-child\")\n      .attr(\"r\", 4)\n      .attr(\"fill\", \"none\")\n\n    this.plusButton = new UISmallButton({\n      dx: \"0px\",\n      fontSize: \"20px\",\n      text: \"+\",\n    })\n\n    this.minusButton = new UISmallButton({\n      dx: \"-15px\",\n      fontSize: \"25px\",\n      text: \"-\",\n    })\n  }\n\n  public update(opts: {\n    getData: () => [Datum[], (nodeData: Datum) => number]\n    onNodeAdd: (node: Datum) => void\n    onNodeClick: (node: Datum) => void\n    onNodeRemove: (node: Datum) => void\n    source: Datum\n  }) {\n    const { source } = opts\n    const {\n      circleLinkForEffect,\n      hoveredItems,\n      initialOpts: {\n        displayRemoveButton,\n        getInitialPosition,\n        getNodeId,\n        getPointingLinkForNode,\n        getPosition,\n        getText,\n        hasDescendants,\n        linkDefaultColor,\n      },\n    } = this\n\n    const nodeSelection = this.nodeG\n      .selectAll<SVGGElement, Datum>(\"g\")\n      .data(...opts.getData())\n\n    const circleDefaultFill = (node: Datum) => {\n      if (hasDescendants(node)) {\n        return hoveredItems.has(getNodeId(node)) ? \"blue\" : \"green\"\n      }\n\n      return \"red\"\n    }\n\n    const nodeEnter = nodeSelection\n      .enter()\n      .append(\"g\")\n      .attr(\"transform\", () => {\n        const position = getInitialPosition(source)\n\n        return `translate(${position.y},${position.x})`\n      })\n      .attr(\"fill-opacity\", 0)\n      .attr(\"stroke-opacity\", 0)\n      .on(\"click\", (...[, treeNode]) => {\n        opts.onNodeClick(treeNode)\n      })\n\n    nodeEnter\n      .append(\"circle\")\n      .attr(\"r\", 10)\n      .attr(\"class\", nodeCircleClass)\n      .attr(\"stroke-width\", 10)\n\n    const textDX = 10\n\n    nodeEnter\n      .append(\"text\")\n      .attr(\"class\", nodeLabelClass)\n      .attr(\"dy\", \"5px\")\n      .style(\"font-size\", \"20px\")\n      .text(getText)\n      .clone(true)\n      .lower()\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"stroke-width\", 3)\n      .attr(\"stroke\", \"white\")\n\n    const { minusButton, plusButton } = this\n\n    const buttons = [plusButton, minusButton]\n\n    const showButtonsIfNecessary = (container: SVGGElement) => {\n      buttons.forEach((button) => {\n        button.hide({\n          container,\n          filterFn: (node) =>\n            button === minusButton && !displayRemoveButton(node),\n        })\n      })\n    }\n\n    nodeEnter\n      .on(\"mouseenter\", function (...[, focusedTreeNode]) {\n        hoveredItems.add(getNodeId(focusedTreeNode))\n\n        select<SVGGElement, Datum>(this)\n          .select<SVGCircleElement>(\"circle\")\n          .attr(\"fill\", circleDefaultFill)\n\n        showButtonsIfNecessary(this)\n\n        const pointingLink = getPointingLinkForNode(focusedTreeNode)\n\n        if (!pointingLink.size()) {\n          return\n        }\n\n        pointingLink.style(\"stroke\", \"orange\")\n        circleLinkForEffect.attr(\"fill\", \"orange\")\n\n        const animePath = anime.path(pointingLink.node() as SVGElement)\n\n        anime({\n          duration: 500,\n          easing: \"easeInOutSine\",\n          endDelay: 1000,\n          loop: true,\n          targets: circleLinkForEffect.node(),\n          translateX: animePath(\"x\"),\n          translateY: animePath(\"y\"),\n        })\n      })\n      .on(\"mouseleave\", function (...[, focusedTreeNode]) {\n        hoveredItems.delete(getNodeId(focusedTreeNode))\n\n        select<SVGGElement, Datum>(this)\n          .select<SVGCircleElement>(\"circle\")\n          .attr(\"fill\", circleDefaultFill)\n\n        buttons.forEach((button) => {\n          button.hide({\n            container: this,\n          })\n        })\n\n        const pointingLink = getPointingLinkForNode(focusedTreeNode)\n\n        if (!pointingLink.size()) {\n          return\n        }\n\n        circleLinkForEffect.attr(\"fill\", \"none\")\n\n        pointingLink.style(\"stroke\", linkDefaultColor)\n        anime.remove(circleLinkForEffect.node())\n      })\n\n    nodeSelection\n      .merge(nodeEnter)\n      .transition()\n      .duration(this.initialOpts.openCloseAnimationDuration)\n      .attr(\"transform\", (treeNode) => {\n        const position = getPosition(treeNode)\n\n        return `translate(${position.y},${position.x})`\n      })\n      .attr(\"fill-opacity\", 1)\n      .attr(\"stroke-opacity\", 1)\n\n    const groupsToUpdate = [nodeSelection, nodeEnter]\n\n    groupsToUpdate.forEach((nodeGroup) => {\n      plusButton.add({\n        container: nodeGroup,\n        onClick: (nodeDatum) => {\n          opts.onNodeAdd(nodeDatum)\n        },\n      })\n\n      minusButton.add({\n        container: nodeGroup,\n        onClick: (nodeDatum) => {\n          opts.onNodeRemove(nodeDatum)\n        },\n      })\n\n      nodeGroup.each(function (nodeDatum) {\n        const isHovered = hoveredItems.has(getNodeId(nodeDatum))\n\n        if (isHovered) {\n          showButtonsIfNecessary(this)\n        }\n      })\n\n      nodeGroup.attr(\"cursor\", (treeNode) =>\n        hasDescendants(treeNode) ? \"pointer\" : \"default\"\n      )\n\n      nodeGroup\n        .selectAll<SVGCircleElement, Datum>(`.${nodeCircleClass}`)\n        .attr(\"fill\", circleDefaultFill)\n\n      nodeGroup\n        .selectAll<SVGCircleElement, Datum>(`.${nodeLabelClass}`)\n        .attr(\"dx\", (treeNode) =>\n          hasDescendants(treeNode) ? `-${textDX}px` : `${textDX}px`\n        )\n        .attr(\"x\", (treeNode) => (hasDescendants(treeNode) ? -6 : 6))\n        .attr(\"text-anchor\", (treeNode) =>\n          hasDescendants(treeNode) ? \"end\" : \"start\"\n        )\n    })\n\n    const sourcePosition = getPosition(source)\n\n    nodeSelection\n      .exit()\n      .transition()\n      .duration(this.initialOpts.openCloseAnimationDuration)\n      .remove()\n      .attr(\"transform\", `translate(${sourcePosition.y},${sourcePosition.x})`)\n      .attr(\"fill-opacity\", 0)\n      .attr(\"stroke-opacity\", 0)\n  }\n}\n","fileName":"collapsible-tree-chart-ui-node.ts"},{"content":"import { BaseType, Selection, select } from \"d3\"\n\ntype UISmallButtonOpts = {\n  dx: string\n  fontSize: string\n  text: string\n}\n\nexport class UISmallButton<\n  Element extends BaseType,\n  Datum,\n  ElementAbove extends BaseType\n> {\n  private readonly className: string\n  private readonly initialOpts: UISmallButtonOpts\n\n  public constructor(opts: UISmallButtonOpts) {\n    this.className = `small-button-${Math.random().toFixed(6).split(\".\")[1]}`\n\n    this.initialOpts = opts\n  }\n\n  public add({\n    container,\n    onClick,\n  }: {\n    container: Selection<Element, Datum, ElementAbove, unknown>\n    onClick: (datum: Datum) => void\n  }) {\n    const {\n      initialOpts: { dx, fontSize, text },\n    } = this\n    const groupSelection = container\n      .append(\"g\")\n      .style(\"transform\", `translate(${dx},-10px)`)\n      .attr(\"class\", this.className)\n      .style(\"display\", \"none\")\n      .attr(\"cursor\", \"pointer\")\n\n    groupSelection\n      .append(\"circle\")\n      .attr(\"r\", 8)\n      .attr(\"cx\", 5)\n      .attr(\"cy\", -7)\n      .attr(\"fill\", \"#ddd\")\n      .style(\"font-size\", fontSize)\n      .text(text)\n\n    const textSelection = groupSelection\n      .append(\"text\")\n      .style(\"font-size\", fontSize)\n      .text(text)\n\n    groupSelection\n      .on(\"mouseenter\", () => {\n        textSelection.attr(\"fill\", \"orange\")\n      })\n      .on(\"mouseleave\", () => {\n        textSelection.attr(\"fill\", null)\n      })\n      .on(\"click\", (...[clickEvent, datum]) => {\n        clickEvent.stopPropagation()\n        onClick(datum)\n      })\n  }\n\n  public hide<ContainerElement extends SVGElement>({\n    container,\n    filterFn,\n  }: {\n    container: ContainerElement\n    filterFn?: (itemData: Datum) => boolean\n  }) {\n    select<ContainerElement, Datum>(container)\n      .selectAll<SVGTextElement, Datum>(`.${this.className}`)\n      .style(\"display\", (itemData) =>\n        !filterFn || filterFn(itemData) ? \"none\" : \"block\"\n      )\n  }\n}\n","fileName":"collapsible-tree-chart-ui-small-button.ts"},{"content":"import {\n  D3DragEvent,\n  HierarchyPointLink,\n  HierarchyPointNode,\n  Selection,\n  drag,\n  hierarchy,\n  select,\n  tree as treeD3,\n} from \"d3\"\n\nimport { UILink } from \"./collapsible-tree-chart-ui-link\"\nimport { UINode } from \"./collapsible-tree-chart-ui-node\"\nimport * as styles from \"./collapsible-tree.module.css\"\n\nconst inlineStyles = {\n  linkDefaultColor: \"#555\",\n} as const\n\nexport type NodeShape<Content> = Content & {\n  children?: Array<NodeShape<Content>>\n}\n\nexport const findNode = <NodeData>({\n  getId,\n  node,\n  nodeId,\n}: {\n  getId: (node: NodeShape<NodeData>) => number\n  node: NodeShape<NodeData>\n  nodeId: number\n}): NodeShape<NodeData> | null => {\n  if (getId(node) === nodeId) {\n    return node\n  }\n\n  return (node.children ?? []).reduce<NodeShape<NodeData> | null>(\n    (...[acc, otherNode]) =>\n      acc ?? findNode({ getId, node: otherNode, nodeId }),\n    null\n  )\n}\n\nexport const findParentNode = <NodeData>({\n  getId,\n  node,\n  nodeId,\n}: {\n  getId: (node: NodeShape<NodeData>) => number\n  node: NodeShape<NodeData>\n  nodeId: number\n}): NodeShape<NodeData> | null => {\n  if (!node.children?.length) {\n    return null\n  }\n\n  const hasNode = node.children.some((otherNode) => getId(otherNode) === nodeId)\n\n  if (hasNode) {\n    return node\n  }\n\n  return node.children.reduce<NodeShape<NodeData> | null>(\n    (...[acc, otherNode]) =>\n      acc ?? findParentNode({ getId, node: otherNode, nodeId }),\n    null\n  )\n}\n\ntype ChartNode<BaseData> = BaseData &\n  NodeShape<{\n    _children: Array<HierarchyPointNode<ChartNode<BaseData>>> | undefined\n    x: number\n    x0: number\n    y: number\n    y0: number\n  }>\n\nconst margin = {\n  bottom: 20,\n  left: 120,\n  right: 120,\n  top: 20,\n}\n\nconst openCloseAnimationDuration = 750\nconst height = 800 - margin.top - margin.bottom\n\nconst getChartNode = <BaseData>(\n  initialNode: NodeShape<BaseData>\n): ChartNode<BaseData> => ({\n  ...initialNode,\n  _children: undefined,\n  children: (initialNode.children ?? []).map((subNode) =>\n    getChartNode(subNode)\n  ),\n  x: 0,\n  x0: 0,\n  y: 0,\n  y0: 0,\n})\n\nconst setupDrag = <SelectionData>(\n  svgG: Selection<SVGGElement, SelectionData, HTMLElement, unknown>\n) => {\n  const translateOffset = {\n    x: margin.left,\n    y: height / 2,\n  } as const\n\n  const draggedState = {\n    x: 0,\n    y: 0,\n  }\n\n  const dragHandler = drag<SVGSVGElement, unknown>().on(\n    \"drag\",\n    (dragEvent: D3DragEvent<SVGSVGElement, unknown, unknown>) => {\n      draggedState.x += dragEvent.dx\n      draggedState.y += dragEvent.dy\n\n      svgG.attr(\n        \"transform\",\n        `translate(${translateOffset.x + draggedState.x},${\n          translateOffset.y + draggedState.y\n        })`\n      )\n    }\n  )\n\n  svgG.attr(\"transform\", `translate(${translateOffset.x},${translateOffset.y})`)\n\n  const svg = select(svgG.node()!.parentNode as SVGSVGElement)\n\n  svg.style(\"cursor\", \"move\").call(dragHandler)\n}\n\nexport type ChartConfig<BaseData> = {\n  canBeRemoved: (node: ChartNode<BaseData>) => boolean\n  getNodeId: (node: ChartNode<BaseData>) => number\n  getNodeLabel: (node: ChartNode<BaseData>) => string\n  onNodeAdd: (node: ChartNode<BaseData>) => NodeShape<BaseData>\n  onNodeRemove: (node: ChartNode<BaseData>) => NodeShape<BaseData>\n  rootData: NodeShape<BaseData>\n  rootElId: string\n}\n\nexport const renderChart = <BaseData>(chartConfig: ChartConfig<BaseData>) => {\n  const { rootData, rootElId } = chartConfig\n\n  const rootEl = document.getElementById(rootElId) as HTMLElement\n\n  rootEl.classList.add(styles.collapsibleTreeChart)\n\n  const width =\n    rootEl.getBoundingClientRect().width - margin.right - margin.left\n\n  type TreeNode = HierarchyPointNode<ChartNode<BaseData>>\n  type TreeLink = HierarchyPointLink<ChartNode<BaseData>>\n\n  const dataNodeRoot = getChartNode(rootData)\n\n  const rootHierarchy = hierarchy<ChartNode<BaseData>>(dataNodeRoot)\n\n  rootHierarchy.data.x0 = height / 2\n  rootHierarchy.data.y0 = 0\n\n  const buildTree = treeD3<ChartNode<BaseData>>().nodeSize([40, 250])\n\n  const rootTree = buildTree(rootHierarchy)\n\n  rootTree.descendants().forEach((treeNode: TreeNode) => {\n    treeNode.data._children = treeNode.children\n\n    if (treeNode.depth) {\n      treeNode.children = undefined\n    }\n  })\n\n  const svgG = select<SVGElement, TreeNode>(`#${rootElId}`)\n    .append(\"svg\")\n    .attr(\"width\", width + margin.right + margin.left)\n    .attr(\"height\", height + margin.top + margin.bottom)\n    .append(\"g\")\n\n  setupDrag(svgG)\n\n  const commonUIOpts = {\n    container: svgG,\n    getInitialPosition: (node: TreeNode) => ({\n      x: node.data.x0,\n      y: node.data.y0,\n    }),\n    getPosition: (node: TreeNode) => ({ x: node.x, y: node.y }),\n    linkDefaultColor: inlineStyles.linkDefaultColor,\n    openCloseAnimationDuration,\n  }\n\n  const uiLink = new UILink<SVGGElement, TreeLink, TreeNode>(commonUIOpts)\n\n  const uiNode = new UINode({\n    ...commonUIOpts,\n    displayRemoveButton: (treeNode) => chartConfig.canBeRemoved(treeNode.data),\n    getNodeId: (treeNode) => chartConfig.getNodeId(treeNode.data),\n    getPointingLinkForNode: (treeNode) =>\n      uiLink\n        .getSelection()\n        .filter(\n          (link) =>\n            chartConfig.getNodeId(link.target.data) ===\n            chartConfig.getNodeId(treeNode.data)\n        ) as unknown as Selection<SVGElement, unknown, SVGElement, unknown>,\n    getText: (treeNode) => chartConfig.getNodeLabel(treeNode.data),\n    hasDescendants: (node) => !!node.data.children?.length,\n  })\n\n  const update = function (source: TreeNode) {\n    const nodes = rootTree.descendants().reverse()\n    const links = rootTree.links()\n\n    buildTree(rootHierarchy)\n\n    uiNode.update({\n      getData: () => [\n        nodes,\n        (treeNode) => chartConfig.getNodeId(treeNode.data),\n      ],\n      onNodeAdd: (clickedTreeNode) => {\n        const newNodeData = chartConfig.onNodeAdd(clickedTreeNode.data)\n        const newDataNode = getChartNode(newNodeData)\n        const newNodeHirarchy = hierarchy<ChartNode<BaseData>>(\n          newDataNode\n        ) as TreeNode\n\n        // @ts-ignore\n        newNodeHirarchy.depth = clickedTreeNode.depth + 1\n        newNodeHirarchy.parent = clickedTreeNode\n\n        clickedTreeNode.children =\n          clickedTreeNode.children ?? clickedTreeNode.data._children ?? []\n        clickedTreeNode.data._children = clickedTreeNode.children\n        clickedTreeNode.children.push(newNodeHirarchy)\n\n        clickedTreeNode.data.children = clickedTreeNode.data.children ?? []\n        clickedTreeNode.data.children.push(newNodeHirarchy.data)\n\n        window.requestAnimationFrame(() => {\n          update(clickedTreeNode)\n        })\n      },\n      onNodeClick: (treeNode) => {\n        treeNode.children = treeNode.children\n          ? undefined\n          : treeNode.data._children\n\n        update(treeNode)\n      },\n      onNodeRemove: (clickedTreeNode) => {\n        const parentNode = chartConfig.onNodeRemove(clickedTreeNode.data)\n\n        const treeNode = findNode({\n          getId: (node) => chartConfig.getNodeId(node.data),\n          node: rootHierarchy,\n          nodeId: chartConfig.getNodeId(parentNode as ChartNode<BaseData>),\n        }) as TreeNode\n\n        const nodeIndex = treeNode.children!.findIndex(\n          (node) =>\n            chartConfig.getNodeId(node.data) ===\n            chartConfig.getNodeId(clickedTreeNode.data)\n        )\n\n        treeNode.children!.splice(nodeIndex, 1)\n\n        update(treeNode)\n      },\n      source,\n    })\n\n    uiLink.update({\n      getData: () => [\n        links,\n        (treeLink) => chartConfig.getNodeId(treeLink.target.data),\n      ],\n      source,\n    })\n\n    rootTree.eachBefore((treeNode) => {\n      treeNode.data.x0 = treeNode.x\n      treeNode.data.y0 = treeNode.y\n    })\n  }\n\n  update(rootTree)\n}\n","fileName":"collapsible-tree-chart.ts"}],"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main, { CONTAINER_ID } from \"@/demos/collapsible-tree/collapsible-tree\"\n\nconst CollapsibleTree = ({ pageContext }: DemoPageProps) => (\n  <Demo main={main} pageContext={pageContext}>\n    <div id={CONTAINER_ID} />\n  </Demo>\n)\n\nexport default CollapsibleTree\n","type":"tsx"}},"key":"collapsible-tree"},"meta":{"description":"Collapsible Tree example using D3.js, with circular nodes and styled links. With transitions, it manages the text placing depending if the node is expanded."}}},
    "staticQueryHashes": []}