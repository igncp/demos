{"componentChunkName":"component---src-pages-d-3-js-chord-tsx","path":"/d3js/chord/","result":{"pageContext":{"demoInfo":{"dataFiles":["data.csv"],"docs":[],"isCompleted":true,"name":"Chord","notes":["Added filters with drop shadow and low opacity","Changed scheme and match each color with a country"],"sources":["http://bl.ocks.org/mbostock/1308257"],"summary":[],"category":"d3js","files":{"demoCSS":[{"content":".chordChart {\n  path.chord {\n    fill-opacity: 0.75;\n    stroke-width: 0.75;\n  }\n\n  .chartTitle {\n    font-weight: bold;\n  }\n\n  .group text {\n    font: 11px sans-serif;\n    pointer-events: none;\n  }\n\n  .group path {\n    stroke: #000;\n  }\n\n  .headingTitle {\n    font-size: 15px;\n    font-weight: bold;\n  }\n}\n","fileName":"chord.module.css"}],"demoTS":[{"content":"import { CONTAINER_ID, getChartConfig } from \"./chord-chart-config\"\nimport { FinancialData } from \"./chord-data-model\"\nimport { renderChart } from \"./double-chord-chart\"\n\nconst main = async () => {\n  const financialData = await FinancialData.fetchAndCreate()\n  const chartConfig = getChartConfig(financialData)\n\n  renderChart(chartConfig)\n}\n\nexport { CONTAINER_ID }\n\nexport default main\n","fileName":"chord.ts"},{"content":"import { format } from \"d3\"\n\nimport { FinancialData, FinancialMatrix } from \"./chord-data-model\"\nimport { ChartConfig } from \"./double-chord-chart\"\n\nexport const CONTAINER_ID = \"chart\"\n\nexport const getChartConfig = (financialData: FinancialData): ChartConfig => {\n  const debits = financialData.getDebits()\n  const credits = financialData.getCredits()\n  const countriesList = financialData.getCountriesList()\n\n  const formatCurrency = format(\",.3r\")\n\n  const getRibbonTitle: ChartConfig[\"getRibbonTitle\"] = ({\n    sourceIndex,\n    sourceValue,\n    targetIndex,\n  }) => {\n    const {\n      [sourceIndex]: sourceData,\n      [targetIndex]: targetData,\n    } = countriesList\n\n    return `${sourceData.name} owes ${targetData.name} $${formatCurrency(\n      sourceValue\n    )}B.`\n  }\n\n  const getGroupTitle: ChartConfig[\"getGroupTitle\"] = ({\n    chartIndex,\n    chordGroup,\n  }) =>\n    `${countriesList[chordGroup.index].name} ${\n      chartIndex ? \"owes\" : \"is owed\"\n    } $${formatCurrency(chordGroup.value)}B.`\n\n  const groupItems = countriesList.map((country) => ({\n    id: country.id,\n    label: country.name,\n  }))\n\n  const extractChordMatrix = (row: FinancialMatrix[0]) =>\n    row.map((cell) => (cell ? +cell.amount : 0))\n\n  const chordLeft = debits.map(extractChordMatrix)\n  const chordRight = credits.map(extractChordMatrix)\n\n  return {\n    chords: [chordLeft, chordRight],\n    chordsTitles: [\"Debits\", \"Credits\"],\n    getGroupTitle,\n    getRibbonTitle,\n    groupItems,\n    rootElId: CONTAINER_ID,\n  }\n}\n","fileName":"chord-chart-config.ts"},{"content":"import { csv } from \"d3\"\n\ntype CSVDataItem = {\n  amount: string\n  creditor: string\n  debtor: string\n  risk: string\n}\n\ntype Country = {\n  id: number\n  name: string\n}\n\ntype Creditor = Country\ntype Debtor = Country & { risk: string }\n\ntype CSVParsedItem = {\n  amount: string\n  creditor: Creditor\n  debtor: Debtor\n  risk: string\n}\n\nexport type FinancialMatrix = Array<Array<CSVParsedItem | null>>\n\nclass FinancialData {\n  private readonly credits: FinancialMatrix\n  private readonly debits: FinancialMatrix\n  private readonly countriesList: Country[]\n\n  private constructor({\n    countriesList,\n    credits,\n    debits,\n  }: {\n    countriesList: Country[]\n    credits: FinancialMatrix\n    debits: FinancialMatrix\n  }) {\n    this.credits = credits\n    this.debits = debits\n    this.countriesList = countriesList\n  }\n\n  public static async fetchAndCreate(): Promise<FinancialData> {\n    const originalCSVItems = (await csv(\n      `${ROOT_PATH}data/d3js/chord/data.csv`\n    )) as CSVDataItem[]\n\n    const countriesList: Country[] = []\n    const countries: Record<string, Country> = {}\n    const debits: FinancialMatrix = []\n    const credits: FinancialMatrix = []\n\n    let id = 0\n\n    const country = (countryName: string): Country => {\n      if (!(countryName in countries)) {\n        countries[countryName] = {\n          id,\n          name: countryName,\n        }\n\n        id += 1\n      }\n\n      return countries[countryName]\n    }\n\n    const parsedList: CSVParsedItem[] = originalCSVItems.map(\n      (originalCSVItem) => ({\n        ...originalCSVItem,\n        creditor: country(originalCSVItem.creditor),\n        debtor: {\n          ...country(originalCSVItem.debtor),\n          risk: originalCSVItem.risk,\n        },\n      })\n    )\n\n    Array.from({ length: id }).forEach((...[, sourceIndex]) => {\n      debits[sourceIndex] = []\n      credits[sourceIndex] = []\n\n      Array.from({ length: id }).forEach((...[, targetIndex]) => {\n        debits[sourceIndex][targetIndex] = null\n        credits[sourceIndex][targetIndex] = null\n      })\n    })\n\n    parsedList.forEach((financialItem) => {\n      debits[financialItem.creditor.id][financialItem.debtor.id] = financialItem\n      credits[financialItem.debtor.id][\n        financialItem.creditor.id\n      ] = financialItem\n\n      countriesList[financialItem.creditor.id] = financialItem.creditor\n      countriesList[financialItem.debtor.id] = financialItem.debtor\n    })\n\n    return new FinancialData({\n      countriesList,\n      credits,\n      debits,\n    })\n  }\n\n  public getCredits() {\n    return this.credits\n  }\n\n  public getDebits() {\n    return this.debits\n  }\n\n  public getCountriesList() {\n    return this.countriesList\n  }\n}\n\nexport { FinancialData }\n","fileName":"chord-data-model.ts"},{"content":"import {\n  BaseType,\n  Chord,\n  ChordGroup,\n  Selection,\n  arc as arcD3,\n  chord,\n  descending,\n  extent,\n  range,\n  rgb,\n  ribbon as ribbonD3,\n  scaleLinear,\n  select,\n} from \"d3\"\nimport { v1 as uuidv1 } from \"uuid\"\n\nimport * as styles from \"./chord.module.css\"\n\nconst addDropShadowFilter = <SVGData>({\n  charts,\n  deviation,\n  name,\n  slope,\n}: {\n  charts: Selection<BaseType, SVGData, BaseType, unknown>\n  deviation: number\n  name: string\n  slope: number\n}) => {\n  const defs = charts.append(\"defs\")\n  const filter = defs.append(\"filter\").attr(\"id\", name)\n\n  filter\n    .append(\"feOffset\")\n    .attr(\"dx\", 0.5)\n    .attr(\"dy\", 0.5)\n    .attr(\"in\", \"SourceGraphic\")\n    .attr(\"result\", \"offOut\")\n\n  filter\n    .append(\"feGaussianBlur\")\n    .attr(\"in\", \"offOut\")\n    .attr(\"result\", \"blurOut\")\n    .attr(\"stdDeviation\", deviation)\n\n  filter\n    .append(\"feBlend\")\n    .attr(\"in\", \"SourceGraphic\")\n    .attr(\"in2\", \"blurOut\")\n    .attr(\"mode\", \"normal\")\n\n  filter\n    .append(\"feComponentTransfer\")\n    .append(\"feFuncA\")\n    .attr(\"slope\", slope)\n    .attr(\"type\", \"linear\")\n}\n\nconst colours = [\n  \"#39B347\",\n  \"#C92E47\",\n  \"#DB704D\",\n  \"#FFA22C\",\n  \"#5E92AA\",\n  \"#F8EDD3\",\n]\n\nconst margin = {\n  bottom: 20,\n  top: 50,\n}\nconst height = 500\n\ntype GroupItem = {\n  id: number\n  label: string\n}\ntype ChordMatrix = number[][]\n\nexport type ChartConfig = {\n  chords: [ChordMatrix, ChordMatrix]\n  chordsTitles: [string, string]\n  getGroupTitle: (o: { chartIndex: number; chordGroup: ChordGroup }) => string\n  getRibbonTitle: (o: {\n    sourceIndex: number\n    sourceValue: number\n    targetIndex: number\n    targetValue: number\n  }) => string\n  groupItems: GroupItem[]\n  rootElId: string\n}\n\nexport const renderChart = (chartConfig: ChartConfig) => {\n  const { chords, chordsTitles, groupItems, rootElId } = chartConfig\n  const rootEl = document.getElementById(rootElId) as HTMLElement\n  const [leftChordItems, rightChordItems] = chords\n  const [leftChordLabel, rightChordLabel] = chordsTitles\n\n  const dropShadowRibbonsId = `drop-shadow-ribbons-${uuidv1().slice(0, 6)}`\n  const dropShadowGroupsId = `drop-shadow-groups-${uuidv1().slice(0, 6)}`\n\n  const ribbonItemClass = `ribbon-item-${uuidv1().slice(0, 6)}`\n  const chordGroupClass = `chord-group-${uuidv1().slice(0, 6)}`\n\n  rootEl.classList.add(styles.chordChart)\n\n  const width = rootEl.getBoundingClientRect().width / 2 - 20\n\n  const r1 = Math.min(width, height) / 2 - 4\n  const r0 = r1 - 20\n\n  const chordGroupArc = arcD3<ChordGroup>().innerRadius(r0).outerRadius(r1)\n  const svg = select(`#${rootElId}`)\n\n  const charts = svg\n    .selectAll(\"div\")\n    .data([leftChordItems, rightChordItems])\n    .enter()\n    .append(\"div\")\n    .style(\"display\", \"inline-block\")\n    .style(\"width\", `${width}px`)\n    .style(\"height\", `${height + margin.top + margin.bottom}px`)\n    .append(\"svg:svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height + margin.top + margin.bottom)\n    .append(\"svg:g\")\n    .attr(\"transform\", `translate(${width / 2},${height / 2 + margin.top})`)\n\n  const leftChart = charts.filter((...[, chartIndex]) => chartIndex === 0)\n  const rightChart = charts.filter((...[, chartIndex]) => chartIndex === 1)\n\n  const setLabel = ({\n    chart,\n    label,\n  }: {\n    chart: Selection<BaseType, ChordMatrix, BaseType, unknown>\n    label: string\n  }) =>\n    chart\n      .append(\"text\")\n      .text(label)\n      .attr(\"transform\", `translate(0,${(-1 * height) / 2 - 10})`)\n      .attr(\"class\", styles.chartTitle)\n      .attr(\"text-anchor\", \"middle\")\n\n  setLabel({ chart: leftChart, label: leftChordLabel })\n  setLabel({ chart: rightChart, label: rightChordLabel })\n\n  addDropShadowFilter({\n    charts,\n    deviation: 2,\n    name: dropShadowRibbonsId,\n    slope: 0.4,\n  })\n  addDropShadowFilter({\n    charts,\n    deviation: 3,\n    name: dropShadowGroupsId,\n    slope: 0.5,\n  })\n\n  const colorDomain = scaleLinear()\n    .domain(extent([0, groupItems.length - 1]) as [number, number])\n    .range([0, 1])\n\n  const heatmapColour = scaleLinear<string>()\n    .domain(range(0, 1, 1.0 / colours.length))\n    .range(colours)\n\n  const fillGroupIndex = (chordGroupIndex: number) =>\n    heatmapColour(colorDomain(chordGroupIndex))\n\n  charts.each(function (...[numberMatrix, chartIndex]) {\n    const svgComp = select(this)\n\n    const chordData = chord()\n      .sortGroups(descending)\n      .sortSubgroups(descending)\n      .sortChords(descending)(numberMatrix)\n\n    const ribbonPath = ribbonD3<Chord, Chord>().radius(r0)\n\n    svgComp\n      .selectAll(`path.${styles.chord}`)\n      .data(chordData)\n      .enter()\n      .append(\"path\")\n      .attr(\"d\", ribbonPath)\n      .attr(\"class\", `${styles.chord} ${ribbonItemClass}`)\n      .style(\"fill\", (chordItem) => fillGroupIndex(chordItem.target.index))\n      .style(\"filter\", `url(#${dropShadowRibbonsId})`)\n      .style(\"stroke\", (ribbonItem) => {\n        const originalColor = fillGroupIndex(ribbonItem.target.index)\n        const newColor = rgb(originalColor).darker()\n\n        return newColor.formatHex()\n      })\n      .style(\"stroke-width\", 2)\n      .attr(\"title\", (ribbonItem) =>\n        chartConfig.getRibbonTitle({\n          sourceIndex: ribbonItem.source.index,\n          sourceValue: ribbonItem.source.value,\n          targetIndex: ribbonItem.target.index,\n          targetValue: ribbonItem.source.value,\n        })\n      )\n\n    const g = svgComp\n      .selectAll(`g.${styles.group}`)\n      .data(chordData.groups)\n      .enter()\n      .append(\"svg:g\")\n      .attr(\"class\", styles.group)\n\n    g.append(\"svg:path\")\n      .attr(\"d\", chordGroupArc)\n      .style(\"fill\", (chordGroup) => fillGroupIndex(chordGroup.index))\n      .attr(\"id\", (chordGroup) => `group${chordGroup.index}-${chartIndex}`)\n      .attr(\"class\", chordGroupClass)\n      .style(\"filter\", () => `url(#${dropShadowGroupsId})`)\n      .attr(\"title\", (chordGroup) =>\n        chartConfig.getGroupTitle({\n          chartIndex,\n          chordGroup,\n        })\n      )\n\n    g.append(\"svg:text\")\n      .attr(\"x\", 6)\n      .attr(\"dy\", 15)\n      .filter((chordGroup) => chordGroup.value > 150)\n      .append(\"svg:textPath\")\n      .attr(\n        \"xlink:href\",\n        (chordGroup) => `#group${chordGroup.index}-${chartIndex}`\n      )\n      .text((chordGroup) => groupItems[chordGroup.index].label)\n      .attr(\"class\", styles.headingTitle)\n\n    $(`.${ribbonItemClass}`).tooltip({\n      track: true,\n    })\n\n    $(`.${chordGroupClass}`).tooltip({\n      track: true,\n    })\n  })\n}\n","fileName":"double-chord-chart.ts"}],"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main, { CONTAINER_ID } from \"@/demos/chord/chord\"\n\nconst Chord = ({ pageContext }: DemoPageProps) => (\n  <Demo\n    links={[\"/vendors/jquery-ui/themes/base/jquery-ui.min.css\"]}\n    main={main}\n    pageContext={pageContext}\n    scripts={[\"/vendors/jquery-ui/jquery-ui.min.js\"]}\n  >\n    <div id={CONTAINER_ID} />\n  </Demo>\n)\n\nexport default Chord\n","type":"tsx"}},"key":"chord"},"meta":{"description":"Chord Chart example using D3.js, which has a different color scheme with a color for each country, and a special drop shadow filter for a 3D effect."}}},"staticQueryHashes":[]}