{
    "componentChunkName": "component---src-pages-d-3-js-chord-tsx",
    "path": "/d3js/chord/",
    "result": {"pageContext":{"demoInfo":{"dataFiles":["data.csv"],"docs":[],"isCompleted":true,"name":"Chord","notes":[],"sources":["http://bl.ocks.org/mbostock/1308257"],"summary":[],"category":"d3js","files":{"demoCSS":[{"content":".chartTitle {\n  font-weight: bold;\n}\n\n.chord {\n  fill-opacity: 0.75;\n  stroke-width: 0.75;\n}\n\n.group text {\n  font: 10rem sans-serif;\n  pointer-events: none;\n}\n\n.group path {\n  stroke: #000;\n}\n\n.groupLabel {\n  font-size: 14px;\n}\n","filePath":"src/demos/chord/chord.module.css"}],"demoTS":[{"content":"import {\n  CONTAINER_ID,\n  UPDATE_BUTTON_ID,\n  getChartConfig,\n} from \"./chord-chart-config\"\nimport { FinancialData } from \"./chord-data-model\"\nimport { NChordChart } from \"./n-chord-chart\"\n\nconst main = async () => {\n  const financialData = await FinancialData.fetchAndCreate()\n  const chartConfig = getChartConfig(financialData)\n\n  const chordChart = NChordChart.renderChart(chartConfig)\n  const buttonEl = document.getElementById(UPDATE_BUTTON_ID)!\n\n  buttonEl.addEventListener(\"click\", () => {\n    chartConfig.chords.forEach((chordMatrix) => {\n      chordMatrix.forEach((...[chordRow, chordRowIndex]) => {\n        chordRow.forEach((...[, chordCellIndex]) => {\n          // Avoid creating a self-referencing ribbon\n          if (chordRowIndex === chordCellIndex) {\n            return\n          }\n\n          const shouldUpdate = Math.random() < 0.1\n\n          if (shouldUpdate) {\n            chordRow[chordCellIndex] = Math.max(\n              0,\n              Math.floor(Math.random() * 100) - 20\n            )\n          }\n        })\n      })\n    })\n    chordChart.refresh()\n  })\n}\n\nexport { CONTAINER_ID, UPDATE_BUTTON_ID }\n\nexport default main\n","filePath":"src/demos/chord/chord.ts"},{"content":"import { format } from \"d3\"\n\nimport { FinancialData, FinancialMatrix } from \"./chord-data-model\"\nimport { ChartConfig } from \"./n-chord-chart\"\n\nconst CONTAINER_ID = \"chart\"\nconst UPDATE_BUTTON_ID = \"update\"\n\nconst getChartConfig = (financialData: FinancialData): ChartConfig => {\n  const debits = financialData.getDebits()\n  const credits = financialData.getCredits()\n  const countriesList = financialData.getCountriesList()\n\n  const formatCurrencyNum = format(\",.3r\")\n\n  const formatCurrency = (currencyValue: number) =>\n    `$${formatCurrencyNum(currencyValue)}B.`\n\n  const getRibbonTitle: ChartConfig[\"getRibbonTitle\"] = ({\n    chartIndex,\n    sourceIndex,\n    sourceValue,\n    targetIndex,\n  }) => {\n    const { [sourceIndex]: sourceData, [targetIndex]: targetData } =\n      countriesList\n\n    const names = [targetData.name, sourceData.name]\n\n    if (chartIndex) {\n      names.reverse()\n    }\n\n    return `${names[0]} owes ${names[1]} ${formatCurrency(sourceValue)}`\n  }\n\n  const getGroupTitle: ChartConfig[\"getGroupTitle\"] = ({\n    chartIndex,\n    chordGroup,\n  }) =>\n    `${countriesList[chordGroup.index].name} ${\n      chartIndex ? \"owes\" : \"is owed\"\n    } ${formatCurrency(chordGroup.value)}`\n\n  const groupItems = countriesList.map((country) => ({\n    id: country.id,\n    label: country.name,\n  }))\n\n  const extractChordMatrix = (row: FinancialMatrix[0]) =>\n    row.map((cell) => (cell ? +cell.amount : 0))\n\n  const chordLeft = debits.map(extractChordMatrix)\n  const chordRight = credits.map(extractChordMatrix)\n\n  return {\n    chords: [chordLeft, chordRight],\n    chordsTitles: [\"Debits\", \"Credits\"],\n    getGroupTitle,\n    getRibbonTitle,\n    groupItems,\n    rootElId: CONTAINER_ID,\n  }\n}\n\nexport { CONTAINER_ID, UPDATE_BUTTON_ID, getChartConfig }\n","filePath":"src/demos/chord/chord-chart-config.ts"},{"content":"import { csv } from \"d3\"\n\ntype CSVDataItem = {\n  amount: string\n  creditor: string\n  debtor: string\n  risk: string\n}\n\ntype Country = {\n  id: number\n  name: string\n}\n\ntype Creditor = Country\ntype Debtor = Country & { risk: string }\n\ntype CSVParsedItem = {\n  amount: string\n  creditor: Creditor\n  debtor: Debtor\n  risk: string\n}\n\ntype FinancialMatrix = Array<Array<CSVParsedItem | null>>\n\nclass FinancialData {\n  private readonly credits: FinancialMatrix\n  private readonly debits: FinancialMatrix\n  private readonly countriesList: Country[]\n\n  private constructor({\n    countriesList,\n    credits,\n    debits,\n  }: {\n    countriesList: Country[]\n    credits: FinancialMatrix\n    debits: FinancialMatrix\n  }) {\n    this.credits = credits\n    this.debits = debits\n    this.countriesList = countriesList\n  }\n\n  public static async fetchAndCreate(): Promise<FinancialData> {\n    const originalCSVItems = (await csv(\n      `${ROOT_PATH}data/d3js/chord/data.csv`\n    )) as CSVDataItem[]\n\n    const countriesList: Country[] = []\n    const countries: Record<string, Country> = {}\n    const debits: FinancialMatrix = []\n    const credits: FinancialMatrix = []\n\n    let id = 0\n\n    const country = (countryName: string): Country => {\n      if (!(countryName in countries)) {\n        countries[countryName] = {\n          id,\n          name: countryName,\n        }\n\n        id += 1\n      }\n\n      return countries[countryName]\n    }\n\n    const parsedList: CSVParsedItem[] = originalCSVItems.map(\n      (originalCSVItem) => ({\n        ...originalCSVItem,\n        creditor: country(originalCSVItem.creditor),\n        debtor: {\n          ...country(originalCSVItem.debtor),\n          risk: originalCSVItem.risk,\n        },\n      })\n    )\n\n    Array.from({ length: id }).forEach((...[, sourceIndex]) => {\n      debits[sourceIndex] = []\n      credits[sourceIndex] = []\n\n      Array.from({ length: id }).forEach((...[, targetIndex]) => {\n        debits[sourceIndex][targetIndex] = null\n        credits[sourceIndex][targetIndex] = null\n      })\n    })\n\n    parsedList.forEach((financialItem) => {\n      debits[financialItem.creditor.id][financialItem.debtor.id] = financialItem\n      credits[financialItem.debtor.id][financialItem.creditor.id] =\n        financialItem\n\n      countriesList[financialItem.creditor.id] = financialItem.creditor\n      countriesList[financialItem.debtor.id] = financialItem.debtor\n    })\n\n    return new FinancialData({\n      countriesList,\n      credits,\n      debits,\n    })\n  }\n\n  public getCredits() {\n    return this.credits\n  }\n\n  public getDebits() {\n    return this.debits\n  }\n\n  public getCountriesList() {\n    return this.countriesList\n  }\n}\n\nexport { FinancialData, FinancialMatrix }\n","filePath":"src/demos/chord/chord-data-model.ts"},{"content":"import {\n  BaseType,\n  Chord,\n  ChordGroup,\n  ScaleOrdinal,\n  Selection,\n  arc as arcD3,\n  chord,\n  descending,\n  interpolate,\n  rgb,\n  ribbon as ribbonD3,\n  scaleOrdinal,\n  schemePastel2,\n  select,\n} from \"d3\"\nimport { v1 as uuidv1 } from \"uuid\"\n\nimport * as styles from \"./chord.module.css\"\n\nconst getRibbonKey = (ribbonNode: Chord) =>\n  `${ribbonNode.source.index}_${ribbonNode.target.index}`\n\nconst getChordGroupKey = (chordGroup: ChordGroup) => chordGroup.index\n\nconst addDropShadowFilter = <SVGData>({\n  charts,\n  deviation,\n  name,\n  slope,\n}: {\n  charts: Selection<SVGGElement, SVGData, BaseType, unknown>\n  deviation: number\n  name: string\n  slope: number\n}) => {\n  const defs = charts.append(\"defs\")\n  const filter = defs.append(\"filter\").attr(\"id\", name)\n\n  filter\n    .append(\"feOffset\")\n    .attr(\"dx\", 0.5)\n    .attr(\"dy\", 0.5)\n    .attr(\"in\", \"SourceGraphic\")\n    .attr(\"result\", \"offOut\")\n\n  filter\n    .append(\"feGaussianBlur\")\n    .attr(\"in\", \"offOut\")\n    .attr(\"result\", \"blurOut\")\n    .attr(\"stdDeviation\", deviation)\n\n  filter\n    .append(\"feBlend\")\n    .attr(\"in\", \"SourceGraphic\")\n    .attr(\"in2\", \"blurOut\")\n    .attr(\"mode\", \"normal\")\n\n  filter\n    .append(\"feComponentTransfer\")\n    .append(\"feFuncA\")\n    .attr(\"slope\", slope)\n    .attr(\"type\", \"linear\")\n}\n\nconst margin = {\n  bottom: 20,\n  top: 50,\n}\n\ntype GroupItem = {\n  id: number\n  label: string\n}\ntype ChordMatrix = number[][]\n\ntype ChartConfig = {\n  chords: ChordMatrix[]\n  chordsTitles: string[]\n  getGroupTitle: (options: {\n    chartIndex: number\n    chordGroup: ChordGroup\n  }) => string\n  getRibbonTitle: (options: {\n    chartIndex: number\n    sourceIndex: number\n    sourceValue: number\n    targetIndex: number\n    targetValue: number\n  }) => string\n  groupItems: GroupItem[]\n  rootElId: string\n}\n\ntype ChartElements = Readonly<{\n  charts: Selection<SVGGElement, ChordMatrix, BaseType, unknown>\n  chartsDivs: Selection<HTMLDivElement, ChordMatrix, BaseType, unknown>\n  chartsSVGs: Selection<SVGSVGElement, ChordMatrix, BaseType, unknown>\n  root: Selection<BaseType, unknown, HTMLElement, unknown>\n}>\n\ninterface BaseChart {\n  refresh: () => void\n  tearDown: () => void\n}\n\nclass NChordChart implements BaseChart {\n  private readonly config: ChartConfig\n  private readonly dropShadowGroupsId: string\n  private readonly ribbonItemClass: string\n  private readonly chordGroupClass: string\n  private readonly elements: ChartElements\n  private readonly colorScale: ScaleOrdinal<number, string>\n\n  private constructor(chartConfig: ChartConfig) {\n    this.config = chartConfig\n\n    const {\n      config: { chords, rootElId },\n    } = this\n\n    this.dropShadowGroupsId = `drop-shadow-groups-${uuidv1().slice(0, 6)}`\n    this.ribbonItemClass = `ribbon-item-${uuidv1().slice(0, 6)}`\n    this.chordGroupClass = `chord-group-${uuidv1().slice(0, 6)}`\n\n    const root = select(`#${rootElId}`)\n      .style(\"width\", \"100%\")\n      .style(\"justify-content\", \"space-evenly\")\n\n    root.selectAll(\"div\").data(chords).enter().append(\"div\")\n\n    const chartsDivs = root.selectAll<HTMLDivElement, ChordMatrix>(\"div\")\n    const chartsSVGs = chartsDivs.append(\"svg\")\n    const charts = chartsSVGs.append(\"g\")\n\n    this.elements = {\n      charts,\n      chartsDivs,\n      chartsSVGs,\n      root,\n    }\n\n    charts.each((...[, chartIndex]) => {\n      const chart = charts.filter(\n        (...[, chartIndexInner]) => chartIndex === chartIndexInner\n      )\n      const {\n        chordsTitles: { [chartIndex]: label },\n      } = chartConfig\n\n      chart\n        .append(\"text\")\n        .text(label)\n        .attr(\"class\", styles.chartTitle)\n        .attr(\"text-anchor\", \"middle\")\n    })\n\n    addDropShadowFilter({\n      charts,\n      deviation: 3,\n      name: this.dropShadowGroupsId,\n      slope: 0.5,\n    })\n\n    this.colorScale = scaleOrdinal<number, string>(schemePastel2)\n\n    this.render()\n\n    window.addEventListener(\"resize\", this.handleWindowResize)\n  }\n\n  public static renderChart(chartConfig: ChartConfig) {\n    return new NChordChart(chartConfig)\n  }\n\n  public tearDown() {\n    window.removeEventListener(\"resize\", this.handleWindowResize)\n  }\n\n  public refresh() {\n    this.render(true)\n  }\n\n  private render(withAnimation?: boolean) {\n    const {\n      colorScale,\n      config: { chords, getGroupTitle, getRibbonTitle, groupItems, rootElId },\n    } = this\n\n    const animationDuration = withAnimation ? 1000 : 0\n    const rootEl = document.getElementById(rootElId) as HTMLElement\n    const { width: fullWidth } = rootEl.getBoundingClientRect()\n    const width = fullWidth / chords.length - 20\n    const isSmallDevice = fullWidth < 768\n    const height = isSmallDevice ? fullWidth : width\n    const {\n      elements: { charts, chartsDivs, chartsSVGs, root },\n    } = this\n\n    const outerRadius =\n      Math.min(width, height) / (isSmallDevice ? 1 : chords.length) -\n      (isSmallDevice ? 0 : 20)\n    const innerRadius = outerRadius - 20\n\n    const chordGroupArc = arcD3<ChordGroup>()\n      .innerRadius(innerRadius)\n      .outerRadius(outerRadius)\n\n    root\n      .style(\"display\", isSmallDevice ? \"flex\" : \"inline-flex\")\n      .style(\"flex-direction\", isSmallDevice ? \"column\" : \"row\")\n\n    chartsDivs\n      .attr(\"width\", isSmallDevice ? fullWidth : width)\n      .style(\"height\", `${height + margin.top + margin.bottom}px`)\n\n    chartsSVGs\n      .attr(\"width\", isSmallDevice ? fullWidth : width)\n      .attr(\"height\", height + margin.top + margin.bottom)\n\n    charts.attr(\n      \"transform\",\n      isSmallDevice\n        ? `translate(${fullWidth / 2},${height / 2 + margin.top})`\n        : `translate(${width / 2},${height / 2 + margin.top})`\n    )\n\n    charts.each((...[, chartIndex]) => {\n      const chart = charts.filter(\n        (...[, chartIndexInner]) => chartIndex === chartIndexInner\n      )\n\n      chart\n        .select(`.${styles.chartTitle}`)\n        .attr(\"transform\", `translate(0,${(-1 * height) / 2 - 0})`)\n    })\n\n    const { chordGroupClass, dropShadowGroupsId, ribbonItemClass } = this\n\n    charts.each(function renderSingleChart(...[numberMatrix, chartIndex]) {\n      const chartSel = select(this)\n\n      const chordData = chord().sortChords(descending)(numberMatrix)\n\n      const ribbonPath = ribbonD3<Chord, Chord>().radius(innerRadius)\n\n      const initialRibbonsData = chartSel\n        .selectAll<SVGPathElement, Chord>(`.${styles.chord}`)\n        .data()\n        .reduce<{ [k: string]: Chord | undefined }>((...[acc, ribbonNode]) => {\n          acc[getRibbonKey(ribbonNode)] = ribbonNode\n\n          return acc\n        }, {})\n\n      const chordUpdated = chartSel\n        .selectAll(`.${styles.chord}`)\n        .data(chordData, (...[, ribbonIndex]) => ribbonIndex)\n\n      chordUpdated\n        .enter()\n        .append(\"path\")\n        .attr(\"class\", `${styles.chord} ${ribbonItemClass}`)\n      chordUpdated.exit().remove()\n\n      chartSel\n        .selectAll<SVGPathElement, Chord>(`path.${styles.chord}`)\n        .style(\"fill\", (chordItem) => colorScale(chordItem.target.index))\n        .style(\"stroke\", (ribbonItem) => {\n          const originalColor = colorScale(ribbonItem.target.index)\n          const newColor = rgb(originalColor).darker()\n\n          return newColor.formatHex()\n        })\n        .style(\"stroke-width\", 2)\n        .attr(\"title\", (ribbonItem) =>\n          getRibbonTitle({\n            chartIndex,\n            sourceIndex: ribbonItem.source.index,\n            sourceValue: ribbonItem.source.value,\n            targetIndex: ribbonItem.target.index,\n            targetValue: ribbonItem.source.value,\n          })\n        )\n        .transition()\n        .duration(animationDuration)\n        .attrTween(\"d\", (finalRibbon) => {\n          const { [getRibbonKey(finalRibbon)]: initialRibbon } =\n            initialRibbonsData\n          const interpolateFn = interpolate(\n            initialRibbon ?? finalRibbon,\n            finalRibbon\n          )\n\n          return (time) => {\n            const interpolatedRibbon = interpolateFn(time)\n\n            return ribbonPath(interpolatedRibbon)!\n          }\n        })\n\n      const newGroupsSel = chartSel\n        .selectAll<SVGGElement, ChordGroup>(`.${styles.group}`)\n        .data(chordData.groups, getChordGroupKey)\n        .enter()\n        .append(\"g\")\n        .attr(\"class\", styles.group)\n\n      newGroupsSel.append(\"path\").attr(\"class\", chordGroupClass)\n      newGroupsSel\n        .append(\"text\")\n        .attr(\"class\", \"group-text\")\n        .attr(\"x\", 6)\n        .attr(\"dy\", 15)\n        .append(\"textPath\")\n        .attr(\n          \"xlink:href\",\n          (chordGroup) => `#group${chordGroup.index}-${chartIndex}`\n        )\n        .attr(\"class\", styles.groupLabel)\n        .text((chordGroup) => groupItems[chordGroup.index].label)\n\n      const initialGroupsData = chartSel.selectAll(`.${chordGroupClass}`).data()\n      const groupsSel = chartSel.selectAll(`.${styles.group}`)\n\n      groupsSel\n        .selectAll<SVGPathElement, ChordGroup>(`.${chordGroupClass}`)\n        .data(chordData.groups, getChordGroupKey)\n        .style(\"fill\", (chordGroup) => colorScale(chordGroup.index))\n        .attr(\"id\", (chordGroup) => `group${chordGroup.index}-${chartIndex}`)\n        .style(\"filter\", () => `url(#${dropShadowGroupsId})`)\n        .attr(\"title\", (chordGroup) =>\n          getGroupTitle({\n            chartIndex,\n            chordGroup,\n          })\n        )\n        .transition()\n        .duration(animationDuration)\n        .attrTween(\"d\", (finalGroup) => {\n          const { [finalGroup.index]: initialGroup } = initialGroupsData\n          const interpolateFn = interpolate(initialGroup, finalGroup)\n\n          return (t) => chordGroupArc(interpolateFn(t))!\n        })\n\n      groupsSel\n        .selectAll<SVGTextElement, ChordGroup>(\".group-text\")\n        .selectAll<SVGTextPathElement, ChordGroup>(\"textPath\")\n        .data(chordData.groups, getChordGroupKey)\n        .transition()\n        .duration(animationDuration)\n        .style(\"opacity\", (chordGroup) =>\n          Math.abs(chordGroup.startAngle - chordGroup.endAngle) > 0.4 ? 1 : 0\n        )\n      ;[ribbonItemClass, chordGroupClass].forEach((className) => {\n        $(`.${className}`).tooltip({\n          track: true,\n        })\n      })\n    })\n  }\n\n  private readonly handleWindowResize = () => {\n    this.render()\n  }\n}\n\nexport { NChordChart, ChartConfig }\n","filePath":"src/demos/chord/n-chord-chart.ts"}],"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps, JQUERYUI } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main, { CONTAINER_ID, UPDATE_BUTTON_ID } from \"@/demos/chord/chord\"\n\nconst Chord = ({ pageContext }: DemoPageProps) => (\n  <Demo\n    links={[JQUERYUI.STYLE]}\n    main={main}\n    pageContext={pageContext}\n    scripts={[JQUERYUI.SCRIPT]}\n  >\n    <form style={{ marginBottom: 20 }}>\n      <button className=\"btn btn-info\" id={UPDATE_BUTTON_ID} type=\"button\">\n        Update Random Value\n      </button>\n    </form>\n    <div id={CONTAINER_ID} />\n  </Demo>\n)\n\nexport default Chord\n","type":"tsx"}},"key":"chord"},"meta":{"description":"Chord Chart example using D3.js, which has a different color scheme with a color for each country, and a special drop shadow filter for a 3D effect."}}},
    "staticQueryHashes": []}