{"componentChunkName":"component---src-pages-d-3-js-chord-tsx","path":"/d3js/chord/","result":{"pageContext":{"demoInfo":{"data":["data.csv"],"docs":[],"isCompleted":true,"name":"Chord","notes":["Added filters with drop shadow and low opacity","Changed scheme and match each color with a country"],"sources":["http://bl.ocks.org/mbostock/1308257"],"summary":[],"category":"d3js","files":{"demo":{"content":"import {\n  BaseType,\n  Selection,\n  arc as arcD3,\n  chord,\n  csv,\n  descending,\n  extent,\n  format,\n  range,\n  rgb,\n  ribbon,\n  scaleLinear,\n  select,\n} from \"d3\"\n\nimport * as styles from \"./chord.module.css\"\n\ntype CSVDataItem = {\n  amount: string\n  creditor: string\n  debtor: string\n  risk: string\n}\n\ntype Country = {\n  name: string\n  id: number\n}\n\ntype Creditor = Country\ntype Debtor = Country & { risk: string }\n\ntype CSVParsedItem = {\n  amount: string\n  creditor: Creditor\n  debtor: Debtor\n  risk: string\n}\n\ntype Debits = (CSVParsedItem | null)[][]\ntype Credits = (CSVParsedItem | null)[][]\n\ntype Data = {\n  fullList: Country[]\n  debits: Debits\n  credits: Credits\n}\n\nconst fetchData = async () => {\n  const list = (await csv(\n    `${ROOT_PATH}data/d3js/chord/data.csv`\n  )) as CSVDataItem[]\n\n  const fullList: Country[] = []\n  const countries: Record<string, Country> = {}\n  const debits: Debits = []\n  const credits: Credits = []\n\n  let id = 0\n\n  const country = function (countryName: string): Country {\n    if (!countries[countryName]) {\n      countries[countryName] = {\n        id: id++,\n        name: countryName,\n      }\n    }\n\n    return countries[countryName]\n  }\n\n  const parsedList: CSVParsedItem[] = list.map((d) => ({\n    ...d,\n    creditor: country(d.creditor),\n    debtor: {\n      ...country(d.debtor),\n      risk: d.risk,\n    },\n  }))\n\n  Array.from({ length: id }).forEach((_, idx) => {\n    debits[idx] = []\n    credits[idx] = []\n\n    Array.from({ length: id }).forEach((_2, idx2) => {\n      debits[idx][idx2] = null\n      credits[idx][idx2] = null\n    })\n  })\n\n  parsedList.forEach((d) => {\n    debits[d.creditor.id][d.debtor.id] = d\n    credits[d.debtor.id][d.creditor.id] = d\n    fullList[d.creditor.id] = d.creditor\n    fullList[d.debtor.id] = d.debtor\n  })\n\n  return {\n    credits,\n    debits,\n    fullList,\n  }\n}\n\nconst addDropShadowFilter = function <A>(\n  charts: Selection<BaseType, A, BaseType, unknown>,\n  name: string,\n  deviation: number,\n  slope: number\n) {\n  const defs = charts.append(\"defs\")\n  const filter = defs.append(\"filter\").attr(\"id\", `drop-shadow-${name}`)\n\n  filter\n    .append(\"feOffset\")\n    .attr(\"dx\", 0.5)\n    .attr(\"dy\", 0.5)\n    .attr(\"in\", \"SourceGraphic\")\n    .attr(\"result\", \"offOut\")\n\n  filter\n    .append(\"feGaussianBlur\")\n    .attr(\"in\", \"offOut\")\n    .attr(\"result\", \"blurOut\")\n    .attr(\"stdDeviation\", deviation)\n\n  filter\n    .append(\"feBlend\")\n    .attr(\"in\", \"SourceGraphic\")\n    .attr(\"in2\", \"blurOut\")\n    .attr(\"mode\", \"normal\")\n\n  filter\n    .append(\"feComponentTransfer\")\n    .append(\"feFuncA\")\n    .attr(\"slope\", slope)\n    .attr(\"type\", \"linear\")\n}\n\nconst colours = [\n  \"#39B347\",\n  \"#C92E47\",\n  \"#DB704D\",\n  \"#FFA22C\",\n  \"#5E92AA\",\n  \"#F8EDD3\",\n]\n\nconst margin = {\n  bottom: 20,\n  top: 50,\n}\nconst height = 500\n\ntype RenderChart = (o: { rootElId: string; data: Data }) => void\n\nconst renderChart: RenderChart = ({ rootElId, data }) => {\n  const rootEl = document.getElementById(rootElId) as HTMLElement\n\n  rootEl.classList.add(styles.chordChart)\n\n  const width = rootEl.getBoundingClientRect().width / 2 - 20\n\n  const r1 = Math.min(width, height) / 2 - 4\n  const r0 = r1 - 20\n  const formatCurrency = format(\",.3r\")\n\n  const arc = arcD3().innerRadius(r0).outerRadius(r1)\n  const svg = select(`#${rootElId}`)\n\n  const { debits, credits, fullList } = data\n\n  const charts = svg\n    .selectAll(\"div\")\n    .data([debits, credits])\n    .enter()\n    .append(\"div\")\n    .style(\"display\", \"inline-block\")\n    .style(\"width\", `${width}px`)\n    .style(\"height\", `${height + margin.top + margin.bottom}px`)\n    .append(\"svg:svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height + margin.top + margin.bottom)\n    .append(\"svg:g\")\n    .attr(\"transform\", `translate(${width / 2},${height / 2 + margin.top})`)\n\n  const leftChart = charts.filter((_d, i) => i === 0)\n  const rightChart = charts.filter((_d, i) => i === 1)\n\n  const setLabel = function (\n    chart: Selection<BaseType, Debits, BaseType, unknown>,\n    label: string\n  ) {\n    return chart\n      .append(\"text\")\n      .text(label)\n      .attr(\"transform\", `translate(0,${(-1 * height) / 2 - 10})`)\n      .attr(\"class\", styles.chartTitle)\n      .attr(\"text-anchor\", \"middle\")\n  }\n\n  setLabel(leftChart, \"Debits\")\n  setLabel(rightChart, \"Credits\")\n\n  addDropShadowFilter(charts, \"chords\", 2, 0.4)\n  addDropShadowFilter(charts, \"headings\", 3, 0.5)\n\n  const colorDomain = scaleLinear()\n    .domain(extent([0, fullList.length - 1]) as [number, number])\n    .range([0, 1])\n\n  const heatmapColour = scaleLinear<string>()\n    .domain(range(0, 1, 1.0 / colours.length))\n    .range(colours)\n\n  const fill = function (d: number) {\n    return heatmapColour(colorDomain(d))\n  }\n\n  charts.each(function (dataMatrix, chartIndex) {\n    const svgComp = select(this)\n    const numberMatrix = dataMatrix.map((row) =>\n      row.map((item) => (item ? +item.amount : 0))\n    )\n\n    const chordData = chord()\n      .sortGroups(descending)\n      .sortSubgroups(descending)\n      .sortChords(descending)(numberMatrix)\n\n    const ribbonLayout = ribbon().radius(r0)\n\n    svgComp\n      .selectAll(`path.${styles.chord}`)\n      .data(chordData)\n      .enter()\n      .append(\"svg:path\")\n      .attr(\"class\", styles.chord)\n      .style(\"fill\", (d) => fill(d.target.index))\n      .style(\"filter\", \"url(#drop-shadow-chords)\")\n      .style(\"stroke\", (d) => {\n        const originalColor = fill(d.target.index)\n        const newColor = rgb(originalColor).darker()\n\n        return newColor.formatHex()\n      })\n      .style(\"stroke-width\", 2)\n      .attr(\"d\", ribbonLayout as any)\n      .append(\"svg:title\")\n      .text((d) => {\n        const sourceData = fullList[d.source.index]\n        const targetData = fullList[d.target.index]\n\n        return `${sourceData.name} owes ${targetData.name} $${formatCurrency(\n          d.source.value\n        )}B.`\n      })\n\n    const g = svgComp\n      .selectAll(`g.${styles.group}`)\n      .data(chordData.groups)\n      .enter()\n      .append(\"svg:g\")\n      .attr(\"class\", styles.group)\n\n    g.append(\"svg:path\")\n      .style(\"fill\", (d) => fill(d.index))\n      .attr(\"id\", (d) => `group${d.index}-${chartIndex}`)\n      .attr(\"d\", arc as any)\n      .style(\"filter\", () => \"url(#drop-shadow-headings)\")\n      .append(\"svg:title\")\n      .text(\n        (d) =>\n          `${fullList[d.index].name} ${\n            chartIndex ? \"owes\" : \"is owed\"\n          } $${formatCurrency(d.value)}B.`\n      )\n\n    g.append(\"svg:text\")\n      .attr(\"x\", 6)\n      .attr(\"dy\", 15)\n      .filter((d) => d.value > 150)\n      .append(\"svg:textPath\")\n      .attr(\"xlink:href\", (d) => `#group${d.index}-${chartIndex}`)\n      .text((d) => fullList[d.index].name)\n      .attr(\"class\", styles.headingTitle)\n  })\n}\n\nconst main = async () => {\n  const data = await fetchData()\n\n  renderChart({\n    data,\n    rootElId: \"chart\",\n  })\n}\n\nexport default main\n","type":"ts"},"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main from \"@/demos/chord/chord\"\n\nconst Chord = ({ pageContext }: DemoPageProps) => (\n  <Demo main={main} pageContext={pageContext}>\n    <div id=\"chart\" />\n  </Demo>\n)\n\nexport default Chord\n","type":"tsx"},"styl":""},"key":"chord"},"meta":{"description":"Chord Chart example using D3.js, which has a different color scheme with a color for each country, and a special drop shadow filter for a 3D effect."}}},"staticQueryHashes":[]}