{"componentChunkName":"component---src-pages-d-3-js-multiline-voronoi-tsx","path":"/d3js/multiline-voronoi/","result":{"pageContext":{"demoInfo":{"data":["data.tsv"],"docs":[["d3-axis API reference","https://github.com/d3/d3-axis#api-reference"],["d3-axis Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-axis/index.d.ts"],["d3-shape API reference","https://github.com/d3/d3-shape#api-reference"],["d3-shape Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-shape/index.d.ts"],["d3-scale API reference","https://github.com/d3/d3-scale#api-reference"],["d3-scale Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-scale/index.d.ts"],["d3-selection API reference","https://github.com/d3/d3-selection#api-reference"],["d3-selection Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-selection/index.d.ts"],["d3-delaunay API reference","https://github.com/d3/d3-delaunay#api-reference"],["d3-delaunay Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-delaunay/index.d.ts"],["Delaunay Triangulation Wikipedia Article","https://en.wikipedia.org/wiki/Delaunay_triangulation"],["d3-scale-chromatic API reference","https://github.com/d3/d3-scale-chromatic#api-reference"],["d3-scale-chromatic Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-scale-chromatic/index.d.ts"],["d3-fetch API reference","https://github.com/d3/d3-fetch#api-reference"],["d3-fetch Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-fetch/index.d.ts"]],"isCompleted":true,"name":"Multi-Line Voronoi","notes":["Click one time to just show a line, click again to sho all","Added color and dropshadow for 3D effect","Added label data and clicked function"],"sources":["http://bl.ocks.org/mbostock/8033015"],"summary":[],"category":"d3js","files":{"demo":{"content":"import {\n  Selection,\n  axisBottom,\n  axisLeft,\n  extent,\n  line as lineD3,\n  max,\n  scaleLinear,\n  scaleOrdinal,\n  scaleTime,\n  schemePastel2,\n  select,\n  selectAll,\n  timeFormat,\n  timeParse,\n  tsv,\n} from \"d3\"\nimport { Delaunay } from \"d3-delaunay\"\n\nimport \"./multiline-voronoi.styl\"\n\ntype InitialDataItem = {\n  name: string\n  [monthKey: string]: string\n}\n\ntype City = {\n  name: string\n  metrics: CityMetric[]\n}\n\ntype CityMetric = {\n  cityName: string\n  date: Date\n  value: number\n}\n\nconst formatStr = \"%Y-%m\"\n\nconst texts = {\n  chartTitle: \"US Unemployment Rate\",\n  tooltipPart1: (cityMetric: CityMetric) => `${cityMetric.cityName.trim()}: `,\n  tooltipPart2: (cityMetric: CityMetric) => {\n    const date = `${\n      monthNames[cityMetric.date.getMonth()]\n    } of ${cityMetric.date.getFullYear()}`\n\n    return ` ${(cityMetric.value * 100).toFixed(2)}% - ${date}`\n  },\n}\n\nconst fetchData = async () => {\n  const monthFormat = timeFormat(formatStr)\n  const monthParse = timeParse(formatStr)\n\n  const dataItems = ((await tsv(\n    `${ROOT_PATH}data/d3js/multiline-voronoi/data.tsv`\n  )) as unknown) as InitialDataItem[]\n\n  const months: Date[] = Object.keys(dataItems[0])\n    .map((v) => monthParse(v)!)\n    .filter(Number)\n\n  const cities: City[] = dataItems.map((initialCity: InitialDataItem) => {\n    const name = initialCity.name\n      .replace(/(msa|necta div|met necta|met div)$/i, \"\")\n      .trim()\n\n    return {\n      metrics: months.map((date: Date) => {\n        const itemKey = monthFormat(date) as string\n        const itemValue = initialCity[itemKey as keyof InitialDataItem]\n        const value: number = Number(itemValue) / 100\n\n        return {\n          cityName: name,\n          date,\n          value,\n        }\n      }),\n      name,\n    }\n  })\n\n  return { cities, months }\n}\n\nconst monthNames = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\",\n]\n\nconst margin = {\n  bottom: 70,\n  left: 80,\n  right: 70,\n  top: 60,\n}\n\ntype RenderChart = (o: {\n  rootElId: string\n  cities: City[]\n  months: Date[]\n}) => {\n  setVoronoi: (v: boolean) => void\n}\n\nconst renderChart: RenderChart = ({ rootElId, cities, months }) => {\n  const color = scaleOrdinal(schemePastel2)\n\n  const state: {\n    clickToggle: boolean\n    voronoiGroup: null | Selection<SVGGElement, unknown, HTMLElement, unknown>\n  } = {\n    clickToggle: false,\n    voronoiGroup: null,\n  }\n\n  const rootEl = document.getElementById(rootElId) as HTMLElement\n\n  rootEl.classList.add(\"multiline-voronoi-chart\")\n\n  const width =\n    rootEl.getBoundingClientRect().width - margin.left - margin.right\n\n  const height = 500 - margin.top - margin.bottom\n\n  const xScale = scaleTime().range([0, width])\n  const yScale = scaleLinear().range([height, 0])\n\n  const lineXTransformer = (cityMetric: CityMetric) => xScale(cityMetric.date)\n  const lineYTransformer = (cityMetric: CityMetric) => yScale(cityMetric.value)\n\n  const cityNameToLine: { [cityName: string]: SVGPathElement } = {}\n\n  const svg = select(`#${rootElId}`)\n    .append(\"svg\")\n    .attr(\"width\", width + margin.left + margin.right)\n    .attr(\"height\", height + margin.top + margin.bottom)\n    .append(\"g\")\n    .attr(\"transform\", `translate(${margin.left},${margin.top})`)\n\n  xScale.domain(extent<Date>(months) as [Date, Date])\n  yScale\n    .domain([\n      0,\n      max(cities, (city: City) =>\n        max(city.metrics, (cityMetric: CityMetric) => cityMetric.value)\n      ) as number,\n    ])\n    .nice()\n\n  svg\n    .append(\"g\")\n    .attr(\"class\", \"axis axis--x\")\n    .attr(\"transform\", `translate(0,${height})`)\n    .call(axisBottom(xScale))\n\n  svg\n    .append(\"g\")\n    .attr(\"class\", \"axis axis--y\")\n    .call(axisLeft(yScale).ticks(10, \"%\"))\n    .append(\"text\")\n    .attr(\"x\", 20)\n    .attr(\"dy\", \".32em\")\n    .style(\"font-weight\", \"bold\")\n    .text(texts.chartTitle)\n\n  addFilter(svg)\n\n  const line = lineD3<CityMetric>().x(lineXTransformer).y(lineYTransformer)\n\n  const generateVoronoi = (usedCities: City[]) => {\n    const mouseover = (_e: unknown, cityMetric: CityMetric) => {\n      const linePath = cityNameToLine[cityMetric.cityName]\n\n      select(linePath).classed(\"city--hover\", true)\n      ;(linePath.parentNode as SVGGElement).appendChild(linePath)\n\n      focus.attr(\n        \"transform\",\n        `translate(${lineXTransformer(cityMetric)},${lineYTransformer(\n          cityMetric\n        )})`\n      )\n\n      focus.select(\".text1\").text(texts.tooltipPart1(cityMetric))\n      focus.select(\".text2\").text(texts.tooltipPart2(cityMetric))\n    }\n\n    const mouseout = (_e: unknown, d: CityMetric) => {\n      const linePath = cityNameToLine[d.cityName]\n\n      select(linePath).classed(\"city--hover\", false)\n\n      return focus.attr(\"transform\", \"translate(-100,-100)\")\n    }\n\n    const clicked = (_e: unknown, d: CityMetric) => {\n      state.clickToggle = !state.clickToggle\n\n      selectAll(\".cities\").remove()\n      selectAll(\".voronoi\").remove()\n      selectAll(\".focus\").remove()\n\n      const inputData: City[] = (() => {\n        if (state.clickToggle) {\n          const city = cities.find((c) => c.name === d.cityName) as City\n\n          return [city]\n        }\n\n        return cities\n      })()\n\n      generateLines(inputData)\n    }\n\n    const focus = svg\n      .append(\"g\")\n      .attr(\"transform\", \"translate(-100,-100)\")\n      .attr(\"class\", \"focus\")\n\n    focus.append(\"circle\").attr(\"r\", 3.5)\n    focus.append(\"text\").attr(\"class\", \"text1\").attr(\"y\", -30)\n    focus.append(\"text\").attr(\"class\", \"text2\").attr(\"y\", -10)\n\n    const flatCityMetrics = usedCities.reduce((acc, city) => {\n      city.metrics.forEach((cityMetric) => {\n        acc.push(cityMetric)\n      })\n\n      return acc\n    }, [] as CityMetric[])\n\n    const voronoi = Delaunay.from(\n      flatCityMetrics,\n      lineXTransformer,\n      lineYTransformer\n    ).voronoi([\n      -margin.left,\n      -margin.top,\n      width + margin.right,\n      height + margin.bottom,\n    ])\n\n    state.voronoiGroup = svg.append(\"g\").attr(\"class\", \"voronoi\")\n\n    state.voronoiGroup\n      .selectAll(\"path\")\n      .data(flatCityMetrics)\n      .enter()\n      .append(\"path\")\n      .attr(\"d\", (_cityMetric: CityMetric, index) => voronoi.renderCell(index))\n      .on(\"mouseover\", mouseover)\n      .on(\"mouseout\", mouseout)\n      .on(\"click\", clicked)\n  }\n\n  const generateLines = (usedCities: City[]) => {\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"cities\")\n      .selectAll(\"path\")\n      .data(usedCities)\n      .enter()\n      .append(\"path\")\n      .attr(\"d\", function (city: City) {\n        cityNameToLine[city.name] = this\n\n        return line(city.metrics)\n      })\n      .style(\"stroke\", (_city, index) => color(index.toString()))\n      .style(\"filter\", () => \"url(#drop-shadow)\")\n\n    generateVoronoi(usedCities)\n  }\n\n  generateLines(cities)\n\n  return {\n    setVoronoi: (checked: boolean) => {\n      state.voronoiGroup!.classed(\"voronoi--show\", checked)\n    },\n  }\n}\n\nconst addFilter = (\n  svg: Selection<SVGGElement, unknown, HTMLElement, unknown>\n) => {\n  const defs = svg.append(\"defs\")\n  const filter = defs.append(\"filter\").attr(\"id\", \"drop-shadow\")\n\n  filter\n    .append(\"feGaussianBlur\")\n    .attr(\"in\", \"SourceAlpha\")\n    .attr(\"stdDeviation\", 1)\n\n  filter.append(\"feOffset\").attr(\"dx\", 1).attr(\"dy\", 1)\n  filter\n    .append(\"feComponentTransfer\")\n    .append(\"feFuncA\")\n    .attr(\"slope\", \"1\")\n    .attr(\"type\", \"linear\")\n\n  const feMerge = filter.append(\"feMerge\")\n\n  feMerge.append(\"feMergeNode\")\n  feMerge.append(\"feMergeNode\").attr(\"in\", \"SourceGraphic\")\n}\n\nconst main = async () => {\n  const rootElId = \"chart\"\n\n  const { cities, months } = await fetchData()\n\n  const { setVoronoi } = renderChart({\n    cities,\n    months,\n    rootElId,\n  })\n\n  select(\"#show-voronoi\")\n    .property(\"disabled\", false)\n    .on(\"change\", (e: MouseEvent) => {\n      setVoronoi((e.target as HTMLInputElement).checked || false)\n    })\n}\n\nexport default main\n","type":"ts"},"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main from \"@/demos/multiline-voronoi/multiline-voronoi\"\n\nconst MultilineVoronoi = ({ pageContext }: DemoPageProps) => (\n  <Demo main={main} pageContext={pageContext}>\n    <form>\n      <input id=\"show-voronoi\" type=\"checkbox\" />{\" \"}\n      <label htmlFor=\"show-voronoi\">Show Voronoi lines</label>\n    </form>\n    <div id=\"chart\" />\n  </Demo>\n)\n\nexport default MultilineVoronoi\n","type":"tsx"},"styl":".multiline-voronoi-chart\n  .axis path,\n  .axis line\n    fill: none;\n    shape-rendering: crispEdges;\n    stroke: #000;\n\n  .cities\n    fill: none;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n    stroke-width: 1.5px;\n    stroke: #aaa;\n\n  .city--hover\n    stroke: #000;\n\n  .focus text\n    text-anchor: middle;\n    text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;\n\n  .voronoi path\n    fill: none;\n    pointer-events: all;\n\n  .voronoi--show path\n    stroke-opacity: .2;\n    stroke: red;\n\n  #form\n    position: absolute;\n    right: 30px;\n    top: 20px;\n"},"key":"multiline-voronoi"},"meta":{"description":"Multiline chart example using D3.js, with Voronoi functionality and the ability to show a single line after it is clicked. The label and style are also changed."}}},"staticQueryHashes":[]}