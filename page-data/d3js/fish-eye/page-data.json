{
    "componentChunkName": "component---src-pages-d-3-js-fish-eye-tsx",
    "path": "/d3js/fish-eye/",
    "result": {"pageContext":{"demoInfo":{"dataFiles":["data.json"],"docs":[],"isCompleted":true,"name":"Fish Eye","notes":[],"sources":["http://bost.ocks.org/mike/fisheye/"],"summary":[],"category":"d3js","files":{"demoCSS":[{"content":".fishEyeChart {\n  text {\n    font: 10px sans-serif;\n    text-shadow: 1px 1px 1px #ccc;\n  }\n\n  .axis path,\n  .axis line {\n    fill: none;\n    shape-rendering: crispEdges;\n    stroke: #eee;\n  }\n\n  .background {\n    fill: none;\n    pointer-events: all;\n  }\n\n  .chartTitle {\n    font-size: 14px;\n  }\n\n  .pointer {\n    fill: #7aae61;\n    font-size: 15px;\n    opacity: 0%;\n  }\n}\n","filePath":"src/demos/fish-eye/fish-eye.module.css"}],"demoTS":[{"content":"import { extent, scalePow } from \"d3\"\n\nimport { FishEyeChart } from \"./fish-eye-chart\"\nimport {\n  CONTAINER_ID,\n  RANDOM_UPDATE_ID,\n  fetchData,\n  getChartConfig,\n} from \"./fish-eye-config\"\n\nconst main = async () => {\n  const incomeMetrics = await fetchData()\n  const chartConfig = getChartConfig(incomeMetrics)\n\n  const chart = new FishEyeChart(chartConfig)\n\n  document.getElementById(RANDOM_UPDATE_ID)?.addEventListener(\"click\", () => {\n    const getCommonExtent = (\n      property: \"income\" | \"lifeExpectancy\" | \"population\"\n    ) =>\n      extent(chartConfig.chartItems, (chartItem) => chartItem[property]) as [\n        number,\n        number\n      ]\n\n    const populationExtent = getCommonExtent(\"population\")\n    const incomeExtent = getCommonExtent(\"income\")\n    const lifeExpectancyExtent = getCommonExtent(\"lifeExpectancy\")\n\n    const populationScale = scalePow().exponent(20).range(populationExtent)\n    const incomeScale = scalePow().exponent(5).range(incomeExtent)\n    const lifeExpectancyScale = scalePow()\n      .exponent(2)\n      .range(lifeExpectancyExtent)\n\n    chartConfig.chartItems.forEach((incomeMetric) => {\n      if (Math.random() < 0.1) {\n        incomeMetric.population = populationScale(Math.random())\n        incomeMetric.income = incomeScale(Math.random())\n        incomeMetric.lifeExpectancy = lifeExpectancyScale(Math.random())\n      }\n    })\n\n    chart.refresh()\n  })\n}\n\nexport { CONTAINER_ID, RANDOM_UPDATE_ID }\n\nexport default main\n","filePath":"src/demos/fish-eye/fish-eye.ts"},{"content":"import {\n  Axis,\n  AxisScale,\n  ScaleOrdinal,\n  ScalePower,\n  Selection,\n  axisBottom,\n  axisLeft,\n  format,\n  pointer as pointerD3,\n  scaleLinear,\n  scaleLog,\n  scaleOrdinal,\n  scaleSqrt,\n  schemePastel2,\n  select,\n} from \"d3\"\n\nimport d3Fisheye, { FishEyeScale } from \"@/demos/_utils/fish-eye\"\n\nimport * as styles from \"./fish-eye.module.css\"\n\nconst margin = {\n  bottom: 70,\n  left: 70,\n  right: 50,\n  top: 80,\n}\nconst LEFT_OFFSET_SMALL_DEVICE = 20\nconst height = 700 - margin.top - margin.bottom\n\ntype FishEyeChartOpts<ChartData> = Readonly<{\n  chartItems: ChartData[]\n  colorDomain: string[]\n  getCircleTitle: (chartItem: ChartData) => string\n  getColorValue: (chartItem: ChartData) => string\n  getRadiusValue: (chartItem: ChartData) => number\n  getXValue: (chartItem: ChartData) => number\n  getYValue: (chartItem: ChartData) => number\n  rootElId: string\n  titles: {\n    long: string\n    short: string\n  }\n  xAxisLabel: string\n  yAxisLabel: string\n}>\n\nclass FishEyeChart<ChartData> {\n  private readonly config: FishEyeChartOpts<ChartData>\n\n  private width = 0\n\n  private dom!: {\n    dot?: Selection<SVGCircleElement, ChartData, SVGGElement, unknown>\n    pointer?: Selection<SVGTextElement, unknown, HTMLElement, unknown>\n    svg: Selection<SVGSVGElement, unknown, HTMLElement, unknown>\n    svgG: Selection<SVGGElement, unknown, HTMLElement, unknown>\n    xAxis?: Axis<number>\n    yAxis?: Axis<number>\n  }\n\n  private vars!: {\n    colorScale: ScaleOrdinal<string, string>\n    focused: boolean\n    radiusScale: ScalePower<number, number>\n    xScale: FishEyeScale\n    yScale: FishEyeScale\n  }\n\n  public constructor(chartConfig: FishEyeChartOpts<ChartData>) {\n    this.config = chartConfig\n\n    this.setupRootEl()\n    this.setVars()\n    this.setDom()\n\n    this.setChartTitle()\n    this.setBackground()\n    this.setPointer()\n    this.setAxis()\n    this.setLabels()\n    this.setDots()\n    this.setTitles()\n    this.updateDimensions()\n    this.bindMousemove()\n    this.bindMouseLeave()\n    this.bindClick()\n    this.bindResize()\n\n    this.setZoom({\n      animationDuration: 0,\n      distortion: 0,\n      focus: [0, 0],\n    })\n  }\n\n  private static isTouchDevice() {\n    return (\n      \"ontouchstart\" in window ||\n      navigator.maxTouchPoints > 0 ||\n      (navigator as any).msMaxTouchPoints > 0 // eslint-disable-line @typescript-eslint/no-explicit-any\n    )\n  }\n\n  public refresh() {\n    this.updateDimensions(1000)\n  }\n\n  private setupRootEl() {\n    const rootEl = document.getElementById(this.config.rootElId) as HTMLElement\n\n    rootEl.classList.add(styles.fishEyeChart)\n\n    this.width =\n      rootEl.getBoundingClientRect().width - margin.left - margin.right\n  }\n\n  private isSmallDevice() {\n    return this.width < 500\n  }\n\n  private setDom() {\n    const svg = select(`#${this.config.rootElId}`).append(\"svg\")\n    const svgG = svg.append(\"g\")\n\n    this.dom = {\n      svg,\n      svgG,\n    }\n  }\n\n  private setChartTitle() {\n    this.dom.svgG\n      .append(\"text\")\n      .attr(\"class\", styles.chartTitle)\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-weight\", \"bold\")\n  }\n\n  private setVars() {\n    const colorScale = scaleOrdinal<string>()\n      .domain(this.config.colorDomain)\n      .range(schemePastel2)\n\n    const radiusScale = scaleSqrt().domain([0, 5e8]).range([5, 60])\n    const xScale = d3Fisheye\n      .scale(scaleLog)\n      .domain([200, 1e5])\n      .range([0, this.width]) as FishEyeScale\n    const yScale = d3Fisheye\n      .scale(scaleLinear)\n      .domain([20, 90])\n      .range([height, 0]) as FishEyeScale\n\n    this.vars = {\n      colorScale,\n      focused: false,\n      radiusScale,\n      xScale,\n      yScale,\n    }\n  }\n\n  private setAxis() {\n    const formatFn = format(\",d\")\n\n    this.dom.xAxis = axisBottom(this.vars.xScale as AxisScale<number>)\n      .tickFormat((tickNumber) => {\n        if (tickNumber < 1000) {\n          return formatFn(tickNumber)\n        }\n\n        const reducedNum = Math.round(tickNumber / 1000)\n\n        return `${formatFn(reducedNum)}k`\n      })\n      .tickSize(-height)\n    this.dom.yAxis = axisLeft(this.vars.yScale as AxisScale<number>).tickSize(\n      -this.width\n    )\n    this.dom.svgG\n      .append(\"g\")\n      .attr(\"class\", `x ${styles.axis}`)\n      .attr(\"transform\", `translate(0,${height})`)\n      .call(this.dom.xAxis)\n    this.dom.svgG\n      .append(\"g\")\n      .attr(\"class\", `y ${styles.axis}`)\n      .call(this.dom.yAxis)\n  }\n\n  private setBackground() {\n    return this.dom.svgG.append(\"rect\").attr(\"class\", styles.background)\n  }\n\n  private setLabels() {\n    this.dom.svgG\n      .append(\"text\")\n      .attr(\"class\", \"x label\")\n      .attr(\"text-anchor\", \"middle\")\n      .text(this.config.xAxisLabel)\n\n    this.dom.svgG\n      .append(\"text\")\n      .attr(\"class\", \"y label\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"x\", -height / 2)\n      .attr(\"y\", -40)\n      .attr(\"dy\", \".75em\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .text(this.config.yAxisLabel)\n  }\n\n  private position(animationDuration: number) {\n    this.dom.svgG.attr(\n      \"transform\",\n      `translate(${\n        margin.left - (this.isSmallDevice() ? LEFT_OFFSET_SMALL_DEVICE : 0)\n      },${margin.top})`\n    )\n    this.dom\n      // Sort the circles by radius, so the largest circles appear below\n      .dot!.sort(\n        (...[chartItemA, chartItemB]) =>\n          this.config.getRadiusValue(chartItemB) -\n          this.config.getRadiusValue(chartItemA)\n      )\n      .transition()\n      .duration(animationDuration)\n      .attr(\"cx\", (chartItem) => {\n        const xValue = this.config.getXValue(chartItem)\n\n        return this.vars.xScale(xValue) as number\n      })\n      .attr(\"cy\", (chartItem) => {\n        const yValue = this.config.getYValue(chartItem)\n\n        return this.vars.yScale(yValue) as number\n      })\n      .attr(\"r\", (chartItem) => {\n        const radiusValue = this.config.getRadiusValue(chartItem)\n\n        return (\n          this.vars.radiusScale(radiusValue) / (this.isSmallDevice() ? 2 : 1)\n        )\n      })\n    this.dom.xAxis!.ticks(this.isSmallDevice() ? 2 : undefined)\n    this.dom.svgG\n      .select<SVGGElement>(`.x.${styles.axis}`)\n      .transition()\n      .duration(animationDuration)\n      .call(this.dom.xAxis!)\n    this.dom.svgG\n      .select<SVGGElement>(`.y.${styles.axis}`)\n      .transition()\n      .duration(animationDuration)\n      .call(this.dom.yAxis!)\n  }\n\n  private setDots() {\n    this.dom.dot = this.dom.svgG\n      .append(\"g\")\n      .attr(\"class\", \"dots\")\n      .selectAll(\".dot\")\n      .data<ChartData>(this.config.chartItems)\n      .enter()\n      .append(\"circle\")\n      .attr(\"class\", \"dot\")\n      .style(\"fill\", (chartItem) => {\n        const colorValue = this.config.getColorValue(chartItem)\n\n        return this.vars.colorScale(colorValue)\n      })\n      .style(\"stroke\", \"black\")\n      .style('\"stroke-width\"', \"1px\")\n\n    this.position(0)\n  }\n\n  private setTitles() {\n    this.dom.dot!.append(\"title\").attr(\"class\", \"dot-title\")\n    this.updateTitles()\n  }\n\n  private setZoom({\n    animationDuration,\n    distortion,\n    focus,\n  }: {\n    animationDuration: number\n    distortion: number\n    focus: [number, number]\n  }) {\n    this.vars.xScale.distortion(distortion).focus(focus[0])\n    this.vars.yScale.distortion(distortion).focus(focus[1])\n    this.position(animationDuration)\n  }\n\n  private updateTitles() {\n    this.dom\n      .dot!.selectAll<SVGTitleElement, ChartData>(\".dot-title\")\n      .text((chartItem) => this.config.getCircleTitle(chartItem))\n\n    this.dom.svgG\n      .select<SVGTitleElement>(`.${styles.chartTitle}`)\n      .text(\n        this.isSmallDevice()\n          ? this.config.titles.short\n          : this.config.titles.long\n      )\n  }\n\n  private zoom({\n    animationDuration,\n    interactionEvent,\n  }: {\n    animationDuration: number\n    interactionEvent: Event\n  }) {\n    const focus = pointerD3(interactionEvent)\n\n    this.setZoom({\n      animationDuration,\n      distortion: 2.5,\n      focus,\n    })\n  }\n\n  private setPointer() {\n    this.dom.pointer = this.dom.svgG\n      .append(\"text\")\n      .text(\"+\")\n      .attr(\"class\", styles.pointer)\n  }\n\n  private bindMousemove() {\n    return this.dom.svgG.on(\"mousemove\", (interactionEvent) => {\n      if (FishEyeChart.isTouchDevice()) {\n        return\n      }\n\n      if (!this.vars.focused) {\n        this.zoom({\n          animationDuration: 0,\n          interactionEvent,\n        })\n      }\n    })\n  }\n\n  private bindMouseLeave() {\n    return this.dom.svgG.on(\"mouseleave\", () => {\n      if (!this.vars.focused) {\n        this.setZoom({\n          animationDuration: 1000,\n          distortion: 0,\n          focus: [0, 0],\n        })\n      }\n    })\n  }\n\n  private bindClick() {\n    this.dom.svgG.on(\"click\", (interactionEvent: Event) => {\n      const isTouchDevice = FishEyeChart.isTouchDevice()\n\n      if (!isTouchDevice) {\n        this.vars.focused = !this.vars.focused\n\n        if (this.vars.focused) {\n          const pointer = pointerD3(this)\n\n          this.dom\n            .pointer!.attr(\"x\", pointer[0])\n            .attr(\"y\", pointer[1])\n            .style(\"opacity\", 1)\n\n          return\n        }\n      }\n\n      this.dom.pointer!.style(\"opacity\", 0)\n\n      this.zoom({\n        animationDuration: isTouchDevice ? 1000 : 0,\n        interactionEvent,\n      })\n    })\n  }\n\n  private updateDimensions(animationDuration = 0) {\n    this.setupRootEl()\n\n    const isSmallDevice = this.isSmallDevice()\n    const widthOffset = isSmallDevice ? LEFT_OFFSET_SMALL_DEVICE : 0\n    const totalWidth = this.width + widthOffset\n\n    this.dom.svg\n      .attr(\"width\", this.width + margin.left + margin.right)\n      .attr(\"height\", height + margin.top + margin.bottom)\n    this.dom.svgG\n      .select(`.${styles.chartTitle}`)\n      .attr(\"transform\", `translate(${totalWidth / 2},-40)`)\n\n    this.dom.svgG\n      .select(`.${styles.background}`)\n      .attr(\"width\", this.width)\n      .attr(\"height\", height)\n\n    this.dom.svgG\n      .select(\".x.label\")\n      .attr(\"y\", height + 26)\n      .attr(\"x\", this.width / 2)\n\n    this.vars.xScale.range([0, totalWidth])\n    this.updateTitles()\n    this.position(animationDuration)\n  }\n\n  private bindResize() {\n    window.addEventListener(\"resize\", () => {\n      this.updateDimensions()\n    })\n  }\n}\n\nexport { FishEyeChart, FishEyeChartOpts }\n","filePath":"src/demos/fish-eye/fish-eye-chart.ts"},{"content":"import { json } from \"d3\"\n\nimport { FishEyeChartOpts } from \"./fish-eye-chart\"\n\nconst CONTAINER_ID = \"chart\"\nconst RANDOM_UPDATE_ID = \"random-update\"\n\ntype IncomeMetric = {\n  income: number\n  lifeExpectancy: number\n  name: string\n  population: number\n  region: string\n}\n\nconst fetchData = async () =>\n  json(`${ROOT_PATH}data/d3js/fish-eye/data.json`) as Promise<IncomeMetric[]>\n\ntype Opts = FishEyeChartOpts<IncomeMetric>\n\nconst getXValue: Opts[\"getXValue\"] = (incomeMetric) => incomeMetric.income\nconst getYValue: Opts[\"getYValue\"] = (incomeMetric) =>\n  incomeMetric.lifeExpectancy\nconst getRadiusValue: Opts[\"getRadiusValue\"] = (incomeMetric) =>\n  incomeMetric.population\nconst getColorValue: Opts[\"getColorValue\"] = (incomeMetric) =>\n  incomeMetric.region\n\nconst humanizeNumber = (initialN: number): string => {\n  let numStr = initialN.toFixed(0)\n\n  while (true) {\n    const numStrFormatted = numStr.replace(/(\\d)(\\d{3})($|,|\\.)/g, \"$1,$2$3\")\n\n    if (numStrFormatted === numStr) {\n      break\n    }\n\n    numStr = numStrFormatted\n  }\n\n  return numStr\n}\n\nconst getCircleTitle: Opts[\"getCircleTitle\"] = (incomeMetric) =>\n  `${incomeMetric.name}:\\n- Income: ${humanizeNumber(\n    incomeMetric.income\n  )} $/P.C.\\n` +\n  `- Population: ${humanizeNumber(incomeMetric.population)}\\n` +\n  `- Life expectancy: ${incomeMetric.lifeExpectancy} years`\n\nconst regions = [\n  \"Sub-Saharan Africa\",\n  \"South Asia\",\n  \"Middle East & North Africa\",\n  \"America\",\n  \"Europe & Central Asia\",\n  \"East Asia & Pacific\",\n]\n\nconst longTitle =\n  \"Income Per Capita vs \" +\n  \"Life Expectancy vs Population vs Region - 180 Countries\"\nconst shortTitle = \"Income Per Capita vs Life Expectancy\"\n\nconst xAxisLabel = \"income per capita, inflation-adjusted (dollars)\"\nconst yAxisLabel = \"life expectancy (years)\"\n\nconst getChartConfig = (incomeMetrics: IncomeMetric[]): Opts => ({\n  chartItems: incomeMetrics,\n  colorDomain: regions,\n  getCircleTitle,\n  getColorValue,\n  getRadiusValue,\n  getXValue,\n  getYValue,\n  rootElId: CONTAINER_ID,\n  titles: {\n    long: longTitle,\n    short: shortTitle,\n  },\n  xAxisLabel,\n  yAxisLabel,\n})\n\nexport { CONTAINER_ID, RANDOM_UPDATE_ID, fetchData, getChartConfig }\n","filePath":"src/demos/fish-eye/fish-eye-config.ts"}],"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main, { CONTAINER_ID, RANDOM_UPDATE_ID } from \"@/demos/fish-eye/fish-eye\"\n\nconst FishEye = ({ pageContext }: DemoPageProps) => (\n  <Demo main={main} pageContext={pageContext}>\n    <div style={{ marginBottom: 20, textAlign: \"center\" }}>\n      <button className=\"btn btn-primary\" id={RANDOM_UPDATE_ID}>\n        Update random values\n      </button>\n    </div>\n    <div id={CONTAINER_ID} />\n  </Demo>\n)\n\nexport default FishEye\n","type":"tsx"}},"key":"fish-eye"},"meta":{"description":"Fisheye Chart example using D3.js, with the Fisheye plugin. It has a more depurated style, and the ability to stop the scale changes when it's clicked."}}},
    "staticQueryHashes": []}