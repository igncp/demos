{"componentChunkName":"component---src-pages-d-3-js-timeline-tsx","path":"/d3js/timeline/","result":{"pageContext":{"demoInfo":{"data":["data.csv"],"docs":[],"name":"Timeline","notes":["Change to bootstrap tooltip","Add dynamic text lengths (adding two dots)","Improve performance (a lot) removing the drop-shadow while brushing"],"sources":["http://bl.ocks.org/rengel-de/5603464"],"summary":[],"category":"d3js","files":{"d3utils":"import * as d3 from \"d3\"\nimport merge from \"lodash/merge\"\n\ntype Margin = {\n  bottom: number\n  left: number\n  right: number\n  top: number\n}\n\ntype SVG = d3.Selection<SVGGElement, unknown, HTMLElement, unknown>\n\n// @TODO: remove when no longer used\n\nconst d3utils = {\n  colorsScale<P extends number = any>(colors: any, extent: any) {\n    const c = d3.scaleLinear().domain(extent).range([0, 1])\n    const colorScale = d3\n      .scaleLinear()\n      .domain(d3.range(0, 1, 1.0 / colors.length))\n      .range(colors)\n\n    return function (p: P) {\n      return colorScale(c(p))\n    }\n  },\n  filterBlackOpacity(id: string, svg: SVG, deviation: number, slope: number) {\n    const defs = svg.append(\"defs\")\n    const filter = defs\n      .append(\"filter\")\n      .attr(\"height\", \"500%\")\n      .attr(\"id\", `drop-shadow-${id}`)\n      .attr(\"width\", \"500%\")\n      .attr(\"x\", \"-200%\")\n      .attr(\"y\", \"-200%\")\n\n    filter\n      .append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", deviation)\n\n    filter.append(\"feOffset\").attr(\"dx\", 1).attr(\"dy\", 1)\n    filter\n      .append(\"feComponentTransfer\")\n      .append(\"feFuncA\")\n      .attr(\"slope\", slope)\n      .attr(\"type\", \"linear\")\n\n    const feMerge = filter.append(\"feMerge\")\n\n    feMerge.append(\"feMergeNode\")\n\n    return feMerge.append(\"feMergeNode\").attr(\"in\", \"SourceGraphic\")\n  },\n  filterColor(\n    id: string,\n    svg: SVG,\n    deviation: number,\n    slope: number,\n    extra?: any\n  ) {\n    if (extra == null) {\n      extra = false\n    }\n\n    const defs = svg.append(\"defs\")\n    const filter = defs.append(\"filter\").attr(\"id\", `drop-shadow-${id}`)\n\n    if (extra) {\n      filter\n        .attr(\"height\", \"500%\")\n        .attr(\"width\", \"500%\")\n        .attr(\"x\", \"-200%\")\n        .attr(\"y\", \"-200%\")\n    }\n\n    filter\n      .append(\"feOffset\")\n      .attr(\"dx\", 0.5)\n      .attr(\"dy\", 0.5)\n      .attr(\"in\", \"SourceGraphic\")\n      .attr(\"result\", \"offOut\")\n\n    filter\n      .append(\"feGaussianBlur\")\n      .attr(\"in\", \"offOut\")\n      .attr(\"result\", \"blurOut\")\n      .attr(\"stdDeviation\", deviation)\n\n    filter\n      .append(\"feBlend\")\n      .attr(\"in\", \"SourceGraphic\")\n      .attr(\"in2\", \"blurOut\")\n      .attr(\"mode\", \"normal\")\n\n    return filter\n      .append(\"feComponentTransfer\")\n      .append(\"feFuncA\")\n      .attr(\"slope\", slope)\n      .attr(\"type\", \"linear\")\n  },\n\n  middleTitle(svg: SVG, width: number, text: string, top: number | null) {\n    if (top == null) {\n      top = -15\n    }\n\n    svg\n      .append(\"text\")\n      .attr(\"class\", \"chart-title\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"transform\", `translate(${String(width / 2)},${top})`)\n      .text(text)\n      .style(\"font-weight\", \"bold\")\n  },\n  svg(selector: string, width: number, height: number, margin: Margin) {\n    return d3\n      .select(selector)\n      .text(\"\")\n      .append(\"svg\")\n      .attr(\"height\", height + margin.top + margin.bottom)\n      .attr(\"width\", width + margin.left + margin.right)\n      .append(\"g\")\n      .attr(\"transform\", `translate(${margin.left},${margin.top})`)\n  },\n  tooltip(selector: string, customOpts: any) {\n    if (customOpts == null) {\n      customOpts = {}\n    }\n\n    const defaultOpts = {\n      elementSelector: \"\",\n      followElement: false,\n      followMouse: false,\n      leftOffst: 60,\n      tOpts: {\n        container: \"body\",\n        viewport: {\n          selector: \"#chart svg\",\n        },\n      },\n      topOffst: 40,\n    }\n\n    const opts = merge(defaultOpts, customOpts)\n\n    const sel: any = $(selector)\n\n    sel.tooltip(opts.tOpts)\n\n    if (opts.followMouse) {\n      $(selector).hover((e) =>\n        $(\".tooltip\").css({\n          left: `${String(e.pageX - opts.leftOffst)}px`,\n          top: `${String(e.pageY - opts.topOffst)}px`,\n        })\n      )\n    } else if (opts.followElement) {\n      $(selector).hover(() =>\n        $(\".tooltip\").css({\n          left: `${String(\n            $(opts.elementSelector).position().left - opts.leftOffst\n          )}px`,\n          top: `${String(\n            $(opts.elementSelector).position().top - opts.topOffst\n          )}px`,\n        })\n      )\n    }\n  },\n}\n\nexport default d3utils\n","demo":{"content":"import * as d3 from \"d3\"\n\nimport d3utils from \"@/demos/_utils/d3utils\"\n\nimport \"./timeline.styl\"\n\ntype DataItem = {\n  end: Date\n  instant: boolean\n  label: string\n  start: Date\n  track: number\n}\n\nconst fetchData = () =>\n  (d3.csv(`${ROOT_PATH}data/d3js/timeline/data.csv`) as unknown) as DataItem[]\n\nconst margin = {\n  bottom: 0,\n  left: 20,\n  right: 20,\n  top: 60,\n}\n\nconst outerHeight = 700\nconst height = outerHeight - margin.top - margin.bottom\nconst bandGap = 25\n\nconst parseDate = function (dateString: string) {\n  const format = d3.timeParse(\"%Y-%m-%d\")\n\n  let date = format(dateString)\n\n  if (date !== null) {\n    return date\n  }\n\n  const year = isNaN(Number(dateString))\n    ? -dateString.replace(/[^0-9]/g, \"\")\n    : +dateString\n\n  if (year < 0 || year > 99) {\n    date = new Date(year, 6, 1)\n  } else if (year === 0) {\n    date = new Date(-1, 6, 1)\n  } else {\n    date = new Date(year, 6, 1)\n    date.setUTCFullYear(year)\n  }\n\n  return date\n}\n\nconst toYear = (date: Date) => {\n  const bcString = \" BC\"\n  const year = date.getUTCFullYear()\n\n  if (year >= 0) {\n    return year.toString()\n  }\n\n  return bcString + Math.abs(year)\n}\n\nclass Timeline {\n  private chart: any\n  private bandY: number\n  private bandNum: number\n  private dataContent: any\n  private components: any\n  private bands: any\n  private width: number\n\n  public constructor({ rootElId }: { rootElId: string }) {\n    const rootEl = document.getElementById(rootElId) as HTMLElement\n\n    rootEl.classList.add(\"timeline-chart\")\n\n    const outerWidth = rootEl.getBoundingClientRect().width\n\n    this.width = outerWidth - margin.left - margin.right\n\n    this.bandY = 0\n    this.bandNum = 0\n\n    this.dataContent = {}\n    this.components = []\n    this.bands = {}\n\n    const svg = d3utils.svg(`#${rootElId}`, outerWidth, outerHeight, margin)\n\n    d3utils.middleTitle(svg, outerWidth, \"Philosophers through History\", -20)\n    d3utils.filterBlackOpacity(\"intervals\", svg, 1, 0.2)\n\n    svg\n      .append(\"clipPath\")\n      .attr(\"id\", \"chart-area\")\n      .append(\"rect\")\n      .attr(\"width\", this.width)\n      .attr(\"height\", height)\n\n    svg.on(\"mouseup\", () =>\n      d3\n        .selectAll(\".interval rect\")\n        .style(\"filter\", \"url(#drop-shadow-intervals)\")\n    )\n\n    this.chart = svg\n      .append(\"g\")\n      .attr(\"class\", \"chart\")\n      .attr(\"clip-path\", \"url(#chart-area)\")\n  }\n\n  public data(timelineItems: DataItem[]) {\n    const today = new Date()\n\n    const tracks: any = []\n    const yearMillis = 31622400000\n    const instantOffset = 100 * yearMillis\n\n    this.dataContent.items = timelineItems\n\n    const compareAscending = function (item1: any, item2: any) {\n      let result = item1.start - item2.start\n\n      if (result < 0) {\n        return -1\n      }\n\n      if (result > 0) {\n        return 1\n      }\n\n      result = item2.end - item1.end\n\n      if (result < 0) {\n        return -1\n      }\n\n      if (result > 0) {\n        return 1\n      }\n\n      return 0\n    }\n\n    const compareDescending = function (item1: any, item2: any) {\n      let result = item1.start - item2.start\n\n      if (result < 0) {\n        return 1\n      }\n\n      if (result > 0) {\n        return -1\n      }\n\n      result = item2.end - item1.end\n\n      if (result < 0) {\n        return 1\n      }\n\n      if (result > 0) {\n        return -1\n      }\n\n      return 0\n    }\n\n    const calculateTracks = (items: any, sortOrder: any, timeOrder: any) => {\n      sortOrder = sortOrder || \"descending\"\n      timeOrder = timeOrder || \"backward\"\n\n      const sortBackward = () =>\n        items.forEach((item: any) => {\n          let track = 0\n\n          for (\n            let i = 0, _i = 0, _ref = tracks.length;\n            0 <= _ref ? _i < _ref : _i > _ref;\n            i = 0 <= _ref ? ++_i : --_i\n          ) {\n            if (item.end < tracks[i]) {\n              break\n            }\n\n            track++\n          }\n\n          item.track = track\n\n          tracks[track] = item.start\n        })\n\n      const sortForward = function () {\n        return items.forEach((item: any) => {\n          let track = 0\n\n          for (\n            let i = 0, _i = 0, _ref = tracks.length;\n            0 <= _ref ? _i < _ref : _i > _ref;\n            i = 0 <= _ref ? ++_i : --_i\n          ) {\n            if (item.start > tracks[i]) {\n              break\n            }\n\n            track++\n          }\n\n          item.track = track\n\n          tracks[track] = item.end\n        })\n      }\n\n      if (sortOrder === \"ascending\") {\n        this.dataContent.items.sort(compareAscending)\n      } else {\n        this.dataContent.items.sort(compareDescending)\n      }\n\n      if (timeOrder === \"forward\") {\n        return sortForward()\n      }\n\n      return sortBackward()\n    }\n\n    this.dataContent.items.forEach((item: any) => {\n      item.start = parseDate(item.start)\n\n      if (item.end === \"\") {\n        item.end = new Date(item.start.getTime() + instantOffset)\n        item.instant = true\n      } else {\n        item.end = parseDate(item.end)\n        item.instant = false\n      }\n\n      if (item.end > today) {\n        item.end = today\n      }\n    })\n\n    calculateTracks(this.dataContent.items, \"descending\", \"backward\")\n\n    this.dataContent.nTracks = tracks.length\n    this.dataContent.minDate = d3.min(\n      this.dataContent.items,\n      (d: any) => d.start\n    )\n    this.dataContent.maxDate = d3.max(this.dataContent.items, (d: any) => d.end)\n\n    return this\n  }\n\n  public xAxis(bandName: any) {\n    const band = this.bands[bandName]\n\n    const axis = (d3 as any)\n      .axisBottom(band.xScale)\n      .tickSize(6, 0)\n      .tickFormat((d: any) => toYear(d))\n\n    const xAxis: any = this.chart\n      .append(\"g\")\n      .attr(\"class\", \"axis\")\n      .attr(\"transform\", `translate(0,${band.y + band.h})`)\n\n    xAxis.redraw = function () {\n      return xAxis.call(axis)\n    }\n\n    band.parts.push(xAxis)\n    this.components.push(xAxis)\n\n    return this\n  }\n\n  public createTooltip() {\n    d3utils.tooltip(\".part.instant, .part.interval\", {\n      followMouse: true,\n      leftOffst: 80,\n    })\n\n    return this\n  }\n\n  public band(bandName: any, sizeFactor: any) {\n    const band: any = {}\n\n    band.id = `band${this.bandNum}`\n    band.x = 0\n    band.y = this.bandY\n    band.w = this.width\n    band.h = height * (sizeFactor || 1)\n    band.trackOffset = 0\n    band.trackHeight = Math.min(\n      (band.h - band.trackOffset) / this.dataContent.nTracks,\n      20\n    )\n    band.itemHeight = band.trackHeight * 0.7\n    band.parts = []\n    band.instantWidth = 100\n    band.xScale = d3\n      .scaleTime()\n      .domain([this.dataContent.minDate, this.dataContent.maxDate])\n      .range([0, band.w])\n\n    band.yScale = (track: any) => band.trackOffset + track * band.trackHeight\n\n    band.yearsScale =\n      this.dataContent.maxDate.getUTCFullYear() -\n      this.dataContent.minDate.getUTCFullYear()\n    band.g = this.chart\n      .append(\"g\")\n      .attr(\"id\", band.id)\n      .attr(\"transform\", `translate(0,${band.y})`)\n    band.g\n      .append(\"rect\")\n      .attr(\"class\", \"band\")\n      .attr(\"width\", band.w)\n      .attr(\"height\", band.h)\n\n    const items = band.g\n      .selectAll(\"g\")\n      .data(this.dataContent.items)\n      .enter()\n      .append(\"svg\")\n      .attr(\"y\", (d: DataItem) => band.yScale(d.track))\n      .attr(\"height\", band.itemHeight)\n      .attr(\"data-title\", (d: DataItem) => {\n        if (d.instant) {\n          return `${d.label}: ${toYear(d.start)}`\n        }\n\n        return `${d.label}: ${toYear(d.start)} - ${toYear(d.end)}`\n      })\n      .attr(\"class\", (d: DataItem) => {\n        if (d.instant) {\n          return \"part instant\"\n        }\n\n        return \"part interval\"\n      })\n\n    const intervals = d3.select(`#band${this.bandNum}`).selectAll(\".interval\")\n\n    intervals\n      .append(\"rect\")\n      .attr(\"height\", \"80%\")\n      .attr(\"width\", \"80%\")\n      .attr(\"x\", \"1px\")\n      .attr(\"y\", \".5px\")\n      .style(\"filter\", \"url(#drop-shadow-intervals)\")\n\n    intervals\n      .append(\"text\")\n      .attr(\"class\", \"intervalLabel\")\n      .attr(\"x\", 3)\n      .attr(\"y\", 9.5)\n\n    const instants = d3.select(`#band${this.bandNum}`).selectAll(\".instant\")\n\n    instants\n      .append(\"circle\")\n      .attr(\"cx\", band.itemHeight / 2)\n      .attr(\"cy\", band.itemHeight / 2)\n      .attr(\"r\", 5)\n    instants\n      .append(\"text\")\n      .attr(\"class\", \"instantLabel\")\n      .attr(\"x\", 15)\n      .attr(\"y\", 10)\n\n    band.addActions = function (actions: any) {\n      return actions.forEach((action: any) => items.on(action[0], action[1]))\n    }\n\n    band.redraw = function () {\n      items\n        .attr(\"x\", (d: any) => band.xScale(d.start))\n        .attr(\"width\", (d: any) => band.xScale(d.end) - band.xScale(d.start))\n        .select(\"text\")\n        .text((d: any) => {\n          const scale = band.xScale(d.end) - band.xScale(d.start)\n          const maxLetters = scale / 9\n\n          if (d.label.length > maxLetters) {\n            return `${d.label.substr(0, maxLetters - 1)}..`\n          }\n\n          return d.label\n        })\n\n      return band.parts.forEach((part: any) => part.redraw())\n    }\n\n    this.bands[bandName] = band\n    this.components.push(band)\n    this.bandY += band.h + bandGap\n    this.bandNum += 1\n\n    return this\n  }\n\n  public labels(bandName: any) {\n    const band = this.bands[bandName]\n    const labelWidth = 46\n    const labelHeight = 20\n    const labelTop = band.y + band.h - 10\n    const yText = 15\n    const labelDefs = [\n      [\n        \"start\",\n        \"bandMinMaxLabel\",\n        0,\n        4,\n        function (min: any) {\n          return toYear(min)\n        },\n        \"Start of the selected interval\",\n        band.x + 30,\n        labelTop,\n      ],\n      [\n        \"end\",\n        \"bandMinMaxLabel\",\n        band.w - labelWidth,\n        band.w - 4,\n        function (_min: any, max: any) {\n          return toYear(max)\n        },\n        \"End of the selected interval\",\n        band.x + band.w - 152,\n        labelTop,\n      ],\n      [\n        \"middle\",\n        \"bandMidLabel\",\n        (band.w - labelWidth) / 2,\n        band.w / 2,\n        function (min: any, max: any) {\n          const result = max.getUTCFullYear() - min.getUTCFullYear()\n\n          return result\n        },\n        \"Length of the selected interval\",\n        band.x + band.w / 2 - 75,\n        labelTop,\n      ],\n    ]\n    const bandLabels = this.chart\n      .append(\"g\")\n      .attr(\"id\", `${bandName}Labels`)\n      .attr(\"transform\", `translate(0,${band.y + band.h + 1})`)\n      .selectAll(`#${bandName}Labels`)\n      .data(labelDefs)\n      .enter()\n      .append(\"g\")\n\n    bandLabels\n      .append(\"rect\")\n      .attr(\"class\", \"bandLabel\")\n      .attr(\"x\", (d: any) => d[2])\n      .attr(\"width\", labelWidth)\n      .attr(\"height\", labelHeight)\n      .style(\"opacity\", 1)\n\n    const labels: any = bandLabels\n      .append(\"text\")\n      .attr(\"class\", (d: any) => d[1])\n      .attr(\"id\", (d: any) => d[0])\n      .attr(\"x\", (d: any) => d[3])\n      .attr(\"y\", yText)\n      .attr(\"text-anchor\", (d: any) => d[0])\n\n    labels.redraw = function () {\n      const min = band.xScale.domain()[0]\n      const max = band.xScale.domain()[1]\n\n      return labels.text((d: any) => d[4](min, max))\n    }\n\n    band.parts.push(labels)\n    this.components.push(labels)\n\n    return this\n  }\n\n  public brush(bandName: any, targetNames: any) {\n    const band = this.bands[bandName]\n    const brush = d3.brushX()\n\n    const selectionScale = d3\n      .scaleTime()\n      .domain([0, 1000])\n      .range([\n        this.dataContent.minDate.getTime(),\n        this.dataContent.maxDate.getTime(),\n      ])\n\n    brush.on(\"brush\", (e) => {\n      let newDomain = band.xScale.domain()\n\n      if (e.selection) {\n        newDomain = [\n          selectionScale(e.selection[0]),\n          selectionScale(e.selection[1]),\n        ]\n      }\n\n      d3.selectAll(\".interval rect\").style(\"filter\", \"none\")\n\n      targetNames.forEach((d: any) => {\n        this.bands[d].xScale.domain(newDomain)\n\n        this.bands[d].redraw()\n      })\n    })\n\n    const xBrush = band.g.append(\"svg\").attr(\"class\", \"x brush\").call(brush)\n\n    xBrush\n      .selectAll(\"rect\")\n      .attr(\"y\", 1)\n      .attr(\"height\", band.h - 1)\n\n    return this\n  }\n\n  public redraw() {\n    return this.components.forEach((component: any) => component.redraw())\n  }\n}\n\nconst main = async () => {\n  const dataset = await fetchData()\n\n  new Timeline({ rootElId: \"chart\" })\n    .data(dataset)\n    .band(\"mainBand\", 0.82)\n    .band(\"naviBand\", 0.08)\n    .xAxis(\"mainBand\")\n    .xAxis(\"naviBand\")\n    .labels(\"mainBand\")\n    .labels(\"naviBand\")\n    .brush(\"naviBand\", [\"mainBand\"])\n    .createTooltip()\n    .redraw()\n}\n\nexport default main\n","type":"ts"},"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\n// @ts-ignore\nimport main from \"@/demos/timeline/timeline\"\n\nconst Timeline = ({ pageContext: { demoInfo } }: DemoPageProps) => (\n  <Demo demoInfo={demoInfo} main={main}>\n    <div id=\"chart\" />\n  </Demo>\n)\n\nexport default Timeline\n","type":"tsx"},"styl":".timeline-chart\n  text\n    text-shadow: .5px .5px .5px #ccc;\n\n  .axis\n    fill: #808080;\n    font-family: sans-serif;\n    font-size: 10px;\n\n  .axis line\n    stroke-width : 1;\n    stroke: grey;\n    shape-rendering: crispEdges;\n\n  .axis path\n    stroke-width : 1;\n    stroke: grey;\n    shape-rendering: crispEdges;\n\n  .band\n    fill: #FFFFFF;\n\n  .bandLabel\n    fill: #F0F0F0;\n    font: 10px sans-serif;\n    font-weight: bold;\n\n  .bandMinMaxLabel\n    fill: #11AA6A;\n    font: 10px sans-serif;\n    font-weight: bold;\n\n  .bandMidLabel\n    cursor: default;\n    fill: #BC79C5;\n    font: 10px sans-serif;\n    font-style: italic;\n    font-weight: bold;\n\n  .brush .extent\n    stroke: gray;\n    fill: #71D7E5;\n    fill-opacity: .1;\n\n  .chart\n    fill: #EEEEEE;\n\n  .interval\n    fill: #ECF7F7;\n    cursor : default;\n    pointer-events: true;\n    rect\n      stroke-width: .5px;\n      stroke: black;\n\n  .instant\n    fill: #AFCAE7;\n    cursor : default;\n\n  .instantLabel\n    fill : #7E7E7E;\n    font: 10px sans-serif;\n    shape-rendering: crispEdges;\n\n  .intervalLabel\n    fill : black;\n    font: 10px sans-serif;\n    shape-rendering: crispEdges;\n\n  .item\n    cursor : default;\n    pointer-events: auto;\n"},"key":"timeline"}}},"staticQueryHashes":[]}