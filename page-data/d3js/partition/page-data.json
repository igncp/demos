{"componentChunkName":"component---src-pages-d-3-js-partition-tsx","path":"/d3js/partition/","result":{"pageContext":{"demoInfo":{"data":["flare.json"],"docs":[["d3-ease API reference","https://github.com/d3/d3-ease#api-reference"],["d3-ease Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-ease/index.d.ts"],["d3-ease functions examples","https://bl.ocks.org/d3noob/1ea51d03775b9650e8dfd03474e202fe"],["d3-fetch API reference","https://github.com/d3/d3-fetch#api-reference"],["d3-fetch Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-fetch/index.d.ts"],["d3-hierarchy API reference","https://github.com/d3/d3-hierarchy#api-reference"],["d3-hierarchy Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-hierarchy/index.d.ts"],["d3-interpolate API reference","https://github.com/d3/d3-interpolate#api-reference"],["d3-interpolate Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-interpolate/index.d.ts"],["d3-scale API reference","https://github.com/d3/d3-scale#api-reference"],["d3-scale Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-scale/index.d.ts"],["d3-selection API reference","https://github.com/d3/d3-selection#api-reference"],["d3-selection Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-selection/index.d.ts"],["d3-transition API reference","https://github.com/d3/d3-transition#api-reference"],["d3-transition Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-transition/index.d.ts"]],"isCompleted":true,"name":"Partition","notes":["Added title attributes, labels and change colors with events","Added bounce ease function"],"sources":["http://bl.ocks.org/mbostock/4063423"],"summary":["This is a good example of how to uses hierarchies in combination with arc shapes. It includes a couple of ways of generating the hierarchy: via the size (value) of each leaf or via the count.","It is also illustrative about how to create custom tween functions for transitions. One possible improvement is the effect of the texts when flipping the direction during a transition due to being oriented vertical.","The chart displays the common flow for updating elements bound to data. Removing exited elements, adding new elements and applying the tween function to the selection."],"category":"d3js","files":{"cssModule":"","demo":{"content":"import {\n  HierarchyRectangularNode,\n  Selection,\n  arc as arcD3,\n  easeBounce,\n  hierarchy,\n  interpolate,\n  json,\n  partition as partitionD3,\n  scaleOrdinal,\n  schemePastel2,\n  select,\n} from \"d3\"\n\ntype DataNode = {\n  children: DataNode[]\n  name: string\n  size?: number\n}\n\ntype HierarchyRectNode = HierarchyRectangularNode<DataNode>\ntype PartitionType = \"count\" | \"size\"\n\nconst fetchData = () =>\n  (json(`${ROOT_PATH}data/d3js/partition/flare.json`) as unknown) as DataNode\n\nconst height = 700\nconst overColor = \"#de7c03\"\nconst transitionDuration = 2000\nconst easeFn = easeBounce\n\nconst addTitle = <A extends SVGElement, B extends SVGElement>(\n  selector: Selection<A, HierarchyRectNode, B, unknown>\n) => {\n  selector.append(\"title\").text((node) => `${node.data.name}\\n${node.value}`)\n}\n\nconst getNodeText = (node: HierarchyRectNode) => {\n  const dx = Math.abs(node.x0 - node.x1)\n\n  if (dx > 0.07 && node.parent && node.data.name.length < 10) {\n    return node.data.name\n  }\n\n  return \"\"\n}\n\ntype RenderChart = (o: {\n  rootData: DataNode\n  rootElId: string\n  partitionType: PartitionType\n}) => {\n  updatePartition(partitionType: PartitionType): void\n}\n\nconst getDataHierarchy = (\n  rootData: DataNode,\n  partitionType: PartitionType,\n  radius: number\n) => {\n  const dataHierarchySize = hierarchy(rootData).sum(\n    (d: DataNode) => d.size || 0\n  )\n  const dataHierarchyCount = hierarchy(rootData).sum(() => 1)\n  const partition = partitionD3<DataNode>().size([2 * Math.PI, radius])\n\n  const hierarchyResult = partition(\n    partitionType === \"size\" ? dataHierarchySize : dataHierarchyCount\n  )\n\n  return hierarchyResult.descendants()\n}\n\nconst extractTweenObj = (node: HierarchyRectNode) => ({\n  depth: node.depth,\n  x0: node.x0,\n  x1: node.x1,\n  y0: node.y0,\n  y1: node.y1,\n})\n\nconst getInterpolatorFn = (\n  initialData: HierarchyRectNode[],\n  fn: (n: HierarchyRectNode) => string | null\n) => (finalNode: HierarchyRectNode, nodeIndex: number) => {\n  const initialNode = initialData[nodeIndex]\n\n  const interpolateFn = interpolate(\n    extractTweenObj(initialNode),\n    extractTweenObj(finalNode)\n  )\n\n  return (t: number) => {\n    const transitientState = interpolateFn(t)\n\n    return fn(transitientState as HierarchyRectNode)!\n  }\n}\n\nconst renderChart: RenderChart = ({ rootData, rootElId, partitionType }) => {\n  const { width } = (document.getElementById(\n    \"chart\"\n  ) as HTMLElement).getBoundingClientRect()\n  const radius = Math.min(width, height) / 2\n  const colorScale = scaleOrdinal(schemePastel2)\n\n  const color = (node: HierarchyRectNode) =>\n    node.children\n      ? colorScale(node.data.name)\n      : colorScale(node.parent!.data.name)\n\n  const svg = select(`#${rootElId}`)\n    .append(\"svg\")\n    .text(\"\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .append(\"g\")\n    .attr(\"transform\", `translate(${width / 2},${height * 0.52})`)\n\n  addFilter(svg)\n\n  const descendants = getDataHierarchy(rootData, partitionType, radius)\n\n  const arc = arcD3<HierarchyRectNode>()\n    .startAngle((node) => node.x0)\n    .endAngle((node) => node.x1)\n    .innerRadius((node) => node.y0)\n    .outerRadius((node) => node.y1)\n\n  const textsTransform = (node: HierarchyRectNode) => {\n    if (!node.depth) {\n      return \"\"\n    }\n\n    const centroid = arc.centroid(node)\n    const rotationDeg = (() => {\n      const rotation =\n        90 + ((node.x0 + (node.x1 - node.x0) / 2) * 180) / Math.PI\n\n      return rotation > 90 && rotation < 270 ? rotation - 180 : rotation\n    })()\n\n    return [\n      `rotate(${rotationDeg},${centroid[0]},${centroid[1]})`,\n      `translate(${centroid[0]},${centroid[1]})`,\n    ].join(\" \")\n  }\n\n  const renderDescendants = (\n    usedDescendants: HierarchyRectangularNode<DataNode>[]\n  ) => {\n    const pathSel = svg.selectAll<SVGPathElement, HierarchyRectNode>(\"path\")\n    const pathInitialData = pathSel.data()\n    const path = pathSel.data(usedDescendants)\n\n    path.exit().remove()\n\n    const pathEnter = path\n      .enter()\n      .append(\"path\")\n      .attr(\"display\", (node) => (node.depth ? null : \"none\"))\n      .attr(\"data-index\", (_d, i: number) => i)\n      .style(\"stroke\", \"#000\")\n      .style(\"stroke-width\", \"0.5px\")\n      .style(\"stroke-dasharray\", \"1,3\")\n      .style(\"fill\", color)\n      .style(\"filter\", (_node, index) =>\n        // not adding drop-shadow in all to avoid too much saturation\n        index % 3 !== 0 ? \"url(#drop-shadow)\" : null\n      )\n      .attr(\"d\", arc)\n\n    path\n      .transition()\n      .duration(transitionDuration)\n      .ease(easeFn)\n      .attrTween(\"d\", getInterpolatorFn(pathInitialData, arc))\n\n    const textsSel = svg.selectAll<SVGTextElement, HierarchyRectNode>(\"text\")\n    const textsInitialData = textsSel.data()\n    const texts = textsSel.data(usedDescendants)\n\n    texts.exit().remove()\n\n    const textsEnter = texts\n      .enter()\n      .append(\"text\")\n      .text(getNodeText)\n      .attr(\"transform\", textsTransform)\n      .attr(\"data-index\", (_d, index) => index)\n      .style(\"fill\", \"#333\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font\", \"bold 12px Arial\")\n      .style(\"cursor\", \"default\")\n      .attr(\"transform\", textsTransform)\n\n    texts\n      .transition()\n      .duration(transitionDuration)\n      .ease(easeFn)\n      .attrTween(\n        \"transform\",\n        getInterpolatorFn(textsInitialData, textsTransform)\n      )\n\n    const updatedGroups = [pathEnter, textsEnter]\n\n    updatedGroups.forEach((set) => {\n      set.on(\"mouseover\", function () {\n        const index = select(this).attr(\"data-index\")\n\n        select(`path[data-index=\"${index}\"]`).style(\"fill\", overColor)\n        select(`text[data-index=\"${index}\"]`).style(\"fill\", \"white\")\n      })\n\n      set.on(\"mouseout\", function () {\n        const index = select(this).attr(\"data-index\")\n\n        select<SVGPathElement, HierarchyRectNode>(\n          `path[data-index=\"${index}\"]`\n        ).style(\"fill\", color)\n        select(`text[data-index=\"${index}\"]`).style(\"fill\", \"#000\")\n      })\n    })\n\n    addTitle(path)\n    addTitle(texts)\n  }\n\n  renderDescendants(descendants)\n\n  return {\n    updatePartition: (newPartitionType: PartitionType) => {\n      const newDescendants = getDataHierarchy(\n        rootData,\n        newPartitionType,\n        radius\n      )\n\n      renderDescendants(newDescendants)\n    },\n  }\n}\n\nconst main = async () => {\n  const rootData = await fetchData()\n\n  const formEl = document.getElementById(\"type-form\") as HTMLFormElement\n\n  const getCurrentSelectedRadio = (): PartitionType => {\n    const result = Array.from(\n      (formEl.elements as unknown) as HTMLInputElement[]\n    ).reduce((acc, el: HTMLInputElement) => {\n      if (acc) return acc\n\n      if (el.checked) return el.value\n\n      return \"\"\n    }, \"\")\n\n    return result as PartitionType\n  }\n\n  formEl.addEventListener(\"change\", () => {\n    const newPartitionType = getCurrentSelectedRadio()\n\n    updatePartition(newPartitionType)\n  })\n\n  const partitionType = getCurrentSelectedRadio()\n\n  const { updatePartition } = renderChart({\n    partitionType,\n    rootData,\n    rootElId: \"chart\",\n  })\n}\n\nconst addFilter = (\n  svg: Selection<SVGGElement, unknown, HTMLElement, unknown>\n) => {\n  const defs = svg.append(\"defs\")\n  const filter = defs.append(\"filter\")\n\n  filter.attr(\"id\", \"drop-shadow\")\n  filter\n    .append(\"feGaussianBlur\")\n    .attr(\"in\", \"SourceAlpha\")\n    .attr(\"stdDeviation\", 9)\n  filter.append(\"feOffset\").attr(\"dx\", 2).attr(\"dy\", 5)\n  filter\n    .append(\"feComponentTransfer\")\n    .append(\"feFuncA\")\n    .attr(\"slope\", \".5\")\n    .attr(\"type\", \"linear\")\n\n  const feMerge = filter.append(\"feMerge\")\n\n  feMerge.append(\"feMergeNode\")\n  feMerge.append(\"feMergeNode\").attr(\"in\", \"SourceGraphic\")\n}\n\nexport default main\n","type":"ts"},"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main from \"@/demos/partition/partition\"\n\nconst Partition = ({ pageContext }: DemoPageProps) => (\n  <Demo main={main} pageContext={pageContext}>\n    <form id=\"type-form\">\n      <label>\n        <input name=\"mode\" type=\"radio\" value=\"size\" /> Size\n      </label>\n      <label>\n        <input defaultChecked name=\"mode\" type=\"radio\" value=\"count\" /> Count\n      </label>\n    </form>\n    <div id=\"chart\" />\n  </Demo>\n)\n\nexport default Partition\n","type":"tsx"},"styl":""},"key":"partition"},"meta":{"description":"Radial treemap example using D3.js, with data from a partition, where labels, mouse events and titles are added."}}},"staticQueryHashes":[]}