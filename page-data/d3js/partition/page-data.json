{
    "componentChunkName": "component---src-pages-d-3-js-partition-tsx",
    "path": "/d3js/partition/",
    "result": {"pageContext":{"demoInfo":{"dataFiles":["flare.json"],"docs":[["d3-ease API reference","https://github.com/d3/d3-ease#api-reference"],["d3-ease Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-ease/index.d.ts"],["d3-ease functions examples","https://bl.ocks.org/d3noob/1ea51d03775b9650e8dfd03474e202fe"],["d3-fetch API reference","https://github.com/d3/d3-fetch#api-reference"],["d3-fetch Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-fetch/index.d.ts"],["d3-hierarchy API reference","https://github.com/d3/d3-hierarchy#api-reference"],["d3-hierarchy Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-hierarchy/index.d.ts"],["d3-interpolate API reference","https://github.com/d3/d3-interpolate#api-reference"],["d3-interpolate Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-interpolate/index.d.ts"],["d3-scale API reference","https://github.com/d3/d3-scale#api-reference"],["d3-scale Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-scale/index.d.ts"],["d3-selection API reference","https://github.com/d3/d3-selection#api-reference"],["d3-selection Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-selection/index.d.ts"],["d3-transition API reference","https://github.com/d3/d3-transition#api-reference"],["d3-transition Types","https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-transition/index.d.ts"]],"isCompleted":true,"name":"Partition","notes":[],"sources":["http://bl.ocks.org/mbostock/4063423"],"summary":["This is a good example of how to uses hierarchies in combination with arc shapes. It includes a couple of ways of generating the hierarchy: via the size (value) of each leaf or via the count.","It is also illustrative about how to create custom tween functions for transitions. One possible improvement is the effect of the texts when flipping the direction during a transition due to being oriented vertical.","The chart displays the common flow for updating elements bound to data. Removing exited elements, adding new elements and applying the tween function to the selection."],"category":"d3js","files":{"demoCSS":[],"demoTS":[{"content":"import { PartitionChart } from \"./partition-chart\"\nimport {\n  CONTAINER_ID,\n  PartitionType,\n  TYPE_FORM,\n  fetchData,\n  getChartConfig,\n} from \"./partition-chart-config\"\n\nconst main = async () => {\n  const rootData = await fetchData()\n\n  const formEl = document.getElementById(TYPE_FORM) as HTMLFormElement\n\n  const getCurrentSelectedRadio = (): PartitionType => {\n    const selectedRadio = Array.from(\n      formEl.elements as unknown as HTMLInputElement[]\n    ).find((formElement: HTMLInputElement) => formElement.checked)\n\n    return selectedRadio!.value as PartitionType\n  }\n\n  const partitionType = getCurrentSelectedRadio()\n\n  const chartConfig = getChartConfig({\n    partitionType,\n    rootData,\n  })\n\n  const chart = new PartitionChart(chartConfig)\n\n  chart.render()\n\n  formEl.addEventListener(\"change\", () => {\n    const newPartitionType = getCurrentSelectedRadio()\n\n    chart.updatePartition(newPartitionType)\n  })\n}\n\nexport { CONTAINER_ID, TYPE_FORM }\n\nexport default main\n","filePath":"src/demos/partition/partition.ts"},{"content":"import { json } from \"d3\"\n\nimport { ChartConfig, Node, PartitionType } from \"./partition-chart\"\n\nconst CONTAINER_ID = \"chart\"\nconst TYPE_FORM = \"type-form\"\n\ntype DataNode = Node<{\n  name: string\n  size?: number\n}>\n\nconst fetchData = () =>\n  json(\n    `${ROOT_PATH}data/d3js/partition/flare.json`\n  ) as unknown as Promise<DataNode>\n\ntype Config = ChartConfig<DataNode>\n\nconst getNodeSize: Config[\"getNodeSize\"] = (node) => node.size\nconst getNodeLabel: Config[\"getNodeLabel\"] = (node) => node.name\nconst getNodeTitle: Config[\"getNodeTitle\"] = ({ nodeData, valueNum }) =>\n  `${nodeData.name}\\n${valueNum}`\n\nconst getChartConfig = ({\n  partitionType,\n  rootData,\n}: {\n  partitionType: PartitionType\n  rootData: DataNode\n}) => ({\n  getNodeLabel,\n  getNodeSize,\n  getNodeTitle,\n  partitionType,\n  rootData,\n  rootElId: CONTAINER_ID,\n})\n\nexport { CONTAINER_ID, TYPE_FORM, fetchData, getChartConfig, PartitionType }\n","filePath":"src/demos/partition/partition-chart-config.ts"},{"content":"import {\n  D3DragEvent,\n  HierarchyRectangularNode,\n  Selection,\n  arc as arcD3,\n  drag as dragD3,\n  easeBounce,\n  easeLinear,\n  hierarchy,\n  interpolate,\n  partition as partitionD3,\n  scaleOrdinal,\n  schemePastel2,\n  select,\n} from \"d3\"\n\ntype Node<NodeData> = NodeData & {\n  chidren: Array<Node<NodeData>>\n}\n\ntype HierarchyRectNode<ChartData> = HierarchyRectangularNode<Node<ChartData>>\n\nenum PartitionType {\n  Count = \"count\",\n  Size = \"size\",\n}\n\nconst height = 700\nconst overColor = \"#de7c03\"\nconst transitionDuration = 2000\nconst easeFn = easeBounce\n\nconst extractTweenObj = <ChartData>(node: HierarchyRectNode<ChartData>) => ({\n  depth: node.depth,\n  x0: node.x0,\n  x1: node.x1,\n  y0: node.y0,\n  y1: node.y1,\n})\n\nconst getInterpolatorFn =\n  <ChartData>({\n    fn,\n    initialData,\n  }: {\n    fn: (node: HierarchyRectNode<ChartData>) => string | null\n    initialData: Array<HierarchyRectNode<ChartData>>\n  }) =>\n  (...[finalNode, nodeIndex]: [HierarchyRectNode<ChartData>, number]) => {\n    const { [nodeIndex]: initialNode } = initialData\n\n    const interpolateFn = interpolate(\n      extractTweenObj(initialNode),\n      extractTweenObj(finalNode)\n    )\n\n    return (t: number) => {\n      const transitientState = interpolateFn(t)\n\n      return fn(transitientState as HierarchyRectNode<ChartData>)!\n    }\n  }\n\ntype ChartConfig<ChartData> = {\n  getNodeLabel: (node: Node<ChartData>) => string\n  getNodeSize: (node: Node<ChartData>) => number | undefined\n  getNodeTitle: (options: {\n    nodeData: Node<ChartData>\n    valueNum?: number\n  }) => string\n  partitionType: PartitionType\n  rootData: Node<ChartData>\n  rootElId: string\n}\n\ntype ChartElements = {\n  svg: Selection<SVGSVGElement, unknown, HTMLElement, unknown>\n  svgDrag: Selection<SVGGElement, unknown, HTMLElement, unknown>\n  svgG: Selection<SVGGElement, unknown, HTMLElement, unknown>\n}\n\nclass PartitionChart<ChartData> {\n  private readonly config: ChartConfig<ChartData>\n  private readonly elements: ChartElements\n\n  private readonly state: {\n    descendants: Array<HierarchyRectangularNode<Node<ChartData>>>\n    drag: { x: number; y: number }\n    partitionType: PartitionType\n  }\n\n  public constructor(config: ChartConfig<ChartData>) {\n    this.config = config\n\n    const { partitionType, rootElId } = config\n\n    const svg = select(`#${rootElId}`).append(\"svg\").text(\"\")\n    const svgDrag = svg.append(\"g\")\n    const svgG = svgDrag.append(\"g\")\n\n    this.state = {\n      descendants: [],\n      drag: { x: 0, y: 0 },\n      partitionType,\n    }\n\n    this.state.descendants = this.getDataHierarchy()\n\n    this.elements = {\n      svg,\n      svgDrag,\n      svgG,\n    }\n\n    this.setupDrag()\n\n    window.addEventListener(\"resize\", this.handleResize)\n  }\n\n  public updatePartition(newPartitionType: PartitionType) {\n    this.state.partitionType = newPartitionType\n\n    const newDescendants = this.getDataHierarchy()\n\n    this.state.descendants = newDescendants\n\n    this.renderDescendants()\n  }\n\n  public render() {\n    const { width } = this.getDimensions()\n    const {\n      elements: { svg, svgG },\n    } = this\n\n    svg.attr(\"width\", width).attr(\"height\", height)\n    svgG.attr(\"transform\", `translate(${width / 2},${height * 0.52})`)\n\n    this.renderDescendants()\n  }\n\n  private getDimensions() {\n    const {\n      config: { rootElId },\n    } = this\n    const { width } = (\n      document.getElementById(rootElId) as HTMLElement\n    ).getBoundingClientRect()\n    const chartWidth = Math.max(width, 700)\n    const radius = Math.min(chartWidth, height) / 2\n\n    return {\n      chartWidth,\n      radius,\n      width,\n    }\n  }\n\n  private getDataHierarchy() {\n    const {\n      config: { getNodeSize, rootData },\n      state: { partitionType },\n    } = this\n    const { radius } = this.getDimensions()\n    const dataHierarchySize = hierarchy(rootData).sum(\n      (node: Node<ChartData>) => getNodeSize(node) ?? 0\n    )\n    const dataHierarchyCount = hierarchy(rootData).sum(() => 1)\n    const partition = partitionD3<Node<ChartData>>().size([2 * Math.PI, radius])\n\n    const hierarchyResult = partition(\n      partitionType === \"size\" ? dataHierarchySize : dataHierarchyCount\n    )\n\n    return hierarchyResult.descendants()\n  }\n\n  private setupDrag() {\n    const {\n      elements: { svg, svgDrag },\n    } = this\n\n    const handler = (\n      dragEvent: D3DragEvent<SVGSVGElement, unknown, unknown>\n    ) => {\n      this.state.drag.x += dragEvent.dx\n      this.state.drag.y += dragEvent.dy\n\n      svgDrag.attr(\n        \"transform\",\n        `translate(${this.state.drag.x},${this.state.drag.y})`\n      )\n    }\n\n    const dragBehavior = dragD3<SVGSVGElement, unknown>().on(\"drag\", handler)\n\n    svg\n      .style(\"cursor\", \"move\")\n      .call(dragBehavior)\n      .on(\"drag\", handler)\n      .on(\"wheel\", null)\n  }\n\n  private renderDescendants() {\n    const {\n      config: { getNodeLabel, getNodeTitle },\n      elements: { svgG },\n      state: { descendants: usedDescendants },\n    } = this\n\n    const colorScale = scaleOrdinal(schemePastel2)\n\n    const color = (node: HierarchyRectNode<ChartData>) =>\n      node.children\n        ? colorScale(getNodeLabel(node.data))\n        : colorScale(getNodeLabel(node.parent!.data))\n\n    const arc = arcD3<HierarchyRectNode<ChartData>>()\n      .startAngle((node) => node.x0)\n      .endAngle((node) => node.x1)\n      .innerRadius((node) => node.y0)\n      .outerRadius((node) => node.y1)\n      .padAngle(0.01)\n\n    const textsTransform = (node: HierarchyRectNode<ChartData>) => {\n      if (!node.depth) {\n        return \"\"\n      }\n\n      const centroid = arc.centroid({\n        ...node,\n        x0: node.x0 + (node.x0 > Math.PI ? -1 : 1) * 0.05,\n      })\n      const rotationDeg = (() => {\n        const rotation =\n          90 + ((node.x0 + (node.x1 - node.x0) / 2) * 180) / Math.PI\n\n        return rotation > 90 && rotation < 270 ? rotation - 180 : rotation\n      })()\n\n      return [\n        `rotate(${rotationDeg},${centroid[0]},${centroid[1]})`,\n        `translate(${centroid[0]},${centroid[1]})`,\n      ].join(\" \")\n    }\n\n    const pathSel = svgG.selectAll<\n      SVGPathElement,\n      HierarchyRectNode<ChartData>\n    >(\"path\")\n    const pathInitialData = pathSel.data()\n    const path = pathSel.data(usedDescendants)\n\n    path.exit().remove()\n\n    const pathEnter = path\n      .enter()\n      .append(\"path\")\n      .attr(\"display\", (node) => (node.depth ? null : \"none\"))\n      .attr(\"data-index\", (...[, nodeIndex]) => nodeIndex)\n      .style(\"stroke\", \"#000\")\n      .style(\"stroke-width\", \"0.5px\")\n      .style(\"stroke-dasharray\", \"1,3\")\n      .style(\"fill\", color)\n      .attr(\"d\", arc)\n\n    path\n      .transition()\n      .duration(transitionDuration)\n      .ease(easeFn)\n      .attrTween(\n        \"d\",\n        getInterpolatorFn({ fn: arc, initialData: pathInitialData })\n      )\n\n    const initialTextsSel = svgG.selectAll<\n      SVGTextElement,\n      HierarchyRectNode<ChartData>\n    >(\"text\")\n    const textsInitialData = initialTextsSel.data()\n    const initialTexts = initialTextsSel.data(usedDescendants)\n\n    initialTexts.exit().remove()\n\n    const opacityFn = (node: HierarchyRectangularNode<Node<ChartData>>) => {\n      const arcLength = Math.abs(node.x0 - node.x1) * node.y1\n\n      // this number is obtained empirically\n      if (arcLength < 25) {\n        return 0\n      }\n\n      const isAlmostVertical = Math.abs((node.x0 + node.x1) / 2 - Math.PI) < 0.2\n\n      return isAlmostVertical ? 0 : 1\n    }\n\n    const textsEnter = initialTexts\n      .enter()\n      .append(\"text\")\n      .style(\"fill\", \"#333\")\n      .style(\"cursor\", \"default\")\n      .style(\"font\", \"bold 12px Arial\")\n      .attr(\"text-anchor\", \"middle\")\n      .text((...[node, nodeIndex]) => {\n        if (nodeIndex === 0) {\n          return \"\"\n        }\n\n        const label = getNodeLabel(node.data)\n        const limit = 9\n\n        return label.length > limit ? `${label.slice(0, limit)}...` : label\n      })\n      .attr(\"data-index\", (...[, nodeIndex]) => nodeIndex)\n      .attr(\"transform\", textsTransform)\n      .style(\"opacity\", opacityFn)\n\n    initialTexts\n      .transition(\"movement\")\n      .duration(transitionDuration)\n      .ease(easeFn)\n      .attrTween(\n        \"transform\",\n        getInterpolatorFn({\n          fn: textsTransform,\n          initialData: textsInitialData,\n        })\n      )\n\n    svgG\n      .selectAll<SVGTextElement, HierarchyRectNode<ChartData>>(\"text\")\n      .transition(\"opacity\")\n      .duration(transitionDuration)\n      .ease(easeLinear)\n      .style(\"opacity\", opacityFn)\n\n    const updatedGroups = [pathEnter, textsEnter]\n\n    updatedGroups.forEach((set) => {\n      set.on(\"mouseover\", function onMouseOver() {\n        const nodeIndex = select(this).attr(\"data-index\")\n\n        select(`path[data-index=\"${nodeIndex}\"]`).style(\"fill\", overColor)\n        select(`text[data-index=\"${nodeIndex}\"]`).style(\"fill\", \"white\")\n      })\n\n      set.on(\"mouseout\", function onMouseOut() {\n        const nodeIndex = select(this).attr(\"data-index\")\n\n        select<SVGPathElement, HierarchyRectNode<ChartData>>(\n          `path[data-index=\"${nodeIndex}\"]`\n        ).style(\"fill\", color)\n        select(`text[data-index=\"${nodeIndex}\"]`).style(\"fill\", \"#000\")\n      })\n\n      set.append(\"title\").text((node) =>\n        getNodeTitle({\n          nodeData: node.data,\n          valueNum: node.value,\n        })\n      )\n    })\n  }\n\n  private readonly handleResize = () => {\n    this.render()\n  }\n}\n\nexport { PartitionChart, PartitionType, Node, ChartConfig }\n","filePath":"src/demos/partition/partition-chart.ts"}],"page":{"content":"import React from \"react\"\n\nimport { DemoPageProps } from \"@/common\"\n\nimport Demo from \"@/components/demo\"\n\nimport main, { CONTAINER_ID, TYPE_FORM } from \"@/demos/partition/partition\"\n\nconst Partition = ({ pageContext }: DemoPageProps) => (\n  <Demo main={main} pageContext={pageContext}>\n    <form id={TYPE_FORM} style={{ marginBottom: 20 }}>\n      <label>\n        <input name=\"mode\" type=\"radio\" value=\"size\" /> Size\n      </label>\n      <label>\n        <input defaultChecked name=\"mode\" type=\"radio\" value=\"count\" /> Count\n      </label>\n    </form>\n    <div id={CONTAINER_ID} />\n  </Demo>\n)\n\nexport default Partition\n","type":"tsx"}},"key":"partition"},"meta":{"description":"Radial treemap example using D3.js, with data from a partition, where labels, mouse events and titles are added."}}},
    "staticQueryHashes": []}