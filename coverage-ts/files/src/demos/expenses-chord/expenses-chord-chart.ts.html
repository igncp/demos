
  <!DOCTYPE html>
  <html>
    <head>
      <title>expenses-chord-chart.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/demos/expenses-chord/expenses-chord-chart.ts</td><td class="">98.31%</td><td class="">95%</td><td class="">711</td><td class="">699</td><td class="">12</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  BaseType,
  Chord,
  ChordGroup,
  D3DragEvent,
  Selection,
  arc as arcD3,
  chordDirected,
  descending as descendingD3,
  drag,
  easeCircle,
  interpolate,
  ribbonArrow as ribbonArrowD3,
  ribbon as ribbonD3,
  scaleOrdinal,
  schemeTableau10,
  select,
} from &quot;d3&quot;
import $ from &quot;jquery&quot;
import &quot;jquery-ui/themes/base/all.css&quot;
import { v1 as uuid } from &quot;uuid&quot;

import * as styles from &quot;./expenses-chord.module.css&quot;

if (typeof window !== &quot;undefined&quot;) {
  require(&quot;jquery-ui/ui/widgets/tooltip&quot;)
}

const height = 800
const elementDefaultOpacity = 0.7

enum DisplayType {
  Source = &quot;source&quot;,
  Target = &quot;target&quot;,
}

enum RibbonType {
  Arrow = &quot;arrow&quot;,
  Common = &quot;common&quot;,
}

type ChartState = {
  lastFocused: string | null
}

const durations = {
  ribbonAnimation: 1000,
  zoom: 500,
} as const

const easingFn = easeCircle

const applyOpacityEffect = &lt;ContainerEl extends BaseType, Datum&gt;(
  elementsSelection: Selection&lt;ContainerEl, Datum, BaseType, unknown&gt;
) =&gt; {
  elementsSelection
    .style(&quot;opacity&quot;, elementDefaultOpacity)
    .on(&quot;mouseenter&quot;, function onMouseEnter() {
      select(this).style(&quot;opacity&quot;, 1)
    })
    .on(&quot;mouseleave&quot;, function onMouseLeave() {
      select(this).style(&quot;opacity&quot;, elementDefaultOpacity)
    })
}

const filterBlackOpacity = ({
  deviation,
  id,
  slope,
  svg,
}: {
  deviation: number
  id: string
  slope: number
  svg: Selection&lt;SVGSVGElement, unknown, HTMLElement, unknown&gt;
}) =&gt; {
  const defs = svg.append(&quot;defs&quot;)
  const filter = defs
    .append(&quot;filter&quot;)
    .attr(&quot;height&quot;, &quot;500%&quot;)
    .attr(&quot;id&quot;, `drop-shadow-${id}`)
    .attr(&quot;width&quot;, &quot;500%&quot;)
    .attr(&quot;x&quot;, &quot;-200%&quot;)
    .attr(&quot;y&quot;, &quot;-200%&quot;)

  filter
    .append(&quot;feGaussianBlur&quot;)
    .attr(&quot;in&quot;, &quot;SourceAlpha&quot;)
    .attr(&quot;stdDeviation&quot;, deviation)

  filter.append(&quot;feOffset&quot;).attr(&quot;dx&quot;, 1).attr(&quot;dy&quot;, 1)
  filter
    .append(&quot;feComponentTransfer&quot;)
    .append(&quot;feFuncA&quot;)
    .attr(&quot;slope&quot;, slope)
    .attr(&quot;type&quot;, &quot;linear&quot;)

  const feMerge = filter.append(&quot;feMerge&quot;)

  feMerge.append(&quot;feMergeNode&quot;)

  feMerge.append(&quot;feMergeNode&quot;).attr(&quot;in&quot;, &quot;SourceGraphic&quot;)
}

// @TODO: setup drag with zoom
const setupDrag = ({
  svgDrag,
  svgTop,
}: {
  svgDrag: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  svgTop: Selection&lt;SVGSVGElement, unknown, HTMLElement, unknown&gt;
}) =&gt; {
  const draggedState = {
    s: 1,
    x: 0,
    y: 0,
  }

  const setupTransform = () =&gt; {
    svgDrag.attr(
      &quot;transform&quot;,
      `translate(${draggedState.x},${draggedState.y}) scale(${draggedState.s})`
    )
  }

  const dragHandler = drag&lt;SVGSVGElement, unknown&gt;().on(
    &quot;drag&quot;,
    (dragEvent: D3DragEvent&lt;SVGSVGElement, unknown, unknown&gt;) =&gt; {
      draggedState.x += dragEvent.dx
      draggedState.y += dragEvent.dy

      setupTransform()
    }
  )

  setupTransform()

  svgTop
    .style(&quot;cursor&quot;, &quot;move&quot;)
    .call(dragHandler)
    .on(&quot;wheel&quot;, (wheelEvent: WheelEvent) =&gt; {
      wheelEvent.preventDefault()

      draggedState.s += -wheelEvent.deltaY / 1000

      setupTransform()
    })
}

type ChartConfig = {
  chordGroupsIds: string[]
  getChordGroupTitle: (groupId: string) =&gt; string
  getChordMatrix: () =&gt; number[][]
  getChordTitle: (
    sourceIndex: number,
    targetIndex: number,
    sourceValue: number,
    targetValue: number
  ) =&gt; string
  getDisplayTypeOnGroupClick: (chordGroupId: string) =&gt; DisplayType
  getRibbonGroupIdColor: (
    sourceGroupId: string,
    targetGroupId: string
  ) =&gt; string
  getRibbonType: () =&gt; RibbonType
  rootElId: string
}

const renderChart = (chartConfig: ChartConfig) =&gt; {
  const { rootElId } = chartConfig

  const chartState: ChartState = {
    lastFocused: null,
  }

  const { chordGroupsIds } = chartConfig

  const color = scaleOrdinal(chordGroupsIds, schemeTableau10)

  const { width } = (
    document.getElementById(rootElId) as HTMLElement
  ).getBoundingClientRect()

  const innerRadius = Math.min(width, height) * 0.5 - 20
  const outerRadius = innerRadius + 20

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const ribbonCommon = (ribbonType: any) =&gt;
    ribbonType.radius(innerRadius - 0.5).padAngle(1 / innerRadius)

  const ribbonArrow = ribbonCommon(ribbonArrowD3())
  const ribbon = ribbonCommon(ribbonD3())

  const totalHeight = height + 50

  const svgTop = select(`#${rootElId}`)
    .attr(&quot;class&quot;, styles.chartWrapper)
    .append(&quot;svg&quot;)
    .attr(&quot;width&quot;, width)
    .attr(&quot;height&quot;, totalHeight)

  filterBlackOpacity({
    deviation: 2,
    id: &quot;groups&quot;,
    slope: 0.5,
    svg: svgTop,
  })

  const svgCenter = svgTop
    .append(&quot;g&quot;)
    .attr(&quot;transform&quot;, `translate(${width / 2}, ${totalHeight / 2})`)

  const svgG = svgCenter.append(&quot;g&quot;).attr(&quot;class&quot;, &quot;svg-drag&quot;)

  setupDrag({
    svgDrag: svgG,
    svgTop,
  })

  // this rect is to allow zooming
  svgG
    .append(&quot;rect&quot;)
    .attr(&quot;fill&quot;, &quot;#fff&quot;)
    .attr(&quot;width&quot;, width)
    .attr(&quot;height&quot;, height)
    .attr(&quot;transform&quot;, `translate(-${width / 2}, -${totalHeight / 2})`)

  const textId = uuid()

  const chord = chordDirected()
    .padAngle(12 / innerRadius)
    .sortSubgroups(descendingD3)
    .sortChords(descendingD3)

  svgG
    .append(&quot;path&quot;)
    .attr(&quot;fill&quot;, &quot;none&quot;)
    .attr(&quot;id&quot;, textId)
    .attr(
      &quot;d&quot;,
      arcD3()({
        endAngle: 2 * Math.PI,
        innerRadius: 0,
        outerRadius,
        startAngle: 0,
      }) as string
    )

  const arc = arcD3&lt;d3.ChordGroup&gt;()
    .innerRadius(innerRadius)
    .outerRadius(outerRadius)

  const ribbonContainer = svgG.append(&quot;g&quot;)
  const groupContainer = svgG
    .append(&quot;g&quot;)
    .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
    .attr(&quot;font-size&quot;, 10)

  const getRibbonKey = (ribbonNode: Chord) =&gt;
    `${ribbonNode.source.index}_${ribbonNode.target.index}`

  const renderItems = () =&gt; {
    const usedRibbon =
      chartConfig.getRibbonType() === RibbonType.Common ? ribbon : ribbonArrow

    const matrix = chartConfig.getChordMatrix()
    const chords = chord(matrix)

    const initialRibbonsData = ribbonContainer
      .selectAll&lt;SVGPathElement, Chord&gt;(`.${styles.ribbon}`)
      .data()
      .reduce&lt;{ [k: string]: Chord | undefined }&gt;((...[acc, ribbonNode]) =&gt; {
        acc[getRibbonKey(ribbonNode)] = ribbonNode

        return acc
      }, {})

    const fillRibbon = (chordItem: Chord) =&gt;
      color(
        chartConfig.getRibbonGroupIdColor(
          chordGroupsIds[chordItem.source.index],
          chordGroupsIds[chordItem.target.index]
        )
      )

    const ribbons = ribbonContainer
      .selectAll&lt;SVGPathElement, Chord&gt;(`.${styles.ribbon}`)
      .data&lt;Chord&gt;(chords, (chordItem) =&gt; getRibbonKey(chordItem))
      .join(
        (enter) =&gt; {
          const enterSelection = enter
            .append(&quot;path&quot;)
            .attr(&quot;class&quot;, styles.ribbon)
            .attr(&quot;fill&quot;, fillRibbon)

          applyOpacityEffect(enterSelection)

          return enterSelection
            .transition()
            .duration(durations.ribbonAnimation)
            .attrTween(&quot;d&quot;, (finalRibbon) =&gt; {
              const initialRibbon = {
                source: {
                  endAngle: 0,
                  startAngle: 0,
                },
                target: {
                  endAngle: 0,
                  startAngle: 0,
                },
              }
              const interpolateSource = interpolate(
                initialRibbon.source,
                finalRibbon.source
              )
              const interpolateTarget = interpolate(
                initialRibbon.target,
                finalRibbon.target
              )

              return (t) =&gt; {
                const interpolated = {
                  source: interpolateSource(t),
                  target: interpolateTarget(t),
                }

                return usedRibbon(interpolated)
              }
            })
        },
        (update) =&gt; {
          update
            .transition()
            .duration(durations.ribbonAnimation)
            .attr(&quot;fill&quot;, fillRibbon)
            .attrTween(&quot;d&quot;, (finalRibbon) =&gt; {
              const { [getRibbonKey(finalRibbon)]: initialRibbon } =
                initialRibbonsData

              if (!initialRibbon) {
                return () =&gt; usedRibbon(finalRibbon)
              }

              const interpolateSource = interpolate(
                initialRibbon.source,
                finalRibbon.source
              )
              const interpolateTarget = interpolate(
                initialRibbon.target,
                finalRibbon.target
              )

              return (t) =&gt; {
                const interpolated = {
                  source: interpolateSource(t),
                  target: interpolateTarget(t),
                }

                return usedRibbon(interpolated)
              }
            })

          return update
        }
      )

    ribbons
      .attr(&quot;title&quot;, (chordItem) =&gt;
        chartConfig.getChordTitle(
          chordItem.source.index,
          chordItem.target.index,
          chordItem.source.value,
          chordItem.target.value
        )
      )
      .on(&quot;click&quot;, function onChordClick(...[, chordItem]) {
        const chordSelection = select(this)
        const chordGroupId = `${chordGroupsIds[chordItem.source.index]}_${
          chordGroupsIds[chordItem.target.index]
        }`

        if (chartState.lastFocused === chordGroupId) {
          ribbons.attr(&quot;display&quot;, &quot;block&quot;)
          chartState.lastFocused = null
        } else {
          ribbons.attr(&quot;display&quot;, &quot;none&quot;)
          chordSelection.attr(&quot;display&quot;, &quot;block&quot;)
          chartState.lastFocused = chordGroupId
        }
      })

    $(`.${styles.ribbon}`).tooltip({
      track: true,
    })

    const getGroupText = (chordItem: ChordGroup) =&gt; {
      if (chordItem.endAngle - chordItem.startAngle &lt; 0.07) {
        return &quot;&quot;
      }

      return chartConfig.getChordGroupTitle(chordGroupsIds[chordItem.index])
    }

    const initialGroupData = groupContainer
      .selectAll(`.${styles.chordGroup}`)
      .data()

    groupContainer
      .selectAll&lt;SVGGElement, ChordGroup&gt;(`.${styles.chordGroup}`)
      .data&lt;ChordGroup&gt;(chords.groups, (chordGroup) =&gt; chordGroup.index)
      .join(
        (enter) =&gt; {
          const groupSelection = enter
            .append(&quot;g&quot;)
            .attr(&quot;class&quot;, styles.chordGroup)
            .attr(&quot;title&quot;, (groupItem) =&gt;
              chartConfig.getChordGroupTitle(chordGroupsIds[groupItem.index])
            )
            .style(&quot;filter&quot;, &quot;url(#drop-shadow-groups)&quot;)

          applyOpacityEffect(groupSelection)

          groupSelection
            .append(&quot;path&quot;)
            .attr(&quot;class&quot;, &quot;group-path&quot;)
            .transition()
            .duration(durations.ribbonAnimation)
            .ease(easingFn)
            .attrTween(&quot;d&quot;, (finalGroup) =&gt; {
              const interpolateFn = interpolate&lt;ChordGroup&gt;(
                {
                  ...finalGroup,
                  endAngle: 0,
                  startAngle: 0,
                },
                finalGroup
              )

              return (t) =&gt; arc(interpolateFn(t))!
            })
            .attr(&quot;fill&quot;, (groupItem) =&gt; color(chordGroupsIds[groupItem.index]))
            .attr(&quot;stroke&quot;, &quot;#fff&quot;)

          groupSelection
            .append(&quot;text&quot;)
            .attr(&quot;dy&quot;, -3)
            .append(&quot;textPath&quot;)
            .attr(&quot;xlink:href&quot;, `#${textId}`)
            .attr(&quot;class&quot;, styles.groupText)
            .text(getGroupText)
            .transition()
            .duration(durations.ribbonAnimation)
            .ease(easingFn)
            .attr(
              &quot;startOffset&quot;,
              (groupItem) =&gt; groupItem.startAngle * outerRadius
            )

          groupSelection.on(&quot;click&quot;, (...[, groupItem]) =&gt; {
            const { [groupItem.index]: chordGroupId } = chordGroupsIds
            const latestRibbons = ribbonContainer.selectAll&lt;
              SVGPathElement,
              Chord
            &gt;(`.${styles.ribbon}`)

            if (chartState.lastFocused === chordGroupId) {
              latestRibbons.attr(&quot;display&quot;, () =&gt; &quot;block&quot;)
              chartState.lastFocused = null

              return
            }

            chartState.lastFocused = chordGroupId

            if (
              chartConfig.getDisplayTypeOnGroupClick(chordGroupId) ===
              DisplayType.Source
            ) {
              latestRibbons.attr(&quot;display&quot;, (otherGroupItem) =&gt;
                otherGroupItem.source.index === groupItem.index
                  ? &quot;block&quot;
                  : &quot;none&quot;
              )

              return
            }

            latestRibbons.attr(&quot;display&quot;, (otherGroupItem) =&gt;
              otherGroupItem.target.index === groupItem.index ? &quot;block&quot; : &quot;none&quot;
            )
          })

          $(`.${styles.chordGroup}`).tooltip({
            track: true,
          })

          return groupSelection
        },
        (update) =&gt; {
          update
            .select(&quot;.group-path&quot;)
            .transition()
            .duration(durations.ribbonAnimation)
            .attrTween(&quot;d&quot;, (...[finalGroup, finalGroupIndex]) =&gt; {
              const { [finalGroupIndex]: initialGroup } = initialGroupData
              const interpolateFn = interpolate(initialGroup, finalGroup)

              return (t) =&gt; arc(interpolateFn(t)) as string
            })

          update
            .select(`.${styles.groupText}`)
            .text(getGroupText)
            .transition()
            .duration(durations.ribbonAnimation)
            .attr(
              &quot;startOffset&quot;,
              (groupItem) =&gt; groupItem.startAngle * outerRadius
            )

          return update
        },
        (exit) =&gt; exit.remove()
      )
      .attr(&quot;class&quot;, styles.chordGroup)
  }

  renderItems()

  return {
    renderItems,
  }
}

export { DisplayType, RibbonType, ChartConfig, renderChart }
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:187,&quot;character&quot;:24,&quot;text&quot;:&quot;ribbonType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:188,&quot;character&quot;:4,&quot;text&quot;:&quot;ribbonType&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:188,&quot;character&quot;:15,&quot;text&quot;:&quot;radius&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:188,&quot;character&quot;:41,&quot;text&quot;:&quot;padAngle&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:190,&quot;character&quot;:8,&quot;text&quot;:&quot;ribbonArrow&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:191,&quot;character&quot;:8,&quot;text&quot;:&quot;ribbon&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:262,&quot;character&quot;:10,&quot;text&quot;:&quot;usedRibbon&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:263,&quot;character&quot;:58,&quot;text&quot;:&quot;ribbon&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:263,&quot;character&quot;:67,&quot;text&quot;:&quot;ribbonArrow&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:326,&quot;character&quot;:23,&quot;text&quot;:&quot;usedRibbon&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:340,&quot;character&quot;:29,&quot;text&quot;:&quot;usedRibbon&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/expenses-chord/expenses-chord-chart.ts&quot;,&quot;line&quot;:358,&quot;character&quot;:23,&quot;text&quot;:&quot;usedRibbon&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Sat, 15 Jan 2022 16:59:07 GMT</p>
    </body>
  </html>
  