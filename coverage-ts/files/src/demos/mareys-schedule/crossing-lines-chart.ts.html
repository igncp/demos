
  <!DOCTYPE html>
  <html>
    <head>
      <title>crossing-lines-chart.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/demos/mareys-schedule/crossing-lines-chart.ts</td><td class="">100.00%</td><td class="">95%</td><td class="">636</td><td class="">636</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  D3DragEvent,
  Selection,
  axisBottom,
  axisTop,
  drag as dragD3,
  extent,
  line as lineD3,
  scaleLinear,
  scaleTime,
  select,
} from &quot;d3&quot;
import $ from &quot;jquery&quot;
import &quot;jquery-ui/themes/base/all.css&quot;
import { v1 as uuid } from &quot;uuid&quot;

import * as styles from &quot;./crossing-lines-chart.module.css&quot;
import { MIN_WIDTH } from &quot;./ui-constants&quot;

if (typeof window !== &quot;undefined&quot;) {
  require(&quot;jquery-ui/ui/widgets/tooltip&quot;)
}

type HorizontalMarker = {
  key: string
  label: string
  position: number
}

type Point = {
  horizontalMarker: HorizontalMarker
  lineId: number
  x: Date | null
}

enum LineStyle {
  Black = &quot;Black&quot;,
  Orange = &quot;Orange&quot;,
  Red = &quot;Red&quot;,
}

type Line = {
  id: number
  points: Point[]
}

type CrossingLines = {
  horizontalMarkers: HorizontalMarker[]
  lines: Line[]
}

type TimeRange = [Date, Date]

const lineStyleToClassName: { [key in LineStyle]: string } = {
  [LineStyle.Red]: styles.redLine,
  [LineStyle.Orange]: styles.orangeLine,
  [LineStyle.Black]: styles.blackLine,
}

const filterBlackOpacity = ({
  deviation,
  id,
  slope,
  svg,
}: {
  deviation: number
  id: string
  slope: number
  svg: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
}) =&gt; {
  const defs = svg.append(&quot;defs&quot;)
  const filter = defs
    .append(&quot;filter&quot;)
    .attr(&quot;height&quot;, &quot;500%&quot;)
    .attr(&quot;id&quot;, `drop-shadow-${id}`)
    .attr(&quot;width&quot;, &quot;500%&quot;)
    .attr(&quot;x&quot;, &quot;-200%&quot;)
    .attr(&quot;y&quot;, &quot;-200%&quot;)

  filter
    .append(&quot;feGaussianBlur&quot;)
    .attr(&quot;in&quot;, &quot;SourceAlpha&quot;)
    .attr(&quot;stdDeviation&quot;, deviation)

  filter.append(&quot;feOffset&quot;).attr(&quot;dx&quot;, 1).attr(&quot;dy&quot;, 1)
  filter
    .append(&quot;feComponentTransfer&quot;)
    .append(&quot;feFuncA&quot;)
    .attr(&quot;slope&quot;, slope)
    .attr(&quot;type&quot;, &quot;linear&quot;)

  const feMerge = filter.append(&quot;feMerge&quot;)

  feMerge.append(&quot;feMergeNode&quot;)

  feMerge.append(&quot;feMergeNode&quot;).attr(&quot;in&quot;, &quot;SourceGraphic&quot;)
}

const margin = {
  bottom: 50,
  left: 120,
  right: 50,
  top: 80,
}

const height = 600 - margin.top - margin.bottom

type ChartConfig = {
  chartTitle: string
  crossingLinesData: CrossingLines
  getLineStyle: (line: Line) =&gt; LineStyle
  getLineTitle: (line: Line) =&gt; string
  getPointTitle: (point: Point) =&gt; string
  getXAxisLabel: (date: Date) =&gt; string
  onPointClick: (point: Point) =&gt; void
  rootElId: string
}

type ChartElements = {
  chartTitle: Selection&lt;SVGTextElement, unknown, HTMLElement, unknown&gt;
  clipPath: Selection&lt;SVGRectElement, unknown, HTMLElement, unknown&gt;
  horizongalAxis: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  linesWrapper: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  svg: Selection&lt;SVGSVGElement, unknown, HTMLElement, unknown&gt;
  svgDrag: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  svgG: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  xAxisBottom: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  xAxisTop: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
}

class CrossingLinesChart {
  private readonly elements: ChartElements
  private readonly config: ChartConfig
  private readonly selectors: {
    clipId: string
    filterId: string
    linePathClass: string
    pointCircleClass: string
  }

  private dragX: number

  private latesTimeRange: TimeRange

  public constructor(chartConfig: ChartConfig) {
    this.config = chartConfig

    const { rootElId } = chartConfig
    const rootEl = document.getElementById(rootElId) as HTMLElement

    rootEl.classList.add(styles.mareysScheduleChart)

    this.selectors = {
      clipId: `clip-${uuid().slice(0, 6)}`,
      filterId: `lines-${uuid().slice(0, 6)}`,
      linePathClass: `line-${uuid().slice(0, 6)}`,
      pointCircleClass: `point-${uuid().slice(0, 6)}`,
    }

    const svg = select(`#${rootElId}`).append(&quot;svg&quot;)
    const svgDrag = svg.append(&quot;g&quot;)
    const svgG = svgDrag.append(&quot;g&quot;)
    const chartTitle = svgG.append(&quot;text&quot;)
    const clipPath = svgG
      .append(&quot;defs&quot;)
      .append(&quot;clipPath&quot;)
      .attr(&quot;id&quot;, this.selectors.clipId)
      .append(&quot;rect&quot;)
    const horizongalAxis = svgG
      .append(&quot;g&quot;)
      .attr(&quot;class&quot;, styles.horizontalMarker)
    const xAxisTop = svgG.append(&quot;g&quot;).attr(&quot;class&quot;, `x top ${styles.axis}`)
    const xAxisBottom = svgG
      .append(&quot;g&quot;)
      .attr(&quot;class&quot;, `x bottom ${styles.axis}`)
    const linesWrapper = svgG.append(&quot;g&quot;)

    filterBlackOpacity({
      deviation: 2,
      id: this.selectors.filterId,
      slope: 0.2,
      svg: svgG,
    })

    this.elements = {
      chartTitle,
      clipPath,
      horizongalAxis,
      linesWrapper,
      svg,
      svgDrag,
      svgG,
      xAxisBottom,
      xAxisTop,
    }

    this.dragX = 0

    this.latesTimeRange = [new Date(), new Date()]

    window.addEventListener(&quot;resize&quot;, this.handleResize)
  }

  public refresh(timeRange: TimeRange) {
    this.latesTimeRange = timeRange

    const [timeStart, timeEnd] = timeRange

    const {
      config: { crossingLinesData, rootElId },
      config,
      elements: {
        chartTitle,
        clipPath,
        horizongalAxis,
        linesWrapper,
        svg,
        svgG,
        xAxisBottom,
        xAxisTop,
      },
      selectors: { clipId, filterId, linePathClass, pointCircleClass },
    } = this
    const { horizontalMarkers, lines } = crossingLinesData
    const rootEl = document.getElementById(rootElId) as HTMLElement
    const realWidth =
      rootEl.getBoundingClientRect().width - margin.left - margin.right
    const width = Math.max(realWidth, MIN_WIDTH)
    const x = scaleTime().domain([timeStart, timeEnd]).range([0, width])
    const y = scaleLinear().range([0, height])
    const xAxisTopFn = axisTop&lt;Date&gt;(x)
      .ticks(8)
      .tickFormat(config.getXAxisLabel)
    const xAxisBottomFn = axisBottom&lt;Date&gt;(x)
      .ticks(8)
      .tickFormat(config.getXAxisLabel)

    svg
      .attr(&quot;height&quot;, height + margin.top + margin.bottom)
      .attr(&quot;width&quot;, width + margin.left + margin.right)
    svgG.attr(&quot;transform&quot;, `translate(${margin.left},${margin.top})`)

    chartTitle
      .attr(&quot;class&quot;, styles.chartTitle)
      .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
      .attr(&quot;transform&quot;, `translate(${width / 2},-40)`)
      .text(config.chartTitle)
      .style(&quot;font-weight&quot;, &quot;bold&quot;)

    clipPath
      .attr(&quot;y&quot;, -margin.top)
      .attr(&quot;width&quot;, width)
      .attr(&quot;height&quot;, height + margin.top + margin.bottom)

    y.domain(
      extent(
        horizontalMarkers,
        (horizontalMarker) =&gt; horizontalMarker.position
      ) as [number, number]
    )

    const horizontalMarkersSelection = horizongalAxis
      .selectAll(&quot;g&quot;)
      .data(horizontalMarkers)
      .enter()
      .append(&quot;g&quot;)
      .attr(
        &quot;transform&quot;,
        (horizontalMarker) =&gt; `translate(0,${y(horizontalMarker.position)})`
      )

    horizontalMarkersSelection
      .append(&quot;text&quot;)
      .attr(&quot;x&quot;, -6)
      .attr(&quot;dy&quot;, &quot;.35em&quot;)
      .text((horizontalMarker) =&gt; horizontalMarker.label)

    horizontalMarkersSelection.append(&quot;line&quot;).attr(&quot;x2&quot;, width)
    xAxisTop.call(xAxisTopFn)
    xAxisBottom.attr(&quot;transform&quot;, `translate(0,${height})`).call(xAxisBottomFn)

    const mouseover = (...[, line]: [unknown, Line]) =&gt; {
      select(`.line-${line.id}`).select(&quot;path&quot;).style(&quot;stroke-width&quot;, &quot;5px&quot;)
    }

    const mouseleave = (...[, line]: [unknown, Line]) =&gt; {
      select(`.line-${line.id}`).select(&quot;path&quot;).style(&quot;stroke-width&quot;, &quot;2.5px&quot;)
    }

    const linesSelection = linesWrapper
      .attr(&quot;class&quot;, styles.line)
      .attr(&quot;clip-path&quot;, `url(#${clipId})`)
      .selectAll(&quot;g&quot;)
      .data(lines)
      .enter()
      .append(&quot;g&quot;)
      .attr(&quot;class&quot;, (crossingLine) =&gt; {
        const lineStyle = config.getLineStyle(crossingLine)
        const { [lineStyle]: lineClass } = lineStyleToClassName

        return `${lineClass} line-${crossingLine.id}`
      })
      .on(&quot;mouseover&quot;, mouseover)
      .on(&quot;mouseleave&quot;, mouseleave)

    const line = lineD3&lt;Point&gt;()
      .x((point) =&gt; x(point.x!))
      .y((point) =&gt; y(point.horizontalMarker.position))

    linesSelection.append(&quot;path&quot;)

    const lineGroup = linesWrapper.selectAll(&quot;g&quot;)

    lineGroup
      .selectAll&lt;SVGPathElement, Line&gt;(&quot;path&quot;)
      .attr(&quot;d&quot;, (crossingLine) =&gt; line(crossingLine.points))
      .attr(&quot;class&quot;, linePathClass)
      .attr(&quot;title&quot;, config.getLineTitle)

    linesSelection
      .selectAll(&quot;circle&quot;)
      .data((crossingLine) =&gt; crossingLine.points)
      .enter()
      .append(&quot;circle&quot;)
      .style(&quot;cursor&quot;, &quot;pointer&quot;)
      .on(&quot;click&quot;, (...[, point]) =&gt; {
        config.onPointClick(point)
      })
      .style(&quot;filter&quot;, `url(#drop-shadow-${filterId})`)
      .attr(&quot;r&quot;, &quot;5px&quot;)
      .attr(&quot;class&quot;, pointCircleClass)

    lineGroup
      .selectAll&lt;SVGCircleElement, Point&gt;(&quot;circle&quot;)
      .attr(
        &quot;transform&quot;,
        (point) =&gt;
          `translate(${x(point.x!)},${y(point.horizontalMarker.position)})`
      )
      .attr(&quot;title&quot;, (point) =&gt; config.getPointTitle(point))

    $(`.${linePathClass}`).tooltip({
      track: true,
    })

    $(`.${pointCircleClass}`).tooltip({
      track: true,
    })

    this.setupDrag(realWidth)
  }

  private setupDrag(containerWidth: number) {
    const { elements } = this

    const canUseDrag = containerWidth &lt; MIN_WIDTH

    const updateDrag = () =&gt; {
      if (canUseDrag) {
        this.dragX = Math.min(0, this.dragX)
        this.dragX = Math.max(containerWidth - MIN_WIDTH, this.dragX)
      } else {
        this.dragX = 0
      }

      this.elements.svgDrag.attr(&quot;transform&quot;, `translate(${this.dragX},0)`)
    }

    const dragHandler = (
      dragEvent: D3DragEvent&lt;SVGSVGElement, unknown, unknown&gt;
    ) =&gt; {
      if (!canUseDrag) {
        return
      }

      this.dragX += dragEvent.dx

      updateDrag()
    }

    const dragBehavior = dragD3&lt;SVGSVGElement, unknown&gt;().on(
      &quot;drag&quot;,
      dragHandler
    )

    elements.svg
      .style(&quot;cursor&quot;, canUseDrag ? &quot;move&quot; : &quot;default&quot;)
      .call(dragBehavior)
      .on(&quot;drag&quot;, dragHandler)

    updateDrag()
  }

  private readonly handleResize = () =&gt; {
    this.refresh(this.latesTimeRange)
  }
}

export {
  ChartConfig,
  CrossingLinesChart,
  HorizontalMarker,
  LineStyle,
  TimeRange,
}
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Wed, 12 Jan 2022 00:26:29 GMT</p>
    </body>
  </html>
  