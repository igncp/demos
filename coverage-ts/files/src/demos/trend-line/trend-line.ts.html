
  <!DOCTYPE html>
  <html>
    <head>
      <title>trend-line.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/demos/trend-line/trend-line.ts</td><td class="">100.00%</td><td class="">90%</td><td class="">364</td><td class="">364</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  Line,
  axisBottom,
  axisLeft,
  line as d3Line,
  extent,
  max,
  min,
  range,
  scaleLinear,
  scaleQuantile,
  scaleTime,
  select,
  selectAll,
  timeParse,
  tsv,
} from &quot;d3&quot;

import * as styles from &quot;./trend-line.module.css&quot;

type InitialDataItem = {
  occurred: string
  value: string
}

type DataItem = {
  occurred: Date
  value: number
}

const fetchData = async (): Promise&lt;DataItem[]&gt; =&gt; {
  const result = (await tsv(
    `${ROOT_PATH}data/d3js/trend-line/data.tsv`
  )) as InitialDataItem[]

  const timeFormat = timeParse(&quot;%Y-%m-%d&quot;)

  const data = result.map((d) =&gt; ({
    occurred: timeFormat(d.occurred) as Date,
    value: +d.value,
  }))

  return data
}

const margin = {
  bottom: 50,
  left: 50,
  right: 50,
  top: 50,
}

const height = 500 - margin.top - margin.bottom

const animationTime = 2000

const getInterpolation = (data: DataItem[], line: Line&lt;DataItem&gt;) =&gt; {
  const interpolate = scaleQuantile()
    .domain([0, 1])
    .range(range(1, data.length + 1))

  return (t: number): string =&gt; {
    const interpolatedLine = data.slice(0, interpolate(t))

    return line(interpolatedLine)!
  }
}

const linearRegression = (data: DataItem[]) =&gt; {
  const lr: { intercept?: number; r2?: number; slope?: number } = {}
  const { length: n } = data

  let sumX = 0
  let sumY = 0
  let sumXY = 0
  let sumXX = 0
  let sumYY = 0

  data.forEach((d) =&gt; {
    sumX += d.occurred.getTime()
    sumY += d.value
    sumXX += d.occurred.getTime() * d.occurred.getTime()
    sumYY += d.value * d.value
    sumXY += d.occurred.getTime() * d.value
  })
  lr.slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX)
  lr.intercept = (sumY - lr.slope * sumX) / n
  lr.r2 = Math.pow(
    (n * sumXY - sumX * sumY) /
      Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY)),
    2
  )

  return lr
}

const renderGraph = ({
  data,
  initialZoomed,
  rootElId,
}: {
  data: DataItem[]
  initialZoomed: boolean
  rootElId: string
}) =&gt; {
  const el = document.getElementById(rootElId) as HTMLElement

  el.classList.add(styles.trendLineChart)

  const width = el.getBoundingClientRect().width - margin.left - margin.right

  const renderContent = (isZoomed: boolean) =&gt; {
    const svg = select(`#${rootElId}`)
      .text(&quot;&quot;)
      .append(&quot;svg&quot;)
      .attr(&quot;height&quot;, height + margin.top + margin.bottom)
      .attr(&quot;width&quot;, width + margin.left + margin.right)
      .append(&quot;g&quot;)
      .attr(&quot;transform&quot;, `translate(${margin.left},${margin.right})`)

    const x = scaleTime().range([0, width])
    const y = scaleLinear().range([height, 0])
    const xAxis = axisBottom(x)
    const yAxis = axisLeft(y)

    const line = d3Line&lt;DataItem&gt;()
      .x((d) =&gt; x(d.occurred))
      .y((d) =&gt; y(d.value))

    x.domain(extent(data, (d) =&gt; d.occurred) as [Date, Date])
    y.domain([
      isZoomed ? (min(data, (d) =&gt; d.value) as number) : 0,
      max(data, (d) =&gt; d.value) as number,
    ])

    svg
      .append(&quot;g&quot;)
      .attr(&quot;class&quot;, `x ${styles.axis}`)
      .attr(&quot;transform&quot;, `translate(0,${height})`)
      .call(xAxis)
    svg.append(&quot;g&quot;).attr(&quot;class&quot;, `y ${styles.axis}`).call(yAxis)

    svg
      .append(&quot;path&quot;)
      .datum(data)
      .transition()
      .duration(animationTime)
      .attrTween(&quot;d&quot;, () =&gt; getInterpolation(data, line))
      .attr(&quot;class&quot;, styles.line)

    const lr = linearRegression(data)

    const regressionLine = d3Line&lt;DataItem&gt;()
      .x((d) =&gt; x(d.occurred))
      .y((d) =&gt; {
        const tmp = lr.intercept! + lr.slope! * +d.occurred

        return y(tmp)
      })

    svg
      .append(&quot;path&quot;)
      .datum(data)
      .transition()
      .delay(animationTime)
      .duration(animationTime)
      .attrTween(&quot;d&quot;, () =&gt; getInterpolation(data, regressionLine))
      .attr(&quot;class&quot;, styles.rline)

    svg
      .append(&quot;text&quot;)
      .attr(&quot;transform&quot;, `translate(${width * 0.7},${height * 0.7})`)
      .style(&quot;opacity&quot;, 0)
      .transition()
      .delay(animationTime * 2)
      .text(`Slope: ${lr.slope!.toExponential(3)}`)
      .style(&quot;opacity&quot;, 1)
  }

  renderContent(initialZoomed)

  return {
    renderContent,
  }
}

const main = async () =&gt; {
  const rootElId = &quot;chart&quot;
  const data = await fetchData()

  const getIsZoomed = () =&gt;
    (document.querySelector(&#x27;input[value=&quot;zoom&quot;]&#x27;) as HTMLInputElement).checked

  const { renderContent } = renderGraph({
    data,
    initialZoomed: getIsZoomed(),
    rootElId,
  })

  selectAll(&#x27;input[name=&quot;mode&quot;]&#x27;).on(&quot;change&quot;, () =&gt; {
    const isZoomed = getIsZoomed()

    renderContent(isZoomed)
  })
}

export default main
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 05 Aug 2021 23:16:53 GMT</p>
    </body>
  </html>
  