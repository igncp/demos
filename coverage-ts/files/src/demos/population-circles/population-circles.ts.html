
  <!DOCTYPE html>
  <html>
    <head>
      <title>population-circles.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/demos/population-circles/population-circles.ts</td><td class="">99.06%</td><td class="">90%</td><td class="">742</td><td class="">735</td><td class="">7</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  BaseType,
  D3ZoomEvent,
  HierarchyCircularNode,
  Selection,
  Transition,
  easeCircleInOut,
  easeSinInOut,
  hierarchy,
  json,
  pack,
  scaleOrdinal,
  schemeSet3,
  select,
  zoom,
} from &quot;d3&quot;
import anime from &quot;animejs&quot;
import hotkeys from &quot;hotkeys-js&quot;
import qs from &quot;query-string&quot;
import chroma from &quot;chroma-js&quot;

import * as styles from &quot;./population-circles.module.css&quot;

type PopulationRecord = {
  count: number
  date: string
}

type Municipality = {
  name: string
  values: {
    females: PopulationRecord[]
    males: PopulationRecord[]
    total: PopulationRecord[]
  }
}

type MunicipalityWithAnimation = Municipality &amp; {
  hoverAnimation?: anime.AnimeInstance | null
}

type MunicipalityNode = HierarchyCircularNode&lt;MunicipalityWithAnimation&gt;
type MunicipalityTransition = Transition&lt;
  BaseType,
  MunicipalityNode,
  BaseType,
  MunicipalityNode
&gt;

type PopulationType = keyof Municipality[&quot;values&quot;]

type State = {
  lastPosition: { k: number; x: number; y: number }
  populationRange: [number, number]
  populationType: PopulationType
  timeRangeIndex: number
}

const fetchData = () =&gt;
  (json(
    `${ROOT_PATH}data/d3js/population-circles/data.json`
  ) as unknown) as Promise&lt;Municipality[]&gt;

const dropShadowBaseId = &quot;dropShadowBase&quot;

const margin = {
  bottom: 0,
  left: 0,
  right: 0,
  top: 70,
}
const height = 400

const formatPopulation = (populationNum: number) =&gt;
  Number(populationNum.toFixed(0)).toLocaleString(undefined, {
    maximumFractionDigits: 0,
    minimumFractionDigits: 0,
  })

const typeNouns: Record&lt;string, string&gt; = {
  females: &quot;females&quot;,
  males: &quot;males&quot;,
  total: &quot;people&quot;,
}

const getYearStr = (dateStr: string) =&gt; new Date(dateStr).getFullYear()

type RenderChart = (o: {
  municipalities: Municipality[]
  onClick: (m: Municipality) =&gt; void
  rootElId: string
}) =&gt; {
  onPopulationPercentilesChange: (vals: [number, number]) =&gt; void
  onTimeSeriesChange: (val: number) =&gt; void
  onTypeChange: (type: string) =&gt; void
}

const renderChart: RenderChart = ({ municipalities, onClick, rootElId }) =&gt; {
  const chartEl = document.getElementById(rootElId) as HTMLElement
  const { width } = chartEl.getBoundingClientRect()

  const state: State = {
    lastPosition: { k: 1, x: 0, y: 0 },
    populationRange: [0, 1],
    populationType: &quot;total&quot;,
    timeRangeIndex: 0,
  }

  // this zoom function is not working well in all directions
  const zoomed = function (
    this: SVGSVGElement,
    zoomEvent: D3ZoomEvent&lt;SVGSVGElement, unknown&gt;
  ) {
    const transition = select(this).transition().duration(150)
    const { lastPosition } = state
    let {
      transform: { x, y },
    } = zoomEvent
    const {
      transform: { k },
    } = zoomEvent

    if (k !== state.lastPosition.k) {
      x = lastPosition.x
      y = lastPosition.y
    }

    transition.attr(&quot;transform&quot;, `translate(${x}, ${y}) scale(${k})`)

    lastPosition.k = k
    lastPosition.x = x
    lastPosition.y = y
  }

  const color = scaleOrdinal&lt;string, string&gt;()
    .domain(municipalities.map((municipality) =&gt; municipality.name))
    .range(schemeSet3)

  const zoomBehavior = zoom&lt;SVGSVGElement, unknown&gt;()
    .extent([
      [0, 0],
      [width / 2, height / 2],
    ])
    .on(&quot;end&quot;, zoomed)

  const svg = select(`#${rootElId}`)
    .append(&quot;svg&quot;)
    .attr(&quot;viewBox&quot;, [0, 0, width, height + margin.top].join(&quot;, &quot;))
    .attr(&quot;font-size&quot;, 10)
    .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
    .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
    .call(zoomBehavior)

  addDropShadow(svg, dropShadowBaseId, 0.5, 2)

  const header = svg
    .append(&quot;text&quot;)
    .attr(&quot;class&quot;, styles.header)
    .text(&quot;&quot;)
    .attr(&quot;transform&quot;, `translate(${width / 2}, 50)`)

  const svgContent = svg
    .append(&quot;g&quot;)
    .attr(&quot;transform&quot;, `translate(${margin.left}, ${margin.top})`)

  const transitionChart = () =&gt; {
    const itemsWithCount = municipalities.filter((municipality) =&gt; {
      const {
        values: {
          [state.populationType]: { [state.timeRangeIndex]: dataItem },
        },
      } = municipality

      return !!(dataItem as unknown)
    })
    const dataValues = itemsWithCount.map((municipality) =&gt; {
      const {
        values: {
          [state.populationType]: { [state.timeRangeIndex]: dataItem },
        },
      } = municipality

      return dataItem.count
    })
    const valueToIdx = dataValues.reduce((acc, val, idx) =&gt; {
      acc[val] = acc[val] ?? []
      acc[val]!.push(idx)

      return acc
    }, {} as { [k: string]: number[] | undefined })
    const sortedDataValues = dataValues.sort((a, b) =&gt; a - b)

    const percentiles = sortedDataValues.reduce((acc, val, idx) =&gt; {
      const percentile = idx / sortedDataValues.length
      const { [val]: unsortedIndexes } = valueToIdx

      unsortedIndexes!.forEach((idx2) =&gt; {
        acc[idx2] = percentile
      })

      return acc
    }, [] as number[])

    const filteredData = itemsWithCount.filter((_municipality, idx) =&gt; {
      const { [idx]: percentile } = percentiles

      return (
        typeof percentile === &quot;number&quot; &amp;&amp;
        percentile &gt;= state.populationRange[0] &amp;&amp;
        percentile &lt;= state.populationRange[1]
      )
    })

    const structure = hierarchy({
      children: filteredData,
      name: &quot;&quot;,
      values: {
        females: [],
        males: [],
        total: [],
      } as Municipality[&quot;values&quot;],
    }).sum((municipality) =&gt; {
      if (!(municipality.values as unknown)) {
        return 1
      }

      const {
        values: {
          [state.populationType]: { [state.timeRangeIndex]: dataItem },
        },
      } = municipality

      return !(dataItem as unknown) ? 0 : dataItem.count
    })
    const root = pack&lt;MunicipalityWithAnimation&gt;()
      .size(
        state.populationType === &quot;total&quot;
          ? [width, height]
          : [width / 2, height / 2]
      )
      .padding(3)(structure)

    const leaves = root.leaves()

    const {
      data: {
        values: {
          [state.populationType]: {
            [state.timeRangeIndex]: { date },
          },
        },
      },
    } = leaves[0]

    const year = getYearStr(date)
    const populationTotal = filteredData.reduce(
      (acc, item) =&gt;
        acc +
        item.values[state.populationType as PopulationType][
          state.timeRangeIndex
        ].count,
      0
    )
    const populationText = `${formatPopulation(populationTotal)} ${
      typeNouns[state.populationType]
    }`

    const { length: totalNum } = leaves.filter(
      (leafItem) =&gt;
        leafItem.data.values[state.populationType].length &gt;=
        state.timeRangeIndex + 1
    )

    header.text(
      `Population in Malaga: ${year} - ${populationText}${
        state.populationRange[0] === 0 &amp;&amp; state.populationRange[1] === 1
          ? &quot;&quot;
          : ` - From ${(state.populationRange[0] * 100).toFixed(
              0
            )} percentile to ${(state.populationRange[1] * 100).toFixed(
              0
            )} percentile`
      } - ${totalNum} municipalities`
    )

    const getDataKey = (municipalityNode: unknown) =&gt;
      (municipalityNode as MunicipalityNode).data.name!

    const leaf = svgContent.selectAll(&quot;.leaf&quot;).data(leaves, getDataKey)

    leaf.exit().remove()

    const getTitle = (municipalityNode: MunicipalityNode) =&gt; {
      const {
        data: {
          values: {
            [state.populationType]: { [state.timeRangeIndex]: dataItem },
          },
        },
      } = municipalityNode

      if (!dataItem as unknown) {
        return &quot;&quot;
      }

      const { [state.populationType]: itemsName } = typeNouns

      return `${municipalityNode.data.name} - ${formatPopulation(
        dataItem.count
      )} ${itemsName} - ${getYearStr(dataItem.date)}`
    }

    leaf
      .attr(&quot;title&quot;, getTitle)
      .transition()
      .duration(1000)
      .ease(easeCircleInOut)
      .attr(&quot;transform&quot;, (municipalityNode) =&gt; {
        if (state.populationType !== &quot;total&quot;) {
          return `translate(${municipalityNode.x + width / 4},${
            municipalityNode.y + height / 4
          })`
        }

        return `translate(${municipalityNode.x + 1},${municipalityNode.y + 1})`
      })

    const enter = leaf
      .enter()
      .append(&quot;g&quot;)
      .attr(&quot;class&quot;, &quot;leaf&quot;)
      .attr(&quot;title&quot;, getTitle)
      .attr(
        &quot;transform&quot;,
        (municipalityNode) =&gt;
          `translate(${municipalityNode.x + 1},${municipalityNode.y + 1})`
      )
      .on(&quot;mouseenter&quot;, function (_event, municipalityNode) {
        const selection = select(this).select(`.${styles.circle}`)

        select(this)
          .select(&quot;.letter&quot;)
          .attr(&quot;filter&quot;, `url(#${dropShadowBaseId})`)

        const hoverAnimation = anime({
          complete: () =&gt; {
            municipalityNode.data.hoverAnimation = null
          },
          strokeWidth: &quot;5px&quot;,
          targets: [selection.node()],
        })

        municipalityNode.data = {
          ...municipalityNode.data,
          hoverAnimation,
        }
      })
      .on(&quot;mouseleave&quot;, function (_event, municipalityNode) {
        const selection = select(this).select(`.${styles.circle}`)

        select(this).select(&quot;.letter&quot;).attr(&quot;filter&quot;, null)

        const {
          data: { hoverAnimation },
        } = municipalityNode

        if (hoverAnimation) {
          hoverAnimation.seek(0)
          anime.remove(selection.node())
          municipalityNode.data = {
            ...municipalityNode.data,
            hoverAnimation: null,
          }
        }

        anime({
          strokeWidth: &quot;0px&quot;,
          targets: [selection.node()],
        })
      })
      .on(&quot;click&quot;, (_event, municipalityNode) =&gt; {
        onClick(municipalityNode.data)
      })

    const generateColor = (municipalityNode: MunicipalityNode) =&gt;
      color(municipalityNode.data.name)

    const generateDarkerColor = (municipalityNode: MunicipalityNode) =&gt; {
      const baseColor = generateColor(municipalityNode)

      return chroma(baseColor).darken(1.5).hex()
    }

    const setupLetter = (
      letter:
        | MunicipalityTransition
        | Selection&lt;SVGTextElement, MunicipalityNode, SVGGElement, unknown&gt;
    ) =&gt; {
      const el = letter.text(
        (municipalityNode) =&gt; municipalityNode.data.name[0]!
      ) as MunicipalityTransition

      el.style(
        &quot;font-size&quot;,
        (municipalityNode) =&gt; `${municipalityNode.r.toFixed(0)}px`
      )
        .attr(&quot;dy&quot;, (municipalityNode) =&gt; municipalityNode.r / 3)
        .attr(&quot;fill&quot;, generateDarkerColor)
    }

    const setupCircle = (
      circle:
        | MunicipalityTransition
        | Selection&lt;SVGCircleElement, MunicipalityNode, SVGGElement, unknown&gt;
    ) =&gt; {
      const elem = circle.attr(
        &quot;r&quot;,
        (municipalityNode) =&gt; municipalityNode.r!
      ) as MunicipalityTransition

      elem.attr(&quot;fill&quot;, generateColor).attr(&quot;stroke&quot;, generateDarkerColor)
    }

    setupCircle(enter.append(&quot;circle&quot;).attr(&quot;class&quot;, styles.circle))

    setupLetter(enter.append(&quot;text&quot;).attr(&quot;class&quot;, &quot;letter&quot;))

    const forwardData = (municipalityNode: MunicipalityNode) =&gt; municipalityNode

    const circles = leaf
      .selectAll(`.${styles.circle}`)
      .data(forwardData, getDataKey)
    const texts = leaf.selectAll(&quot;.letter&quot;).data(forwardData, getDataKey)

    setupCircle(circles.transition().duration(1000).ease(easeSinInOut))

    setupLetter(texts.transition().duration(1000).ease(easeSinInOut))

    $(&quot;.leaf&quot;).tooltip({
      track: true,
    })
  }

  transitionChart()

  return {
    onPopulationPercentilesChange: (newValues: [number, number]) =&gt; {
      state.populationRange = newValues
      transitionChart()
    },
    onTimeSeriesChange: (newIndex: number) =&gt; {
      state.timeRangeIndex = newIndex
      transitionChart()
    },
    onTypeChange: (newType: string) =&gt; {
      state.populationType = newType as PopulationType
      transitionChart()
    },
  }
}

const addDropShadow = (
  svg: Selection&lt;SVGSVGElement, unknown, HTMLElement, unknown&gt;,
  name: string,
  slope: number,
  deviation: number
) =&gt; {
  svg.append(&quot;filter&quot;).html(`
&lt;filter id=&quot;${name}&quot; height=&quot;130%&quot;&gt;
  &lt;feGaussianBlur in=&quot;SourceAlpha&quot; stdDeviation=&quot;${deviation}&quot;/&gt;
  &lt;feOffset dx=&quot;2&quot; dy=&quot;2&quot; result=&quot;offsetblur&quot;/&gt;
  &lt;feComponentTransfer&gt;
    &lt;feFuncA type=&quot;linear&quot; slope=&quot;${slope}&quot;/&gt;
  &lt;/feComponentTransfer&gt;
  &lt;feMerge&gt;
    &lt;feMergeNode/&gt;
    &lt;feMergeNode in=&quot;SourceGraphic&quot;/&gt;
  &lt;/feMerge&gt;
&lt;/filter&gt;
`)
}

const main = async () =&gt; {
  hotkeys(&quot;control&quot;, () =&gt; {})

  const municipalities = await fetchData()

  const {
    onPopulationPercentilesChange,
    onTimeSeriesChange,
    onTypeChange,
  } = renderChart({
    municipalities,
    onClick: (municipality) =&gt; {
      if (!hotkeys.isPressed(&quot;control&quot;)) {
        return
      }

      window.open(
        `https://www.google.com/search?${qs.stringify({
          q: `Malaga ${municipality.name}`,
        })}`
      )
    },
    rootElId: &quot;chart&quot;,
  })

  select(&quot;form&quot;).on(&quot;change&quot;, (e) =&gt; {
    onTypeChange(e.target.value)
  })

  $(&quot;.population-slider&quot;).slider({
    change: (_event, { values }) =&gt; {
      const newValues = (values as [number, number]).map((v) =&gt; v / 100) as [
        number,
        number
      ]

      onPopulationPercentilesChange(newValues)
    },
    range: true,
    values: [0, 100],
  })

  const max = municipalities[0].values.total.length - 1

  $(&quot;.time-slider&quot;).slider({
    change: (_event, { value }) =&gt; {
      onTimeSeriesChange(value as number)
    },
    max,
    min: 0,
    value: 0,
  })
}

export default main
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/demos/population-circles/population-circles.ts&quot;,&quot;line&quot;:337,&quot;character&quot;:34,&quot;text&quot;:&quot;_event&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/population-circles/population-circles.ts&quot;,&quot;line&quot;:357,&quot;character&quot;:34,&quot;text&quot;:&quot;_event&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/population-circles/population-circles.ts&quot;,&quot;line&quot;:380,&quot;character&quot;:20,&quot;text&quot;:&quot;_event&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/population-circles/population-circles.ts&quot;,&quot;line&quot;:507,&quot;character&quot;:31,&quot;text&quot;:&quot;e&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/population-circles/population-circles.ts&quot;,&quot;line&quot;:508,&quot;character&quot;:17,&quot;text&quot;:&quot;e&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/population-circles/population-circles.ts&quot;,&quot;line&quot;:508,&quot;character&quot;:19,&quot;text&quot;:&quot;target&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/population-circles/population-circles.ts&quot;,&quot;line&quot;:508,&quot;character&quot;:26,&quot;text&quot;:&quot;value&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Mon, 02 Aug 2021 22:36:00 GMT</p>
    </body>
  </html>
  