
  <!DOCTYPE html>
  <html>
    <head>
      <title>circles-chart.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/demos/concentric-circles/circles-chart.ts</td><td class="">100.00%</td><td class="">95%</td><td class="">484</td><td class="">484</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  D3DragEvent,
  Selection,
  drag,
  interpolateCool,
  max,
  scaleLinear,
  scaleOrdinal,
  select,
} from &quot;d3&quot;
import { v1 as uuidv1 } from &quot;uuid&quot;

const margin = {
  bottom: 20,
  left: 20,
  right: 20,
  top: 20,
}

// https://stackoverflow.com/questions/2916081/zoom-in-on-a-point-using-scale-and-translate
const getNewDrag = ({
  baseZoom,
  newZoom,
  prevDragX,
  prevDragY,
  prevZoom,
  zoomPoint,
}: {
  baseZoom: number
  newZoom: number
  prevDragX: number
  prevDragY: number
  prevZoom: number
  zoomPoint: { x: number; y: number }
}) =&gt; {
  const scalechange = (newZoom - prevZoom) / baseZoom
  const offsetX = -(zoomPoint.x * scalechange)
  const offsetY = -(zoomPoint.y * scalechange)

  return {
    x: prevDragX + offsetX,
    y: prevDragY + offsetY,
  }
}

type ChartConfig&lt;ChartData&gt; = Readonly&lt;{
  chartDescription: string
  circlesData: ChartData[]
  getCircleId: (circle: ChartData) =&gt; string
  getCircleTitle: (circle: ChartData) =&gt; string
  getCircleValue: (circle: ChartData) =&gt; number
  rootElId: string
}&gt;

type ChartElements&lt;ChartData&gt; = Readonly&lt;{
  descriptionSel: Selection&lt;SVGTextElement, ChartData, HTMLElement, unknown&gt;
  dragSel: Selection&lt;SVGGElement, ChartData, HTMLElement, unknown&gt;
  gSel: Selection&lt;SVGGElement, ChartData, HTMLElement, unknown&gt;
  rootSel: Selection&lt;HTMLElement, ChartData, HTMLElement, unknown&gt;
  svgSel: Selection&lt;SVGSVGElement, ChartData, HTMLElement, unknown&gt;
}&gt;

class CirclesChart&lt;ChartData&gt; {
  public static defaultZoom = 10

  private readonly config: ChartConfig&lt;ChartData&gt;
  private readonly elements: ChartElements&lt;ChartData&gt;
  private readonly circleClass: string
  private readonly state: {
    dragX: number
    dragY: number
    selectedCircles: Record&lt;string, boolean&gt;
    zoom: number
  } = {
    dragX: 0,
    dragY: 0,
    selectedCircles: {},
    zoom: CirclesChart.defaultZoom,
  }

  private constructor(config: ChartConfig&lt;ChartData&gt;) {
    this.config = config

    const rootSel = select&lt;HTMLElement, ChartData&gt;(`#${config.rootElId}`)
    const svgSel = rootSel.append(&quot;svg&quot;)
    const dragSel = svgSel.append(&quot;g&quot;)
    const gSel = dragSel.append(&quot;g&quot;)
    const descriptionSel = gSel
      .append(&quot;text&quot;)
      .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
      .attr(&quot;width&quot;, &quot;20px&quot;)

    this.circleClass = `name-circle-${uuidv1().slice(0, 6)}`

    this.elements = {
      descriptionSel,
      dragSel,
      gSel,
      rootSel,
      svgSel,
    }

    this.setupDrag()
    this.render()

    window.addEventListener(&quot;resize&quot;, this.handleResize)
  }

  public static renderChart&lt;ChartData&gt;(config: ChartConfig&lt;ChartData&gt;) {
    return new CirclesChart(config)
  }

  public teardown() {
    window.removeEventListener(&quot;resize&quot;, this.handleResize)
  }

  public setZoom(zoom: number) {
    const { height, width } = this.getDimensions()

    const newDrag = getNewDrag({
      baseZoom: CirclesChart.defaultZoom,
      newZoom: zoom,
      prevDragX: this.state.dragX,
      prevDragY: this.state.dragY,
      prevZoom: this.state.zoom,
      zoomPoint: { x: width / 2, y: height / 2 },
    })

    this.state.zoom = zoom
    this.state.dragX = newDrag.x
    this.state.dragY = newDrag.y

    this.updateDrag()
  }

  private updateDrag() {
    const {
      elements: { dragSel },
    } = this

    dragSel.attr(
      &quot;transform&quot;,
      `translate(${this.state.dragX},${this.state.dragY}) scale(${
        this.state.zoom / CirclesChart.defaultZoom
      })`
    )
  }

  private setupDrag() {
    const {
      elements: { svgSel },
    } = this

    const dragHandler = drag&lt;SVGSVGElement, ChartData&gt;().on(
      &quot;drag&quot;,
      (dragEvent: D3DragEvent&lt;SVGSVGElement, unknown, unknown&gt;) =&gt; {
        this.state.dragX += dragEvent.dx
        this.state.dragY += dragEvent.dy

        this.updateDrag()
      }
    )

    svgSel.style(&quot;cursor&quot;, &quot;move&quot;).call(dragHandler).on(&quot;wheel&quot;, null)
  }

  private getDimensions() {
    const {
      config: { circlesData, getCircleValue, rootElId },
    } = this
    const rootEl = document.getElementById(rootElId) as HTMLElement
    const { width: elWidth } = rootEl.getBoundingClientRect()

    const width = elWidth - margin.left - margin.right
    const height = max(circlesData, getCircleValue)! * 2.5

    return {
      height,
      width,
    }
  }

  private render() {
    const {
      config: {
        chartDescription,
        circlesData,
        getCircleId,
        getCircleTitle,
        getCircleValue,
      },
      elements,
    } = this

    this.updateDrag()

    const maxValue = max(circlesData, getCircleValue) as number
    const colorScale = scaleOrdinal&lt;number, number&gt;()
      .domain([0, maxValue])
      .range([0, 0.5])
    const clickedColor = &quot;orange&quot;

    const colorize = (circle: ChartData) =&gt; {
      const circleId = getCircleId(circle)

      if (this.state.selectedCircles[circleId]) {
        return clickedColor
      }

      const circleValue = getCircleValue(circle)

      const normalized = colorScale(circleValue)

      return interpolateCool(normalized)
    }

    const { height, width } = this.getDimensions()

    elements.svgSel
      .attr(&quot;width&quot;, width + margin.left + margin.right)
      .attr(&quot;height&quot;, height + margin.left + margin.right)

    // It sorts from bigger to smaller value for the hover to work
    const sortedData = circlesData
      .slice(0)
      .sort(
        (...[circleA, circleB]) =&gt;
          getCircleValue(circleB) - getCircleValue(circleA)
      )

    const groupUpdates = elements.gSel
      .selectAll&lt;SVGGElement, ChartData&gt;(&quot;.circle-group&quot;)
      .data(sortedData, getCircleId)

    groupUpdates
      .enter()
      .append(&quot;g&quot;)
      .attr(&quot;class&quot;, &quot;circle-group&quot;)
      .append(&quot;circle&quot;)
      .attr(&quot;class&quot;, this.circleClass)

    groupUpdates.exit().remove()

    const maxRadius = Math.min(height / 2, width / 2)
    const scaleRadius = scaleLinear()
      .domain([0, maxValue])
      .range([0, maxRadius])

    const circles = elements.gSel.selectAll&lt;SVGCircleElement, ChartData&gt;(
      `.${this.circleClass}`
    )

    const {
      state: { selectedCircles },
    } = this

    const bigStroke = &quot;4px&quot;

    const getStrokeWidth = (circle: ChartData) =&gt; {
      const id = getCircleId(circle)

      return selectedCircles[id] ? bigStroke : &quot;2px&quot;
    }

    circles
      .attr(&quot;cx&quot;, width / 2)
      .attr(&quot;cy&quot;, height / 2)
      .style(&quot;fill&quot;, &quot;rgba(0, 0, 0, 0)&quot;)
      .style(&quot;stroke&quot;, colorize)
      .style(&quot;stroke-width&quot;, getStrokeWidth)
      .attr(&quot;r&quot;, (circle) =&gt; scaleRadius(getCircleValue(circle)))
      .on(&quot;mouseenter&quot;, function handleMouseEnter() {
        select&lt;SVGCircleElement, ChartData&gt;(this)
          .style(&quot;stroke&quot;, clickedColor)
          .style(&quot;stroke-width&quot;, bigStroke)
      })
      .on(&quot;mouseleave&quot;, function handleMouseLeave() {
        select&lt;SVGCircleElement, ChartData&gt;(this)
          .style(&quot;stroke&quot;, colorize)
          .style(&quot;stroke-width&quot;, getStrokeWidth)
      })
      .on(&quot;click&quot;, function handleClick(...[, circle]) {
        const id = getCircleId(circle)

        selectedCircles[id] = !selectedCircles[id]

        select&lt;SVGCircleElement, ChartData&gt;(this)
          .style(&quot;stroke&quot;, colorize)
          .style(&quot;stroke-width&quot;, getStrokeWidth)
      })
      .append(&quot;title&quot;)
      .text(getCircleTitle)

    elements.descriptionSel
      .text(chartDescription)
      .attr(&quot;transform&quot;, `translate(${width / 2},${height + 25})`)
  }

  private readonly handleResize = () =&gt; {
    this.render()
  }
}

const _test = process.env.NODE_ENV === &quot;test&quot; ? { getNewDrag } : null

export { CirclesChart, ChartConfig, _test }
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Sat, 15 Jan 2022 16:59:07 GMT</p>
    </body>
  </html>
  