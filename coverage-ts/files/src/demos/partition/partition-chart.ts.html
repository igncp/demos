
  <!DOCTYPE html>
  <html>
    <head>
      <title>partition-chart.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/demos/partition/partition-chart.ts</td><td class="">100.00%</td><td class="">95%</td><td class="">604</td><td class="">604</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  D3DragEvent,
  HierarchyRectangularNode,
  Selection,
  arc as arcD3,
  drag as dragD3,
  easeBounce,
  easeLinear,
  hierarchy,
  interpolate,
  partition as partitionD3,
  scaleOrdinal,
  schemePastel2,
  select,
} from &quot;d3&quot;

type Node&lt;NodeData&gt; = NodeData &amp; {
  chidren: Array&lt;Node&lt;NodeData&gt;&gt;
}

type HierarchyRectNode&lt;ChartData&gt; = HierarchyRectangularNode&lt;Node&lt;ChartData&gt;&gt;

enum PartitionType {
  Count = &quot;count&quot;,
  Size = &quot;size&quot;,
}

const height = 700
const overColor = &quot;#de7c03&quot;
const transitionDuration = 2000
const easeFn = easeBounce

const extractTweenObj = &lt;ChartData&gt;(node: HierarchyRectNode&lt;ChartData&gt;) =&gt; ({
  depth: node.depth,
  x0: node.x0,
  x1: node.x1,
  y0: node.y0,
  y1: node.y1,
})

const getInterpolatorFn =
  &lt;ChartData&gt;({
    fn,
    initialData,
  }: {
    fn: (node: HierarchyRectNode&lt;ChartData&gt;) =&gt; string | null
    initialData: Array&lt;HierarchyRectNode&lt;ChartData&gt;&gt;
  }) =&gt;
  (...[finalNode, nodeIndex]: [HierarchyRectNode&lt;ChartData&gt;, number]) =&gt; {
    const { [nodeIndex]: initialNode } = initialData

    const interpolateFn = interpolate(
      extractTweenObj(initialNode),
      extractTweenObj(finalNode)
    )

    return (t: number) =&gt; {
      const transitientState = interpolateFn(t)

      return fn(transitientState as HierarchyRectNode&lt;ChartData&gt;)!
    }
  }

type ChartConfig&lt;ChartData&gt; = {
  getNodeLabel: (node: Node&lt;ChartData&gt;) =&gt; string
  getNodeSize: (node: Node&lt;ChartData&gt;) =&gt; number | undefined
  getNodeTitle: (options: {
    nodeData: Node&lt;ChartData&gt;
    valueNum?: number
  }) =&gt; string
  partitionType: PartitionType
  rootData: Node&lt;ChartData&gt;
  rootElId: string
}

type ChartElements = {
  svg: Selection&lt;SVGSVGElement, unknown, HTMLElement, unknown&gt;
  svgDrag: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  svgG: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
}

class PartitionChart&lt;ChartData&gt; {
  private readonly config: ChartConfig&lt;ChartData&gt;
  private readonly elements: ChartElements

  private readonly state: {
    descendants: Array&lt;HierarchyRectangularNode&lt;Node&lt;ChartData&gt;&gt;&gt;
    drag: { x: number; y: number }
    partitionType: PartitionType
  }

  public constructor(config: ChartConfig&lt;ChartData&gt;) {
    this.config = config

    const { partitionType, rootElId } = config

    const svg = select(`#${rootElId}`).append(&quot;svg&quot;).text(&quot;&quot;)
    const svgDrag = svg.append(&quot;g&quot;)
    const svgG = svgDrag.append(&quot;g&quot;)

    this.state = {
      descendants: [],
      drag: { x: 0, y: 0 },
      partitionType,
    }

    this.state.descendants = this.getDataHierarchy()

    this.elements = {
      svg,
      svgDrag,
      svgG,
    }

    this.setupDrag()

    window.addEventListener(&quot;resize&quot;, this.handleResize)
  }

  public updatePartition(newPartitionType: PartitionType) {
    this.state.partitionType = newPartitionType

    const newDescendants = this.getDataHierarchy()

    this.state.descendants = newDescendants

    this.renderDescendants()
  }

  public render() {
    const { width } = this.getDimensions()
    const {
      elements: { svg, svgG },
    } = this

    svg.attr(&quot;width&quot;, width).attr(&quot;height&quot;, height)
    svgG.attr(&quot;transform&quot;, `translate(${width / 2},${height * 0.52})`)

    this.renderDescendants()
  }

  private getDimensions() {
    const {
      config: { rootElId },
    } = this
    const { width } = (
      document.getElementById(rootElId) as HTMLElement
    ).getBoundingClientRect()
    const chartWidth = Math.max(width, 700)
    const radius = Math.min(chartWidth, height) / 2

    return {
      chartWidth,
      radius,
      width,
    }
  }

  private getDataHierarchy() {
    const {
      config: { getNodeSize, rootData },
      state: { partitionType },
    } = this
    const { radius } = this.getDimensions()
    const dataHierarchySize = hierarchy(rootData).sum(
      (node: Node&lt;ChartData&gt;) =&gt; getNodeSize(node) ?? 0
    )
    const dataHierarchyCount = hierarchy(rootData).sum(() =&gt; 1)
    const partition = partitionD3&lt;Node&lt;ChartData&gt;&gt;().size([2 * Math.PI, radius])

    const hierarchyResult = partition(
      partitionType === &quot;size&quot; ? dataHierarchySize : dataHierarchyCount
    )

    return hierarchyResult.descendants()
  }

  private setupDrag() {
    const {
      elements: { svg, svgDrag },
    } = this

    const handler = (
      dragEvent: D3DragEvent&lt;SVGSVGElement, unknown, unknown&gt;
    ) =&gt; {
      this.state.drag.x += dragEvent.dx
      this.state.drag.y += dragEvent.dy

      svgDrag.attr(
        &quot;transform&quot;,
        `translate(${this.state.drag.x},${this.state.drag.y})`
      )
    }

    const dragBehavior = dragD3&lt;SVGSVGElement, unknown&gt;().on(&quot;drag&quot;, handler)

    svg
      .style(&quot;cursor&quot;, &quot;move&quot;)
      .call(dragBehavior)
      .on(&quot;drag&quot;, handler)
      .on(&quot;wheel&quot;, null)
  }

  private renderDescendants() {
    const {
      config: { getNodeLabel, getNodeTitle },
      elements: { svgG },
      state: { descendants: usedDescendants },
    } = this

    const colorScale = scaleOrdinal(schemePastel2)

    const color = (node: HierarchyRectNode&lt;ChartData&gt;) =&gt;
      node.children
        ? colorScale(getNodeLabel(node.data))
        : colorScale(getNodeLabel(node.parent!.data))

    const arc = arcD3&lt;HierarchyRectNode&lt;ChartData&gt;&gt;()
      .startAngle((node) =&gt; node.x0)
      .endAngle((node) =&gt; node.x1)
      .innerRadius((node) =&gt; node.y0)
      .outerRadius((node) =&gt; node.y1)
      .padAngle(0.01)

    const textsTransform = (node: HierarchyRectNode&lt;ChartData&gt;) =&gt; {
      if (!node.depth) {
        return &quot;&quot;
      }

      const centroid = arc.centroid({
        ...node,
        x0: node.x0 + (node.x0 &gt; Math.PI ? -1 : 1) * 0.05,
      })
      const rotationDeg = (() =&gt; {
        const rotation =
          90 + ((node.x0 + (node.x1 - node.x0) / 2) * 180) / Math.PI

        return rotation &gt; 90 &amp;&amp; rotation &lt; 270 ? rotation - 180 : rotation
      })()

      return [
        `rotate(${rotationDeg},${centroid[0]},${centroid[1]})`,
        `translate(${centroid[0]},${centroid[1]})`,
      ].join(&quot; &quot;)
    }

    const pathSel = svgG.selectAll&lt;
      SVGPathElement,
      HierarchyRectNode&lt;ChartData&gt;
    &gt;(&quot;path&quot;)
    const pathInitialData = pathSel.data()
    const path = pathSel.data(usedDescendants)

    path.exit().remove()

    const pathEnter = path
      .enter()
      .append(&quot;path&quot;)
      .attr(&quot;display&quot;, (node) =&gt; (node.depth ? null : &quot;none&quot;))
      .attr(&quot;data-index&quot;, (...[, nodeIndex]) =&gt; nodeIndex)
      .style(&quot;stroke&quot;, &quot;#000&quot;)
      .style(&quot;stroke-width&quot;, &quot;0.5px&quot;)
      .style(&quot;stroke-dasharray&quot;, &quot;1,3&quot;)
      .style(&quot;fill&quot;, color)
      .attr(&quot;d&quot;, arc)

    path
      .transition()
      .duration(transitionDuration)
      .ease(easeFn)
      .attrTween(
        &quot;d&quot;,
        getInterpolatorFn({ fn: arc, initialData: pathInitialData })
      )

    const initialTextsSel = svgG.selectAll&lt;
      SVGTextElement,
      HierarchyRectNode&lt;ChartData&gt;
    &gt;(&quot;text&quot;)
    const textsInitialData = initialTextsSel.data()
    const initialTexts = initialTextsSel.data(usedDescendants)

    initialTexts.exit().remove()

    const opacityFn = (node: HierarchyRectangularNode&lt;Node&lt;ChartData&gt;&gt;) =&gt; {
      const arcLength = Math.abs(node.x0 - node.x1) * node.y1

      // this number is obtained empirically
      if (arcLength &lt; 25) {
        return 0
      }

      const isAlmostVertical = Math.abs((node.x0 + node.x1) / 2 - Math.PI) &lt; 0.2

      return isAlmostVertical ? 0 : 1
    }

    const textsEnter = initialTexts
      .enter()
      .append(&quot;text&quot;)
      .style(&quot;fill&quot;, &quot;#333&quot;)
      .style(&quot;cursor&quot;, &quot;default&quot;)
      .style(&quot;font&quot;, &quot;bold 12px Arial&quot;)
      .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
      .text((...[node, nodeIndex]) =&gt; {
        if (nodeIndex === 0) {
          return &quot;&quot;
        }

        const label = getNodeLabel(node.data)
        const limit = 9

        return label.length &gt; limit ? `${label.slice(0, limit)}...` : label
      })
      .attr(&quot;data-index&quot;, (...[, nodeIndex]) =&gt; nodeIndex)
      .attr(&quot;transform&quot;, textsTransform)
      .style(&quot;opacity&quot;, opacityFn)

    initialTexts
      .transition(&quot;movement&quot;)
      .duration(transitionDuration)
      .ease(easeFn)
      .attrTween(
        &quot;transform&quot;,
        getInterpolatorFn({
          fn: textsTransform,
          initialData: textsInitialData,
        })
      )

    svgG
      .selectAll&lt;SVGTextElement, HierarchyRectNode&lt;ChartData&gt;&gt;(&quot;text&quot;)
      .transition(&quot;opacity&quot;)
      .duration(transitionDuration)
      .ease(easeLinear)
      .style(&quot;opacity&quot;, opacityFn)

    const updatedGroups = [pathEnter, textsEnter]

    updatedGroups.forEach((set) =&gt; {
      set.on(&quot;mouseover&quot;, function onMouseOver() {
        const nodeIndex = select(this).attr(&quot;data-index&quot;)

        select(`path[data-index=&quot;${nodeIndex}&quot;]`).style(&quot;fill&quot;, overColor)
        select(`text[data-index=&quot;${nodeIndex}&quot;]`).style(&quot;fill&quot;, &quot;white&quot;)
      })

      set.on(&quot;mouseout&quot;, function onMouseOut() {
        const nodeIndex = select(this).attr(&quot;data-index&quot;)

        select&lt;SVGPathElement, HierarchyRectNode&lt;ChartData&gt;&gt;(
          `path[data-index=&quot;${nodeIndex}&quot;]`
        ).style(&quot;fill&quot;, color)
        select(`text[data-index=&quot;${nodeIndex}&quot;]`).style(&quot;fill&quot;, &quot;#000&quot;)
      })

      set.append(&quot;title&quot;).text((node) =&gt;
        getNodeTitle({
          nodeData: node.data,
          valueNum: node.value,
        })
      )
    })
  }

  private readonly handleResize = () =&gt; {
    this.render()
  }
}

export { PartitionChart, PartitionType, Node, ChartConfig }
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 25 Nov 2021 23:14:39 GMT</p>
    </body>
  </html>
  