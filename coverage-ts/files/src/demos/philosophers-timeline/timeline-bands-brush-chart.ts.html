
  <!DOCTYPE html>
  <html>
    <head>
      <title>timeline-bands-brush-chart.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/demos/philosophers-timeline/timeline-bands-brush-chart.ts</td><td class="">99.48%</td><td class="">95%</td><td class="">961</td><td class="">956</td><td class="">5</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  BaseType,
  ScaleTime,
  Selection,
  axisBottom,
  brushX,
  min as minD3,
  scaleTime,
  select,
  selectAll,
} from &quot;d3&quot;

import * as styles from &quot;./timeline-bands-brush-chart.module.css&quot;

enum SortOrder {
  Ascending = &quot;ascending&quot;,
  Descending = &quot;descending&quot;,
}

enum TimeOrder {
  Backward = &quot;backward&quot;,
  Forward = &quot;forward&quot;,
}

type RedrawComp = {
  redraw?: () =&gt; void
}

const margin = {
  bottom: 0,
  left: 20,
  right: 20,
  top: 60,
}

type Band = RedrawComp &amp; {
  g: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  h: number
  id: string
  instantWidth: number
  itemHeight: number
  parts: RedrawComp[]
  trackHeight: number
  trackOffset: number
  w: number
  x: number
  xScale: ScaleTime&lt;number, number, number&gt;
  y: number
  yScale: (track: number) =&gt; number
}

const outerHeight = 700
const height = outerHeight - margin.top - margin.bottom
const bandGap = 25

const toYear = (date: Date) =&gt; {
  const bcString = &quot; BC&quot;
  const year = date.getUTCFullYear()

  if (year &gt;= 0) {
    return year.toString()
  }

  return bcString + Math.abs(year)
}

const filterBlackOpacity = ({
  deviation,
  id,
  slope,
  svg,
}: {
  deviation: number
  id: string
  slope: number
  svg: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
}) =&gt; {
  const defs = svg.append(&quot;defs&quot;)
  const filter = defs
    .append(&quot;filter&quot;)
    .attr(&quot;height&quot;, &quot;500%&quot;)
    .attr(&quot;id&quot;, `drop-shadow-${id}`)
    .attr(&quot;width&quot;, &quot;500%&quot;)
    .attr(&quot;x&quot;, &quot;-200%&quot;)
    .attr(&quot;y&quot;, &quot;-200%&quot;)

  filter
    .append(&quot;feGaussianBlur&quot;)
    .attr(&quot;in&quot;, &quot;SourceAlpha&quot;)
    .attr(&quot;stdDeviation&quot;, deviation)

  filter.append(&quot;feOffset&quot;).attr(&quot;dx&quot;, 1).attr(&quot;dy&quot;, 1)
  filter
    .append(&quot;feComponentTransfer&quot;)
    .append(&quot;feFuncA&quot;)
    .attr(&quot;slope&quot;, slope)
    .attr(&quot;type&quot;, &quot;linear&quot;)

  const feMerge = filter.append(&quot;feMerge&quot;)

  feMerge.append(&quot;feMergeNode&quot;)

  feMerge.append(&quot;feMergeNode&quot;).attr(&quot;in&quot;, &quot;SourceGraphic&quot;)
}

type ChartDataBase = {
  instant: boolean
  track: number
}

type ChartConfig&lt;ChartData extends ChartDataBase&gt; = {
  chartTitle: string
  getItemLimitLeft: (chartItem: ChartData) =&gt; Date
  getItemLimitRight: (chartItem: ChartData) =&gt; Date
  getItemText: (itemInfo: {
    chartItem: ChartData
    maxLetters: number
  }) =&gt; string
  getItemTitle: (chartItem: ChartData) =&gt; string
  getSortFn: (
    sortOrder: SortOrder
  ) =&gt; (itemA: ChartData, itemB: ChartData) =&gt; number
  onChartItemClick: (chartItem: ChartData) =&gt; void
  rootElId: string
}

class Timeline&lt;ChartData extends ChartDataBase&gt; {
  private readonly chart: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;

  private bandY: number
  private bandNum: number
  private dataContent: {
    chartItems?: ChartData[]
    maxDate?: Date
    minDate?: Date
    nTracks?: number
  }

  private readonly components: RedrawComp[]
  private bands: { [k: string]: Band }
  private readonly width: number
  private readonly chartConfig: ChartConfig&lt;ChartData&gt;

  public constructor(chartConfig: ChartConfig&lt;ChartData&gt;) {
    this.chartConfig = chartConfig

    const rootEl = document.getElementById(chartConfig.rootElId) as HTMLElement

    rootEl.classList.add(styles.timelineChart)

    const { width: outerWidth } = rootEl.getBoundingClientRect()

    this.width = outerWidth - margin.left - margin.right

    this.bandY = 0
    this.bandNum = 0

    this.dataContent = {}
    this.components = []
    this.bands = {}

    const svg = select(`#${chartConfig.rootElId}`)
      .text(&quot;&quot;)
      .append(&quot;svg&quot;)
      .attr(&quot;height&quot;, outerHeight + margin.top + margin.bottom)
      .attr(&quot;width&quot;, outerWidth + margin.left + margin.right)
      .append(&quot;g&quot;)
      .attr(&quot;transform&quot;, `translate(${margin.left},${margin.top})`)

    svg
      .append(&quot;text&quot;)
      .attr(&quot;class&quot;, &quot;chart-title&quot;)
      .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
      .attr(&quot;transform&quot;, `translate(${outerWidth / 2},-20)`)
      .text(chartConfig.chartTitle)
      .style(&quot;font-weight&quot;, &quot;bold&quot;)

    filterBlackOpacity({ deviation: 1, id: &quot;intervals&quot;, slope: 0.2, svg })

    svg
      .append(&quot;clipPath&quot;)
      .attr(&quot;id&quot;, &quot;chart-area&quot;)
      .append(&quot;rect&quot;)
      .attr(&quot;width&quot;, this.width)
      .attr(&quot;height&quot;, height)

    svg.on(&quot;mouseup&quot;, () =&gt;
      selectAll(`.${styles.interval} rect`).style(
        &quot;filter&quot;,
        &quot;url(#drop-shadow-intervals)&quot;
      )
    )

    this.chart = svg
      .append(&quot;g&quot;)
      .attr(&quot;class&quot;, styles.chart)
      .attr(&quot;clip-path&quot;, &quot;url(#chart-area)&quot;)
  }

  public addChartData(timelineItems: ChartData[]) {
    const tracks: Date[] = []

    this.dataContent.chartItems = timelineItems

    const calculateTracks = ({
      chartItems,
      sortOrderInitial,
      timeOrderInitial,
    }: {
      chartItems: ChartData[]
      sortOrderInitial?: SortOrder
      timeOrderInitial?: TimeOrder
    }) =&gt; {
      const sortOrder = sortOrderInitial ?? SortOrder.Descending
      const timeOrder = timeOrderInitial ?? TimeOrder.Forward

      const sortBackward = () =&gt; {
        chartItems.forEach((chartItem) =&gt; {
          let trackIndex = 0

          for (trackIndex = 0; trackIndex &lt; tracks.length; trackIndex += 1) {
            if (
              this.chartConfig.getItemLimitRight(chartItem) &lt; tracks[trackIndex]
            ) {
              break
            }
          }

          chartItem.track = trackIndex
          tracks[trackIndex] = this.chartConfig.getItemLimitLeft(chartItem)
        })
      }

      const sortForward = () =&gt; {
        chartItems.forEach((chartItem) =&gt; {
          let trackIndex = 0

          for (trackIndex = 0; trackIndex &lt; tracks.length; trackIndex += 1) {
            if (
              this.chartConfig.getItemLimitLeft(chartItem) &gt; tracks[trackIndex]
            ) {
              break
            }
          }

          chartItem.track = trackIndex

          tracks[trackIndex] = this.chartConfig.getItemLimitRight(chartItem)
        })
      }

      const sortFn = this.chartConfig.getSortFn(sortOrder)

      this.dataContent.chartItems!.sort(sortFn)

      if (timeOrder === TimeOrder.Forward) {
        sortForward()

        return
      }

      sortBackward()
    }

    calculateTracks({
      chartItems: this.dataContent.chartItems,
      sortOrderInitial: SortOrder.Descending,
      timeOrderInitial: TimeOrder.Backward,
    })

    this.dataContent.nTracks = tracks.length
    this.dataContent.minDate = minD3(
      this.dataContent.chartItems,
      this.chartConfig.getItemLimitLeft
    )
    this.dataContent.maxDate = new Date()

    return this
  }

  public xAxis(bandName: string) {
    const {
      bands: { [bandName]: band },
    } = this

    const axis = axisBottom&lt;Date&gt;(band.xScale)
      .tickSize(6)
      .tickFormat((axisTick) =&gt; toYear(axisTick))

    const xAxis: RedrawComp &amp;
      Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt; = this.chart
      .append(&quot;g&quot;)
      .attr(&quot;class&quot;, styles.axis)
      .attr(&quot;transform&quot;, `translate(0,${band.y + band.h})`)

    xAxis.redraw = () =&gt; {
      xAxis.call(axis)
    }

    band.parts.push(xAxis)
    this.components.push(xAxis)

    return this
  }

  public createTooltip() {
    $(`.part.${styles.instant}, .part.${styles.interval}`).tooltip({
      track: true,
    })

    return this
  }

  public addBand({
    bandName,
    sizeFactor,
  }: {
    bandName: string
    sizeFactor: number
  }) {
    const band: Partial&lt;Band&gt; = {}

    band.id = `band${this.bandNum}`
    band.x = 0
    band.y = this.bandY
    band.w = this.width
    band.h = height * (sizeFactor || 1)
    band.trackOffset = 0
    band.trackHeight = Math.min(
      (band.h - band.trackOffset) / this.dataContent.nTracks!,
      20
    )
    band.itemHeight = band.trackHeight * 0.7
    band.parts = []
    band.instantWidth = 100
    band.xScale = scaleTime()
      .domain([this.dataContent.minDate!, this.dataContent.maxDate!])
      .range([0, band.w])

    band.yScale = (track: number) =&gt;
      band.trackOffset! + track * band.trackHeight!

    band.g = this.chart
      .append(&quot;g&quot;)
      .attr(&quot;id&quot;, band.id)
      .attr(&quot;transform&quot;, `translate(0,${band.y})`)

    band.g
      .append(&quot;rect&quot;)
      .attr(&quot;class&quot;, styles.band)
      .attr(&quot;width&quot;, band.w)
      .attr(&quot;height&quot;, band.h)

    const bandElements = band.g
      .selectAll(&quot;g&quot;)
      .data&lt;ChartData&gt;(this.dataContent.chartItems!)
      .enter()
      .append&lt;SVGSVGElement&gt;(&quot;svg&quot;)
      .attr(&quot;y&quot;, (chartItem) =&gt; band.yScale!(chartItem.track))
      .attr(&quot;height&quot;, band.itemHeight)
      .attr(&quot;title&quot;, this.chartConfig.getItemTitle)
      .attr(
        &quot;class&quot;,
        (chartItem) =&gt;
          `part ${chartItem.instant ? styles.instant : styles.interval}`
      )

    const intervals = select(`#band${this.bandNum}`).selectAll&lt;
      BaseType,
      ChartData
    &gt;(`.${styles.interval}`)

    const instants = select(`#band${this.bandNum}`).selectAll&lt;
      BaseType,
      ChartData
    &gt;(`.${styles.instant}`)

    intervals
      .append(&quot;rect&quot;)
      .attr(&quot;height&quot;, &quot;100%&quot;)
      .attr(&quot;width&quot;, &quot;100%&quot;)
      .attr(&quot;x&quot;, &quot;1px&quot;)
      .attr(&quot;y&quot;, &quot;.5px&quot;)
      .style(&quot;filter&quot;, &quot;url(#drop-shadow-intervals)&quot;)

    intervals
      .append(&quot;text&quot;)
      .attr(&quot;class&quot;, styles.intervalLabel)
      .attr(&quot;x&quot;, 3)
      .attr(&quot;y&quot;, 9.5)

    instants
      .append(&quot;circle&quot;)
      .attr(&quot;cx&quot;, band.itemHeight / 2)
      .attr(&quot;cy&quot;, band.itemHeight / 2)
      .attr(&quot;r&quot;, 5)

    instants
      .append(&quot;text&quot;)
      .attr(&quot;class&quot;, styles.instantLabel)
      .attr(&quot;x&quot;, 15)
      .attr(&quot;y&quot;, 10)

    const itemsSelections = [intervals, instants]

    itemsSelections.forEach((selection) =&gt; {
      selection.on(&quot;click&quot;, (...[, chartItem]) =&gt;
        this.chartConfig.onChartItemClick(chartItem)
      )
      selection.style(&quot;cursor&quot;, &quot;pointer&quot;)
    })

    const {
      chartConfig: { getItemLimitLeft, getItemLimitRight },
    } = this

    band.redraw = () =&gt; {
      bandElements
        .attr(&quot;x&quot;, (chartItem: ChartData) =&gt;
          band.xScale!(getItemLimitLeft(chartItem))
        )
        .attr(
          &quot;width&quot;,
          (chartItem: ChartData) =&gt;
            band.xScale!(getItemLimitRight(chartItem)) -
            band.xScale!(getItemLimitLeft(chartItem))
        )
        .select(&quot;text&quot;)
        .text((chartItem: ChartData) =&gt; {
          const scale =
            band.xScale!(getItemLimitRight(chartItem)) -
            band.xScale!(getItemLimitLeft(chartItem))
          const maxLetters = scale / 9

          return this.chartConfig.getItemText({ chartItem, maxLetters })
        })

      band.parts!.forEach((part) =&gt; part.redraw!())
    }

    this.bands[bandName] = band as Band
    this.components.push(band)
    this.bandY += band.h + bandGap
    this.bandNum += 1

    return this
  }

  public labels(bandName: string) {
    const {
      bands: { [bandName]: band },
    } = this
    const labelWidth = 46
    const labelHeight = 20
    const labelTop = band.y + band.h - 10
    const yText = 15

    type LabelDef = {
      className: string
      getText: (min: Date, max: Date) =&gt; string
      id: string
      left: number
      textAnchor: string
      textLeft: number
      top: number
    }

    const labelDefs: LabelDef[] = [
      {
        className: styles.bandMinMaxLabel,
        getText: (min: Date) =&gt; toYear(min),
        id: &quot;Start of the selected interval&quot;,
        left: 0,
        textAnchor: &quot;start&quot;,
        textLeft: 4,
        top: labelTop,
      },
      {
        className: styles.bandMinMaxLabel,
        getText: (...[, max]: [unknown, Date]) =&gt; toYear(max),
        id: &quot;End of the selected interval&quot;,
        left: band.w - labelWidth,
        textAnchor: &quot;end&quot;,
        textLeft: band.w - 4,
        top: labelTop,
      },
      {
        className: styles.bandMidLabel,
        getText: (...[min, max]: [Date, Date]) =&gt;
          (max.getUTCFullYear() - min.getUTCFullYear()).toString(),
        id: &quot;Length of the selected interval&quot;,
        left: (band.w - labelWidth) / 2,
        textAnchor: &quot;middle&quot;,
        textLeft: band.w / 2,
        top: labelTop,
      },
    ]

    const bandLabels = this.chart
      .append(&quot;g&quot;)
      .attr(&quot;id&quot;, `${bandName}Labels`)
      .attr(&quot;transform&quot;, `translate(0,${band.y + band.h + 1})`)
      .selectAll(`#${bandName}Labels`)
      .data(labelDefs)
      .enter()
      .append(&quot;g&quot;)

    bandLabels
      .append(&quot;rect&quot;)
      .attr(&quot;class&quot;, styles.bandLabel)
      .attr(&quot;x&quot;, (label) =&gt; label.left)
      .attr(&quot;width&quot;, labelWidth)
      .attr(&quot;height&quot;, labelHeight)
      .style(&quot;opacity&quot;, 1)

    const labels: RedrawComp &amp;
      Selection&lt;SVGTextElement, LabelDef, SVGGElement, unknown&gt; = bandLabels
      .append(&quot;text&quot;)
      .attr(&quot;class&quot;, (label) =&gt; label.className)
      .attr(&quot;id&quot;, (label) =&gt; label.id)
      .attr(&quot;x&quot;, (label) =&gt; label.textLeft)
      .attr(&quot;y&quot;, yText)
      .attr(&quot;text-anchor&quot;, (label) =&gt; label.textAnchor)

    labels.redraw = () =&gt; {
      const min = band.xScale.domain()[0]
      const max = band.xScale.domain()[1]

      labels.text((label) =&gt; label.getText(min, max))
    }

    band.parts.push(labels)
    this.components.push(labels)

    return this
  }

  public addBrush({
    brushBandName,
    targetBandName,
  }: {
    brushBandName: string
    targetBandName: string
  }) {
    const {
      bands: { [brushBandName]: brushBand },
    } = this
    const brush = brushX()

    const {
      dataContent: { maxDate, minDate },
    } = this
    const totalRange = [minDate!.getTime(), maxDate!.getTime()]

    const selectionScale = scaleTime&lt;number, Date&gt;()
      .domain([0, this.width])
      .range(totalRange)

    brush.on(&quot;brush&quot;, (brushEvent) =&gt; {
      let newDomain = brushBand.xScale.domain()

      if (brushEvent.selection) {
        const {
          selection: [selectionStart, selectionEnd],
        } = brushEvent

        newDomain = [
          selectionScale(Math.max(0, selectionStart)),
          selectionScale(Math.min(this.width, selectionEnd)),
        ]
      }

      selectAll(`.${styles.interval} rect`).style(&quot;filter&quot;, &quot;none&quot;)

      this.bands[targetBandName].xScale.domain(newDomain)
      this.bands[targetBandName].redraw!()
    })

    const xBrush = brushBand.g
      .append(&quot;svg&quot;)
      .attr(&quot;class&quot;, `x`)
      .call(brush as any) // eslint-disable-line @typescript-eslint/no-explicit-any

    xBrush
      .selectAll(&quot;rect&quot;)
      .attr(&quot;y&quot;, 1)
      .attr(&quot;height&quot;, brushBand.h - 1)

    return this
  }

  public redraw() {
    this.components.forEach((component: RedrawComp) =&gt; component.redraw!())

    return this
  }
}

export { ChartConfig, SortOrder, Timeline }
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/demos/philosophers-timeline/timeline-bands-brush-chart.ts&quot;,&quot;line&quot;:558,&quot;character&quot;:23,&quot;text&quot;:&quot;brushEvent&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/philosophers-timeline/timeline-bands-brush-chart.ts&quot;,&quot;line&quot;:561,&quot;character&quot;:10,&quot;text&quot;:&quot;brushEvent&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/philosophers-timeline/timeline-bands-brush-chart.ts&quot;,&quot;line&quot;:561,&quot;character&quot;:21,&quot;text&quot;:&quot;selection&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/philosophers-timeline/timeline-bands-brush-chart.ts&quot;,&quot;line&quot;:563,&quot;character&quot;:22,&quot;text&quot;:&quot;selectionStart&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/philosophers-timeline/timeline-bands-brush-chart.ts&quot;,&quot;line&quot;:563,&quot;character&quot;:38,&quot;text&quot;:&quot;selectionEnd&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 23 Sep 2021 23:16:51 GMT</p>
    </body>
  </html>
  