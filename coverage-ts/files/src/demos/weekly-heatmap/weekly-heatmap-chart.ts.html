
  <!DOCTYPE html>
  <html>
    <head>
      <title>weekly-heatmap-chart.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/demos/weekly-heatmap/weekly-heatmap-chart.ts</td><td class="">100.00%</td><td class="">95%</td><td class="">511</td><td class="">511</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  D3DragEvent,
  Selection,
  drag as dragD3,
  max as maxD3,
  scaleQuantile,
  select,
} from &quot;d3&quot;
import $ from &quot;jquery&quot;
import &quot;jquery-ui/themes/base/all.css&quot;

import { TRANSITION_DURATION } from &quot;./ui-constants&quot;
import * as styles from &quot;./weekly-heatmap.module.css&quot;

if (typeof window !== &quot;undefined&quot;) {
  require(&quot;jquery-ui/ui/widgets/tooltip&quot;)
}

const colors = [
  &quot;#ffffd9&quot;,
  &quot;#edf8b1&quot;,
  &quot;#c7e9b4&quot;,
  &quot;#7fcdbb&quot;,
  &quot;#41b6c4&quot;,
  &quot;#1d91c0&quot;,
  &quot;#225ea8&quot;,
  &quot;#253494&quot;,
  &quot;#081d58&quot;,
]
const { length: buckets } = colors

const margin = {
  bottom: 100,
  left: 50,
  right: 50,
  top: 50,
}
const minHeight = 250
const minWidth = 850

const rectRadiusSize = 100
const extraHeight = 60
const axisOffset = -6

const legendStroke = &quot;#ccc&quot;

type ChartConfig&lt;ChartData&gt; = Readonly&lt;{
  getIsHorizontalLabelBold: (label: string, labelIndex: number) =&gt; boolean
  getIsVerticalLabelBold: (label: string, labelIndex: number) =&gt; boolean
  getItemHorizontalIndex: (cell: ChartData) =&gt; number
  getItemTooltip: (cell: ChartData) =&gt; string
  getItemValue: (cell: ChartData) =&gt; number
  getItemVerticalIndex: (cell: ChartData) =&gt; number
  getLegendText: (cellValue: number) =&gt; string
  horizontalLabels: string[]
  rootElId: string
  verticalLabels: string[]
  weeklyData: ChartData[]
}&gt;

type ChartElements&lt;ChartData&gt; = Readonly&lt;{
  cellsSel: Selection&lt;SVGGElement, ChartData, SVGGElement, unknown&gt;
  gSel: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  legendSel: Selection&lt;SVGGElement, number, SVGGElement, unknown&gt;
  svgDragSel: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  svgSel: Selection&lt;SVGSVGElement, unknown, HTMLElement, unknown&gt;
}&gt;

type ChartClasses = Readonly&lt;{
  cell: string
  legend: string
}&gt;

class HeatmapChart&lt;ChartData&gt; {
  private readonly config: ChartConfig&lt;ChartData&gt;
  private readonly elements: ChartElements&lt;ChartData&gt;
  private readonly classes: ChartClasses
  private readonly state = {
    drag: {
      x: 0,
      y: 0,
    },
    width: 0,
  }

  private constructor(chartConfig: ChartConfig&lt;ChartData&gt;) {
    this.config = chartConfig

    const { rootElId } = chartConfig

    const svgSel = select(`#${rootElId}`).append(&quot;svg&quot;)
    const svgDragSel = svgSel.append(&quot;g&quot;)
    const gSel = svgDragSel.append(&quot;g&quot;)

    const chartClasses = {
      cell: &quot;cell&quot;,
      legend: &quot;legend&quot;,
    }

    this.classes = chartClasses

    this.elements = {
      get cellsSel() {
        return gSel.selectAll&lt;SVGGElement, ChartData&gt;(`.${chartClasses.cell}`)
      },
      gSel,
      get legendSel() {
        return gSel.selectAll&lt;SVGGElement, number&gt;(`.${chartClasses.legend}`)
      },
      svgDragSel,
      svgSel,
    }

    this.render()

    window.addEventListener(&quot;resize&quot;, this.handleResize)
  }

  public static renderChart&lt;ChartData&gt;(chartConfig: ChartConfig&lt;ChartData&gt;) {
    return new HeatmapChart&lt;ChartData&gt;(chartConfig)
  }

  public teardown() {
    window.removeEventListener(&quot;resize&quot;, this.handleResize)
  }

  public refresh() {
    this.render()
  }

  private render() {
    const { config, elements } = this
    const { horizontalLabels, rootElId, verticalLabels, weeklyData } = config
    const rootEl = document.getElementById(rootElId) as HTMLElement

    rootEl.classList.add(styles.weeklyHeatmapChart)

    const fullWidth =
      rootEl.getBoundingClientRect().width - margin.left - margin.right
    const width = Math.max(fullWidth, minWidth)

    this.state.width = fullWidth

    const height = Math.max(
      Math.ceil((width * 10) / horizontalLabels.length) -
        margin.top -
        margin.bottom +
        extraHeight,
      minHeight
    )
    const cellSize = Math.floor(width / horizontalLabels.length)
    const legendElementWidth = cellSize * 2

    const max = maxD3(weeklyData, (cell) =&gt; config.getItemValue(cell))

    const colorScale = scaleQuantile&lt;string&gt;()
      .domain([0, buckets - 1, max])
      .range(colors)

    elements.svgSel
      .attr(&quot;height&quot;, height + margin.top + margin.bottom)
      .attr(&quot;width&quot;, width + margin.left + margin.right)

    elements.gSel.attr(&quot;transform&quot;, `translate(${margin.left},${margin.top})`)

    elements.gSel
      .selectAll(&quot;.verticalLabel&quot;)
      .data(verticalLabels)
      .enter()
      .append(&quot;text&quot;)
      .attr(
        &quot;class&quot;,
        (...[label, labelIndex]) =&gt;
          `verticalLabel ${styles.mono} axis${
            config.getIsVerticalLabelBold(label, labelIndex)
              ? ` ${styles.axisBold}`
              : &quot;&quot;
          }`
      )

    elements.gSel
      .selectAll&lt;SVGTextElement, string&gt;(&quot;.verticalLabel&quot;)
      .text((label) =&gt; label)
      .attr(&quot;transform&quot;, `translate(${axisOffset},${cellSize / 1.5})`)
      .attr(&quot;x&quot;, 0)
      .attr(&quot;y&quot;, (...[, labelIndex]) =&gt; labelIndex * cellSize)
      .style(&quot;text-anchor&quot;, &quot;end&quot;)

    elements.gSel
      .selectAll(&quot;.horizontalLabel&quot;)
      .data(horizontalLabels)
      .enter()
      .append(&quot;text&quot;)
      .text((label) =&gt; label)
      .style(&quot;text-anchor&quot;, &quot;middle&quot;)
      .attr(
        &quot;class&quot;,
        (...[label, labelIndex]) =&gt;
          `horizontalLabel ${styles.mono} axis${
            config.getIsHorizontalLabelBold(label, labelIndex)
              ? ` ${styles.axisBold}`
              : &quot;&quot;
          }`
      )

    elements.gSel
      .selectAll&lt;SVGTextElement, string&gt;(&quot;.horizontalLabel&quot;)
      .attr(&quot;transform&quot;, `translate(${cellSize / 2}, ${axisOffset})`)
      .attr(&quot;x&quot;, (...[, labelIndex]) =&gt; labelIndex * cellSize)
      .attr(&quot;y&quot;, 0)

    elements.cellsSel
      .data(weeklyData)
      .enter()
      .append(&quot;rect&quot;)
      .attr(&quot;class&quot;, `${this.classes.cell} ${styles.bordered}`)
      .style(&quot;fill&quot;, colors[0])

    elements.cellsSel
      .transition()
      .duration(TRANSITION_DURATION)
      .style(&quot;fill&quot;, (cellItem) =&gt; colorScale(config.getItemValue(cellItem)))

    elements.cellsSel
      .attr(&quot;height&quot;, cellSize)
      .attr(&quot;rx&quot;, rectRadiusSize)
      .attr(&quot;ry&quot;, rectRadiusSize)
      .attr(&quot;width&quot;, cellSize)
      .attr(
        &quot;x&quot;,
        (cellItem) =&gt; config.getItemHorizontalIndex(cellItem) * cellSize
      )
      .attr(&quot;y&quot;, (cellItem) =&gt; config.getItemVerticalIndex(cellItem) * cellSize)
      .attr(&quot;title&quot;, config.getItemTooltip)

    $(`.${this.classes.cell}`).tooltip()

    const legendData = [0].concat(colorScale.quantiles())

    const legendNew = elements.legendSel
      .data(legendData)
      .enter()
      .append(&quot;g&quot;)
      .attr(&quot;class&quot;, this.classes.legend)

    legendNew
      .append(&quot;rect&quot;)
      .style(&quot;fill&quot;, (...[, valueIndex]) =&gt; colors[valueIndex])
      .style(&quot;stroke&quot;, legendStroke)

    legendNew
      .append(&quot;text&quot;)
      .attr(&quot;class&quot;, styles.mono)
      .style(&quot;text-anchor&quot;, &quot;middle&quot;)

    elements.legendSel.each(function handleLegendItem(
      ...[valueItem, valueIndex]
    ) {
      select(this)
        .selectAll(&quot;rect&quot;)
        .attr(&quot;x&quot;, legendElementWidth * valueIndex)
        .attr(&quot;y&quot;, height)
        .attr(&quot;width&quot;, legendElementWidth)
        .attr(&quot;height&quot;, cellSize / 2)

      select(this)
        .selectAll&lt;SVGTextElement, unknown&gt;(`.${styles.mono}`)
        .attr(&quot;x&quot;, legendElementWidth * valueIndex + legendElementWidth / 2)
        .text(config.getLegendText(valueItem))
        .attr(&quot;y&quot;, height + cellSize)
    })

    this.setupDrag()
  }

  private setupDrag() {
    const { elements } = this

    const updateDrag = () =&gt; {
      this.elements.svgDragSel.attr(
        &quot;transform&quot;,
        `translate(${this.state.drag.x},${this.state.drag.y})`
      )
    }

    const canUseDrag = this.state.width &lt; minWidth

    const dragHandler = (
      dragEvent: D3DragEvent&lt;SVGSVGElement, unknown, unknown&gt;
    ) =&gt; {
      if (!canUseDrag) {
        return
      }

      this.state.drag.x += dragEvent.dx
      this.state.drag.y += dragEvent.dy

      updateDrag()
    }

    const dragBehavior = dragD3&lt;SVGSVGElement, unknown&gt;().on(
      &quot;drag&quot;,
      dragHandler
    )

    elements.svgSel.style(&quot;cursor&quot;, canUseDrag ? &quot;move&quot; : &quot;default&quot;)

    if (!canUseDrag) {
      this.state.drag = { x: 0, y: 0 }
    }

    elements.svgSel.call(dragBehavior).on(&quot;drag&quot;, dragHandler)

    updateDrag()
  }

  private readonly handleResize = () =&gt; {
    this.render()
  }
}

export { HeatmapChart, ChartConfig }
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Sat, 05 Feb 2022 19:43:17 GMT</p>
    </body>
  </html>
  