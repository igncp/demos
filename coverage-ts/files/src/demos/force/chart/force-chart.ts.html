
  <!DOCTYPE html>
  <html>
    <head>
      <title>force-chart.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/demos/force/chart/force-chart.ts</td><td class="">100.00%</td><td class="">95%</td><td class="">470</td><td class="">470</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  Selection,
  Simulation,
  SimulationLinkDatum,
  SimulationNodeDatum,
  forceCenter,
  forceCollide as forceCollideD3,
  forceLink as forceLinkD3,
  forceManyBody,
  forceSimulation,
  select,
} from &quot;d3&quot;

import * as styles from &quot;../force.module.css&quot;

import { BackgroundDrag, CustomDragEvent, NodeDrag } from &quot;./force-drag&quot;

const settings = {
  defaultTextOpacity: 0.5,
  strength: -40,
  textDY: 5,
}

const getNodeId = (node: SimulationNodeDatum) =&gt; `node-text-${node.index!}`

type ChartConfig&lt;NodeData, LinkData&gt; = {
  forceData: { links: LinkData[]; nodes: NodeData[] }
  getNodeText: (node: NodeData) =&gt; string
  height: number
  radius?: number
  rootElId: string
}

type ChartElements = {
  svg: Selection&lt;SVGSVGElement, unknown, HTMLElement, unknown&gt;
  svgDrag: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  svgG: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
}

class ForceChart&lt;NodeData, LinkData extends SimulationLinkDatum&lt;NodeData&gt;&gt; {
  public static defaultRadius = 5

  private readonly backgroundDrag: BackgroundDrag&lt;SVGSVGElement, SVGGElement&gt;
  private readonly config: ChartConfig&lt;NodeData, LinkData&gt;
  private readonly elements: ChartElements
  private readonly simulation: Simulation&lt;NodeData, undefined&gt;
  private state: {
    radius: number
  }

  private readonly forceNodes: Array&lt;NodeData &amp; SimulationNodeDatum&gt;
  private readonly forceLinks: Array&lt;
    SimulationLinkDatum&lt;NodeData &amp; SimulationNodeDatum&gt;
  &gt;

  public constructor(config: ChartConfig&lt;NodeData, LinkData&gt;) {
    this.config = config
    this.state = {
      radius: config.radius ?? ForceChart.defaultRadius,
    }

    const { forceData, rootElId } = config
    const { links, nodes } = forceData

    const rootEl = document.getElementById(rootElId) as HTMLElement

    rootEl.classList.add(styles.forceChart)

    const svg = select(`#${rootElId}`).append(&quot;svg&quot;)
    const svgDrag = svg.append(&quot;g&quot;)
    const svgG = svgDrag.append(&quot;g&quot;)

    this.elements = { svg, svgDrag, svgG }

    this.backgroundDrag = new BackgroundDrag({
      svg,
      svgDrag,
    })

    const forceLink = forceLinkD3&lt;NodeData, LinkData&gt;().links(
      links.map((link) =&gt; ({ ...link }))
    )
    const forceCollide = forceCollideD3(12).strength(1).iterations(100)

    const simulation = forceSimulation&lt;NodeData&gt;(
      nodes.map((node) =&gt; ({ ...node }))
    )
      .force(&quot;link&quot;, forceLink)
      .force(&quot;collide&quot;, forceCollide)
      .on(&quot;tick&quot;, () =&gt; {
        this.render()
      })

    this.simulation = simulation
    this.forceNodes = this.simulation.nodes()
    this.forceLinks = forceLink.links()

    this.backgroundDrag.setupBackgroundDrag()

    this.render()

    window.addEventListener(&quot;resize&quot;, this.handleResize)
  }

  public setRadius(radius: number) {
    this.state.radius = radius
    this.getNodes().attr(&quot;r&quot;, radius)
  }

  private readonly handleResize = () =&gt; {
    this.render()
  }

  private render() {
    const {
      config: { height, rootElId },
    } = this

    const rootEl = document.getElementById(rootElId) as HTMLElement

    const { width } = rootEl.getBoundingClientRect()

    this.simulation
      .force(&quot;charge&quot;, forceManyBody().strength(settings.strength))
      .force(&quot;center&quot;, forceCenter(width / 2, height / 2))

    this.elements.svg.attr(&quot;width&quot;, width).attr(&quot;height&quot;, height)

    this.updateLinks()
    this.updateNodes()
  }

  private updateLinks() {
    const {
      elements: { svgG },
    } = this
    const linksEls = svgG
      .selectAll&lt;SVGPathElement, ForceChart&lt;NodeData, LinkData&gt;[&quot;forceLinks&quot;]&gt;(
        `.${styles.linkCurved}`
      )
      .data(this.forceLinks)

    type ForceNode = NodeData &amp; SimulationNodeDatum

    linksEls
      .enter()
      .append&lt;SVGPathElement&gt;(&quot;path&quot;)
      .merge(linksEls)
      .attr(&quot;d&quot;, (forceLink) =&gt; {
        const { source, target } = forceLink as {
          source: ForceNode
          target: ForceNode
        }
        const dx = target.x! - source.x!
        const dy = target.y! - source.y!
        const dr = Math.sqrt(dx * dx + dy * dy) * 1.3

        return `M${source.x!},${source.y!}A${dr},${dr} 0 0,1 ${target.x!},${target.y!}`
      })
      .attr(&quot;class&quot;, styles.linkCurved)
      .attr(&quot;marker-end&quot;, &quot;url(#end)&quot;)
      .attr(&quot;id&quot;, (...[, forceLinkIndex]) =&gt; `link-${forceLinkIndex}`)

    linksEls.exit().remove()
  }

  private updateNodes() {
    type ForceNode = ForceChart&lt;NodeData, LinkData&gt;[&quot;forceNodes&quot;][0]

    const {
      config: { getNodeText },
      elements: { svgG },
      forceNodes,
    } = this

    const nodesEls = this.getNodes().data(forceNodes)

    const textsEls = svgG
      .selectAll&lt;SVGTextElement, ForceNode&gt;(&quot;text&quot;)
      .data(forceNodes)

    type DragOpts = {
      dragEvent: CustomDragEvent
      node: ForceNode
    }

    const onDrag = ({ dragEvent, node }: DragOpts) =&gt; {
      node.fx = dragEvent.x
      node.fy = dragEvent.y
    }

    const onDragEnded = ({ dragEvent, node }: DragOpts) =&gt; {
      if (!dragEvent.active) {
        this.simulation.alphaTarget(0)
      }

      node.fx = null
      node.fy = null
    }

    const onDragStart = ({ dragEvent, node }: DragOpts) =&gt; {
      if (!dragEvent.active) {
        this.simulation.alphaTarget(0.3).restart()
      }

      node.fx = node.x
      node.fy = node.y
    }

    const addInteraction = &lt;SVGType extends SVGCircleElement | SVGTextElement&gt;(
      selection: Selection&lt;SVGType, ForceNode, SVGGElement, unknown&gt;
    ) =&gt; {
      const nodeDrag = new NodeDrag&lt;ForceNode, SVGType&gt;({
        onDrag,
        onDragEnded,
        onDragStart,
      })

      selection
        .on(&quot;mouseenter&quot;, (...[, forceNode]) =&gt; {
          select(`#${getNodeId(forceNode)}`)
            .style(&quot;opacity&quot;, 1)
            .style(&quot;fill&quot;, &quot;#000&quot;)
        })!
        .on(&quot;mouseleave&quot;, (...[, forceNode]) =&gt; {
          select(`#${getNodeId(forceNode)}`)
            .style(&quot;opacity&quot;, settings.defaultTextOpacity)
            .style(&quot;fill&quot;, null)
        })
        .call(nodeDrag.setupNodes)
        .style(&quot;cursor&quot;, &quot;pointer&quot;)
    }

    nodesEls
      .enter()
      .append(&quot;circle&quot;)
      .merge(nodesEls)
      .attr(&quot;cx&quot;, (forceNode) =&gt; forceNode.x!)
      .attr(&quot;cy&quot;, (forceNode) =&gt; forceNode.y!)
      .attr(&quot;r&quot;, () =&gt; this.state.radius)
      .attr(&quot;fill&quot;, &quot;black&quot;)
      .call(addInteraction)

    textsEls
      .enter()
      .append(&quot;text&quot;)
      .merge(textsEls)
      .text(getNodeText)
      .attr(&quot;x&quot;, (forceNode) =&gt; forceNode.x!)
      .attr(&quot;y&quot;, (forceNode) =&gt; forceNode.y!)
      .attr(&quot;dy&quot;, () =&gt; settings.textDY)
      .attr(&quot;id&quot;, getNodeId)
      .style(&quot;opacity&quot;, settings.defaultTextOpacity)
      .call(addInteraction)

    nodesEls.exit().remove()
    textsEls.exit().remove()
  }

  private getNodes() {
    type ForceNode = NodeData &amp; SimulationNodeDatum

    return this.elements.svgG.selectAll&lt;SVGCircleElement, ForceNode&gt;(&quot;circle&quot;)
  }
}

export { ChartConfig, ForceChart }
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 10 Feb 2022 00:16:15 GMT</p>
    </body>
  </html>
  