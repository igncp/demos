
  <!DOCTYPE html>
  <html>
    <head>
      <title>world-map.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/demos/world-map/world-map.ts</td><td class="">97.94%</td><td class="">95%</td><td class="">535</td><td class="">524</td><td class="">11</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  D3DragEvent,
  GeoPath,
  GeoPermissibleObjects,
  Selection,
  drag as dragD3,
  geoMercator,
  geoPath,
  interpolateBlues,
  interpolateRdYlGn,
  interpolateSpectral,
  interpolateTurbo,
  interpolateViridis,
  json,
  scaleLinear,
  select,
} from &quot;d3&quot;
import { feature } from &quot;topojson-client&quot;

import {
  COLOR_FNS_NUM,
  CONTAINER_ID,
  COUNTRY_CLASS,
  UPDATE_BUTTON_ID,
} from &quot;./ui-constants&quot;

type CountryData = GeoPermissibleObjects &amp; {
  id: number
}

const fetchData = () =&gt; json(`${ROOT_PATH}data/d3js/world-map/world.json`)

const transitionDuration = 1500

type WorldData = any // eslint-disable-line @typescript-eslint/no-explicit-any

type ChartConfig = {
  rootElId: string
  world: WorldData
}

type Bounds = [[number, number], [number, number]]

const calculateBounds = ({
  featuresData,
  projectionPath,
}: {
  featuresData: any[] // eslint-disable-line @typescript-eslint/no-explicit-any
  projectionPath: GeoPath
}) =&gt;
  featuresData.reduce&lt;Bounds&gt;(
    (...[acc, featureData]) =&gt; {
      const dataBounds = projectionPath.bounds(featureData)

      acc[0][0] = Math.min(acc[0][0], dataBounds[0][0])
      acc[0][1] = Math.min(acc[0][1], dataBounds[0][1])
      acc[1][0] = Math.max(acc[1][0], dataBounds[1][0])
      acc[1][1] = Math.max(acc[1][1], dataBounds[1][1])

      return acc
    },
    [
      [Infinity, Infinity],
      [-Infinity, -Infinity],
    ]
  )

const boundDrag = ({
  bounds,
  dragPoint,
  height,
  width,
}: {
  bounds: Bounds
  dragPoint: { draggedX: number; draggedY: number }
  height: number
  width: number
}) =&gt; {
  if (dragPoint.draggedX * -1 &lt; bounds[0][0]) {
    dragPoint.draggedX = bounds[0][0] * -1
  } else if (dragPoint.draggedX * -1 &gt; bounds[1][0] - width) {
    dragPoint.draggedX = (bounds[1][0] - width) * -1
  }

  if (dragPoint.draggedY * -1 &lt; bounds[0][1]) {
    dragPoint.draggedY = bounds[0][1] * -1
  } else if (dragPoint.draggedY * -1 &gt; bounds[1][1] - height) {
    dragPoint.draggedY = (bounds[1][1] - height) * -1
  }
}

type ChartElements = Readonly&lt;{
  backgroundSel: Selection&lt;SVGRectElement, unknown, HTMLElement, unknown&gt;
  contentSel: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  svgDragSel: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
  svgSel: Selection&lt;SVGSVGElement, unknown, HTMLElement, unknown&gt;
}&gt;

const addDropShadowFilter = ({
  deviation,
  slope,
  svg,
}: {
  deviation: number
  slope: number
  svg: Selection&lt;SVGSVGElement, unknown, HTMLElement, unknown&gt;
}) =&gt; {
  const defs = svg.append(&quot;defs&quot;)
  const filter = defs.append(&quot;filter&quot;).attr(&quot;id&quot;, `drop-shadow`)

  filter
    .append(&quot;feGaussianBlur&quot;)
    .attr(&quot;in&quot;, &quot;SourceAlpha&quot;)
    .attr(&quot;stdDeviation&quot;, deviation)

  filter.append(&quot;feOffset&quot;).attr(&quot;dx&quot;, 1).attr(&quot;dy&quot;, 1)
  filter
    .append(&quot;feComponentTransfer&quot;)
    .append(&quot;feFuncA&quot;)
    .attr(&quot;slope&quot;, slope)
    .attr(&quot;type&quot;, &quot;linear&quot;)

  const feMerge = filter.append(&quot;feMerge&quot;)

  feMerge.append(&quot;feMergeNode&quot;)

  feMerge.append(&quot;feMergeNode&quot;).attr(&quot;in&quot;, &quot;SourceGraphic&quot;)
}

const colorFns = [
  interpolateRdYlGn,
  interpolateSpectral,
  interpolateBlues,
  interpolateViridis,
  interpolateTurbo,
]

if (colorFns.length !== COLOR_FNS_NUM) {
  throw new Error(`Expected ${COLOR_FNS_NUM} color functions`)
}

class WorldMap {
  private readonly config: ChartConfig
  private readonly state: {
    colorFnIndex: number
    draggedX: number
    draggedY: number
    lastZoomId: number | null
  } = {
    colorFnIndex: 0,
    draggedX: 0,
    draggedY: 0,
    lastZoomId: null,
  }

  private dimensions!: {
    height: number
    width: number
  }

  private projectionPath!: GeoPath
  private bounds!: Bounds

  private readonly elements: ChartElements

  public constructor(config: ChartConfig) {
    this.config = config

    const {
      config: { rootElId },
    } = this

    const svgSel = select(`#${rootElId}`).append(&quot;svg&quot;)
    const svgDragSel = svgSel.append(&quot;g&quot;)
    const backgroundSel = svgDragSel
      .append(&quot;rect&quot;)
      .attr(&quot;class&quot;, &quot;background&quot;)
      .style(&quot;fill&quot;, &quot;#daedff&quot;)
    const contentSel = svgDragSel.append(&quot;g&quot;)

    addDropShadowFilter({
      deviation: 2,
      slope: 0.5,
      svg: svgSel,
    })

    this.elements = {
      backgroundSel,
      contentSel,
      svgDragSel,
      svgSel,
    }

    this.render()
    this.setupDrag()

    window.addEventListener(&quot;resize&quot;, this.handleWindowResize)
  }

  public teardown() {
    window.removeEventListener(&quot;resize&quot;, this.handleWindowResize)
  }

  public updateColors() {
    this.state.colorFnIndex += 1

    if (this.state.colorFnIndex &gt;= colorFns.length) {
      this.state.colorFnIndex = 0
    }

    this.render()
  }

  private setDimensions() {
    const {
      config: { rootElId },
    } = this
    const { width } = (
      document.getElementById(rootElId) as HTMLElement
    ).getBoundingClientRect()
    const height = 500

    this.dimensions = {
      height,
      width,
    }
  }

  private render() {
    const {
      config: { world },
      elements: { backgroundSel, svgSel },
    } = this

    this.setDimensions()

    const {
      dimensions: { height, width },
    } = this
    const projection = geoMercator()
      .center([0, 45.4])
      .scale(Math.max((150 * width) / 750, 140))
      .translate([width / 2, height / 2])

    this.projectionPath = geoPath().projection(projection)

    const { features: featuresData } = feature(
      world,
      world.objects.countries
    ) as any // eslint-disable-line @typescript-eslint/no-explicit-any

    this.bounds = calculateBounds({
      featuresData,
      projectionPath: this.projectionPath,
    })

    const colorScale = scaleLinear()
      .domain([0, featuresData.length - 1])
      .range([0, 1])

    const colorFn = (...[, countryIndex]: [unknown, number]) =&gt;
      colorFns[this.state.colorFnIndex](colorScale(countryIndex))

    svgSel.attr(&quot;width&quot;, width).attr(&quot;height&quot;, height)

    const backgroundSize = 100_000

    backgroundSel
      .on(&quot;click&quot;, this.setZoom as any) // eslint-disable-line @typescript-eslint/no-explicit-any
      .attr(&quot;height&quot;, backgroundSize)
      .attr(&quot;width&quot;, backgroundSize)
      .attr(
        &quot;transform&quot;,
        `translate(${Math.min(0, (backgroundSize - width) / -2)}, ${Math.min(
          0,
          (backgroundSize - height) / -2
        )})`
      )

    const countriesUpdateSel =
      this.getCountriesSel().data&lt;CountryData&gt;(featuresData)

    const countriesStrokeWidth = &quot;1px&quot;

    countriesUpdateSel.exit().remove()
    countriesUpdateSel
      .enter()
      .append(&quot;path&quot;)
      .attr(&quot;class&quot;, COUNTRY_CLASS)
      .style(&quot;stroke&quot;, &quot;#fff&quot;)
      .style(&quot;stroke-width&quot;, countriesStrokeWidth)
      .attr(&quot;filter&quot;, &quot;url(#drop-shadow)&quot;)

    const countriesSel = this.getCountriesSel()
      .attr(&quot;d&quot;, this.projectionPath)
      .style(&quot;fill&quot;, colorFn)
      .on(&quot;mouseenter&quot;, function handleCountryMouseEnter() {
        select(this)
          .attr(&quot;filter&quot;, &quot;url(#drop-shadow)&quot;)
          .style(&quot;stroke-width&quot;, &quot;2px&quot;)
      })
      .on(&quot;mouseleave&quot;, () =&gt; {
        countriesSel
          .attr(&quot;filter&quot;, &quot;url(#drop-shadow)&quot;)
          .style(&quot;stroke-width&quot;, countriesStrokeWidth)
      })
      .on(&quot;click&quot;, this.setZoom)

    this.updateDrag()
  }

  private getCountriesSel() {
    return this.elements.contentSel.selectAll&lt;SVGPathElement, CountryData&gt;(
      `.${COUNTRY_CLASS}`
    )
  }

  private updateDrag() {
    const {
      bounds,
      dimensions: { height, width },
      elements: { svgDragSel },
    } = this

    boundDrag({
      bounds,
      dragPoint: this.state,
      height,
      width,
    })

    svgDragSel.attr(
      &quot;transform&quot;,
      `translate(${this.state.draggedX},${this.state.draggedY})`
    )
  }

  private setupDrag() {
    const {
      elements: { svgSel },
    } = this

    const dragHandler = (
      dragEvent: D3DragEvent&lt;SVGSVGElement, unknown, unknown&gt;
    ) =&gt; {
      this.state.draggedX += dragEvent.dx
      this.state.draggedY += dragEvent.dy

      this.updateDrag()
    }

    const dragBehavior = dragD3&lt;SVGSVGElement, unknown&gt;().on(
      &quot;drag&quot;,
      dragHandler
    )

    svgSel.style(&quot;cursor&quot;, &quot;move&quot;).call(dragBehavior).on(&quot;drag&quot;, dragHandler)
  }

  private readonly setZoom = (...[, countryData]: [unknown, CountryData]) =&gt; {
    const {
      dimensions: { height, width },
    } = this
    const countriesSel = this.getCountriesSel()

    if (!(countryData as unknown) || this.state.lastZoomId === countryData.id) {
      this.state.lastZoomId = null

      countriesSel
        .transition()
        .duration(transitionDuration)
        .attr(
          &quot;transform&quot;,
          `translate(${width / 2},${height / 2})scale(${1})translate(${
            -width / 2
          },${-height / 2})`
        )

      return
    }

    this.state.lastZoomId = countryData.id

    const centroid = this.projectionPath.centroid(countryData)

    const x = centroid[0]
    const y = centroid[1]

    countriesSel
      .transition()
      .duration(transitionDuration)
      .attr(
        &quot;transform&quot;,
        `translate(${width / 2},${height / 2})scale(${8})translate(${-x},${-y})`
      )
  }

  private readonly handleWindowResize = () =&gt; {
    this.render()
  }
}

const main = async () =&gt; {
  const world = await fetchData()

  const worldMap = new WorldMap({
    rootElId: CONTAINER_ID,
    world,
  })

  document.getElementById(UPDATE_BUTTON_ID)?.addEventListener(&quot;click&quot;, () =&gt; {
    worldMap.updateColors()
  })
}

export { CONTAINER_ID, UPDATE_BUTTON_ID }

export default main
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/demos/world-map/world-map.ts&quot;,&quot;line&quot;:34,&quot;character&quot;:5,&quot;text&quot;:&quot;WorldData&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/world-map/world-map.ts&quot;,&quot;line&quot;:38,&quot;character&quot;:2,&quot;text&quot;:&quot;world&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/world-map/world-map.ts&quot;,&quot;line&quot;:38,&quot;character&quot;:9,&quot;text&quot;:&quot;WorldData&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/world-map/world-map.ts&quot;,&quot;line&quot;:51,&quot;character&quot;:14,&quot;text&quot;:&quot;featureData&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/world-map/world-map.ts&quot;,&quot;line&quot;:230,&quot;character&quot;:16,&quot;text&quot;:&quot;world&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/world-map/world-map.ts&quot;,&quot;line&quot;:246,&quot;character&quot;:22,&quot;text&quot;:&quot;featuresData&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/world-map/world-map.ts&quot;,&quot;line&quot;:248,&quot;character&quot;:6,&quot;text&quot;:&quot;world&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/world-map/world-map.ts&quot;,&quot;line&quot;:248,&quot;character&quot;:12,&quot;text&quot;:&quot;objects&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/world-map/world-map.ts&quot;,&quot;line&quot;:248,&quot;character&quot;:20,&quot;text&quot;:&quot;countries&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/world-map/world-map.ts&quot;,&quot;line&quot;:257,&quot;character&quot;:18,&quot;text&quot;:&quot;featuresData&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/demos/world-map/world-map.ts&quot;,&quot;line&quot;:257,&quot;character&quot;:31,&quot;text&quot;:&quot;length&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Mon, 10 Jan 2022 00:15:23 GMT</p>
    </body>
  </html>
  