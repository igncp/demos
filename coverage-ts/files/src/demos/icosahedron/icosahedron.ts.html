
  <!DOCTYPE html>
  <html>
    <head>
      <title>icosahedron.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/demos/icosahedron/icosahedron.ts</td><td class="">100.00%</td><td class="">95%</td><td class="">389</td><td class="">389</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  GeoProjection,
  Selection,
  geoOrthographic,
  polygonArea,
  polygonHull,
  scaleOrdinal,
  schemePastel2,
  select,
  timer,
} from &quot;d3&quot;
import textures from &quot;textures&quot;

import * as styles from &quot;./icosahedron.module.css&quot;
import { CONTAINER_ID } from &quot;./ui-constants&quot;

type IcosahedronOpts = {
  rootElId: string
}

type Position = [number, number, number]
type Point2D = [number, number]

type Hull = Point2D[]
type Face = Hull
type FaceWithPolygon = Face &amp; {
  faceIndex: number
  polygon?: Hull
}

const hoverTexture = textures.lines().thicker().background(&quot;orange&quot;)

class Icosahedron {
  private readonly rootElId: string

  private readonly config: Readonly&lt;{
    defaultVelocity: number[]
    height: number
    rotationFactor1: number
    rotationFactor2: number
    t0: number
    zeroVelocity: number[]
  }&gt;

  private dom!: {
    faces: Selection&lt;SVGPathElement, FaceWithPolygon, SVGGElement, unknown&gt;
    gSel: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;
    projection: GeoProjection
    svg: Selection&lt;SVGSVGElement, unknown, HTMLElement, unknown&gt;
  }

  private vars!: {
    selectedIndex: number | null
    velocity: number[] | null
  }

  public constructor(opts: IcosahedronOpts) {
    this.rootElId = opts.rootElId

    this.config = {
      defaultVelocity: [1, 0.4, 0.07],
      height: 500,
      rotationFactor1: 1 / 1000,
      rotationFactor2: 4,
      t0: Date.now(),
      zeroVelocity: [0, 0, 0],
    }

    this.setVars()
    this.setDom()
    this.setDimensions()

    window.addEventListener(&quot;resize&quot;, this.handleResize)
  }

  private static getIcosahedronFaces(): FaceWithPolygon[] {
    const faces: Face[] = []
    const y = (Math.atan2(1, 2) * 180) / Math.PI

    for (let x = 0; x &lt; 360; x += 360 / 5) {
      faces.push(
        [
          [x + 0, -90],
          [x + 0, -y],
          [x + 72, -y],
        ],
        [
          [x + 36, y],
          [x + 72, -y],
          [x + 0, -y],
        ],
        [
          [x + 36, y],
          [x + 0, -y],
          [x - 36, y],
        ],
        [
          [x + 36, y],
          [x - 36, y],
          [x - 36, 90],
        ]
      )
    }

    return faces.map((...[face, faceIndex]) =&gt;
      Object.assign(face, {
        faceIndex,
      })
    )
  }

  public start() {
    timer(() =&gt; this.timer())
  }

  public teardown() {
    window.removeEventListener(&quot;resize&quot;, this.handleResize)
  }

  private setDom() {
    const rootEl = document.getElementById(this.rootElId) as HTMLElement

    rootEl.classList.add(styles.icosahedronChart)

    const projection = geoOrthographic().scale(this.config.height / 2 - 10)
    const svg = select(`#${this.rootElId}`)
      .append(&quot;svg&quot;)
      .attr(&quot;height&quot;, this.config.height)

    svg.call(hoverTexture)

    const gSel = svg.append(&quot;g&quot;)

    const color = scaleOrdinal&lt;number, string&gt;(schemePastel2)
    const { vars } = this

    const setColor = (faceData: FaceWithPolygon) =&gt; {
      if (vars.selectedIndex === faceData.faceIndex) {
        return hoverTexture.url()
      }

      return color(faceData.faceIndex)
    }

    const faces = gSel
      .selectAll(&quot;path&quot;)
      .data&lt;FaceWithPolygon&gt;(Icosahedron.getIcosahedronFaces())
      .enter()
      .append(&quot;path&quot;)
      .each((face) =&gt; {
        face.polygon = polygonHull(face.map(projection) as Face)!
      })
      .style(&quot;fill&quot;, setColor)
      .on(&quot;mouseenter&quot;, function handleMouseEnter() {
        select(this).style(&quot;fill&quot;, hoverTexture.url())
      })
      .on(&quot;mouseleave&quot;, function handleMouseLeave() {
        select&lt;SVGPathElement, FaceWithPolygon&gt;(this).style(&quot;fill&quot;, setColor)
      })
      .on(&quot;click&quot;, (...[, face]) =&gt; {
        if (this.vars.selectedIndex === face.faceIndex) {
          this.vars.velocity = this.config.defaultVelocity
          this.vars.selectedIndex = null
        } else {
          this.vars.velocity = this.config.zeroVelocity
          this.vars.selectedIndex = face.faceIndex
        }

        faces.style(&quot;fill&quot;, setColor)
      })

    this.dom = {
      faces,
      gSel,
      projection,
      svg,
    }
  }

  private setDimensions() {
    const polygonSize = 475
    const { width } = (
      document.getElementById(this.rootElId) as HTMLElement
    ).getBoundingClientRect()

    this.dom.svg.attr(&quot;width&quot;, width)

    const scale = width &lt; polygonSize ? 0.5 : 1
    const verticalTranslate = scale !== 1 ? (polygonSize * scale) / 2 : 0

    this.dom.gSel.attr(
      &quot;transform&quot;,
      `translate(${
        width / 2 - polygonSize * scale
      }, ${verticalTranslate}) scale(${scale})`
    )
  }

  private setVars() {
    this.vars = {
      selectedIndex: null,
      velocity: this.config.defaultVelocity,
    }
  }

  private calcNewPosition({
    position,
    time,
  }: {
    position: Position
    time: number
  }): Position {
    const {
      vars: { velocity },
    } = this

    return [
      velocity![0] *
        Math.abs(
          Math.sin(time * this.config.rotationFactor1) *
            this.config.rotationFactor2
        ) +
        position[0],
      velocity![1] + position[1],
      position[2] + velocity![2],
    ]
  }

  private timer() {
    const time = Date.now() - this.config.t0
    const originalPos = this.dom.projection.rotate()

    this.dom.projection.rotate(
      this.calcNewPosition({ position: originalPos, time })
    )

    this.dom.faces
      .each((face) =&gt; {
        face.forEach((...[point, pointIndex]: [Point2D, number]) =&gt; {
          face.polygon![pointIndex] = this.dom.projection(point) as Point2D

          return null
        })
      })
      .style(&quot;display&quot;, (face) =&gt; {
        const area = polygonArea(face.polygon!)

        if (area &gt; 0) {
          return null
        }

        return &quot;none&quot;
      })
      .attr(&quot;d&quot;, (face) =&gt; `M${face.polygon!.join(&quot;L&quot;)}Z`)

    return null
  }

  private readonly handleResize = () =&gt; {
    this.setDimensions()
  }
}

const main = () =&gt; {
  const chart = new Icosahedron({
    rootElId: CONTAINER_ID,
  })

  chart.start()

  return Promise.resolve()
}

export { CONTAINER_ID }

export default main
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Tue, 01 Feb 2022 19:55:50 GMT</p>
    </body>
  </html>
  