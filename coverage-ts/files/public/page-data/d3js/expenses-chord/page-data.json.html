
  <!DOCTYPE html>
  <html>
    <head>
      <title>page-data.json</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">public/page-data/d3js/expenses-chord/page-data.json</td><td class="">100.00%</td><td class="">95%</td><td class="">0</td><td class="">0</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">{&quot;componentChunkName&quot;:&quot;component---src-pages-d-3-js-expenses-chord-tsx&quot;,&quot;path&quot;:&quot;/d3js/expenses-chord/&quot;,&quot;result&quot;:{&quot;pageContext&quot;:{&quot;demoInfo&quot;:{&quot;data&quot;:[&quot;data.json&quot;],&quot;docs&quot;:[],&quot;isCompleted&quot;:false,&quot;name&quot;:&quot;Expenses Chord&quot;,&quot;notes&quot;:[&quot;TODO: Review checklist for remaining refactors&quot;,&quot;TODO: add textPath: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/textPath&quot;,&quot;performance is not great when displaying all elements due to the large number of elements, canvas may be a better solution&quot;],&quot;sources&quot;:[&quot;https://datos.gob.es/en/catalogo/ea0010587-distribucion-del-gasto-en-destino-de-cada-pais-de-residencia-segun-comunidad-autonoma-gdve-identificador-api-37671&quot;,&quot;https://observablehq.com/@d3/directed-chord-diagram&quot;],&quot;summary&quot;:[],&quot;category&quot;:&quot;d3js&quot;,&quot;files&quot;:{&quot;cssModule&quot;:&quot;.chartWrapper {\n  border: solid 1px black;\n  overflow: hidden;\n}\n\n.chordGroup {\n  cursor: pointer;\n}\n\n.countriesSelect {\n  margin-right: 20px;\n}\n\n.groupText {\n  fill: black;\n  user-select: none;\n}\n\n.ribbon {\n  cursor: pointer;\n  mix-blend-mode: multiply;\n}\n\ndiv.sliderTime {\n  background: #c4dcf9;\n  margin: 20px 0;\n}\n&quot;,&quot;demo&quot;:[{&quot;content&quot;:&quot;import { renderChart } from \&quot;./expenses-chord-chart\&quot;\nimport {\n  ALL_ID,\n  createChartConfig,\n  createInitialState,\n  fetchData,\n  getAreas,\n} from \&quot;./expenses-chord-chart-data\&quot;\n\nconst main = async () =&gt; {\n  const data = await fetchData()\n  const state = createInitialState()\n  const { countries, regions } = getAreas(data)\n  const chartConfig = createChartConfig({\n    countries,\n    data,\n    regions,\n    state,\n  })\n\n  const { renderItems } = renderChart(chartConfig)\n\n  $(\&quot;#slider-time\&quot;).slider({\n    change: (_e, { value }) =&gt; {\n      if (value === 3) {\n        // @TODO: error in this case, find why\n        return\n      }\n\n      state.timeIndex = value!\n      renderItems()\n    },\n    max: data[countries[0]][regions[0]].length - 1,\n    min: 0,\n  })\n\n  const setupSelect = (\n    vals: string[],\n    id: string,\n    onChange: (v: string) =&gt; void\n  ) =&gt; {\n    const selectEl = document.getElementById(id) as HTMLSelectElement\n\n    ;[ALL_ID].concat(vals).forEach((val) =&gt; {\n      const option = document.createElement(\&quot;option\&quot;)\n\n      option.setAttribute(\&quot;value\&quot;, val)\n      option.innerText = val\n\n      selectEl.appendChild(option)\n    })\n\n    selectEl.addEventListener(\&quot;change\&quot;, () =&gt; {\n      onChange(selectEl.value)\n    })\n  }\n\n  setupSelect(countries, \&quot;countries-select\&quot;, (newSelected: string) =&gt; {\n    state.selectedCountry = newSelected\n    renderItems()\n  })\n  setupSelect(regions, \&quot;regions-select\&quot;, (newSelected: string) =&gt; {\n    state.selectedRegion = newSelected\n    renderItems()\n  })\n}\n\nexport default main\n&quot;,&quot;fileName&quot;:&quot;expenses-chord&quot;},{&quot;content&quot;:&quot;import { json } from \&quot;d3\&quot;\n\nimport { ChartConfig, DisplayType, RibbonType } from \&quot;./expenses-chord-chart\&quot;\n\nexport const ALL_ID = \&quot;All\&quot;\n\ntype State = {\n  selectedCountry: string\n  selectedRegion: string\n  timeIndex: number\n}\n\ntype DataItem = {\n  value: number | null\n  year: number\n}\n\ntype Data = {\n  [country: string]: {\n    [region: string]: DataItem[]\n  }\n}\n\nexport const createInitialState = (): State =&gt; ({\n  selectedCountry: ALL_ID,\n  selectedRegion: ALL_ID,\n  timeIndex: 0,\n})\n\nexport const getAreas = (data: Data) =&gt; {\n  const countries = Object.keys(data).sort()\n  const regions = Object.keys(data[countries[0]]).sort()\n\n  return { countries, regions }\n}\n\nexport const fetchData = () =&gt;\n  (json(\n    `${ROOT_PATH}data/d3js/expenses-chord/data.json`\n  ) as unknown) as Promise&lt;Data&gt;\n\nexport const createChartConfig = ({\n  countries,\n  data,\n  regions,\n  state,\n}: {\n  countries: string[]\n  data: Data\n  regions: string[]\n  state: State\n}): ChartConfig =&gt; {\n  const names = countries.concat(regions)\n\n  const getChordMatrix: ChartConfig[\&quot;getChordMatrix\&quot;] = () =&gt; {\n    const matrix = names.map((maybeCountry) =&gt; {\n      if (!data[maybeCountry] as unknown) {\n        return names.map(() =&gt; 0)\n      }\n\n      if (![ALL_ID, maybeCountry].includes(state.selectedCountry)) {\n        return names.map(() =&gt; 0)\n      }\n\n      return names.map((maybeRegion) =&gt; {\n        const {\n          [maybeCountry]: { [maybeRegion]: dataItem },\n        } = data\n\n        if (!dataItem as unknown) {\n          return 0\n        }\n\n        if (![ALL_ID, maybeRegion].includes(state.selectedRegion)) {\n          return 0\n        }\n\n        return dataItem[state.timeIndex].value\n      })\n    }) as number[][]\n\n    return matrix\n  }\n\n  // @TODO: confirm title\n  const getChordTitle: ChartConfig[\&quot;getChordTitle\&quot;] = (\n    sourceIndex,\n    targetIndex,\n    sourceValue\n  ) =&gt;\n    `People from \&quot;${names[sourceIndex]}\&quot; spend into \&quot;${names[targetIndex]}\&quot;: ${sourceValue}`\n\n  const getChordGroupTitle: ChartConfig[\&quot;getChordGroupTitle\&quot;] = (d) =&gt; d\n\n  const getRibbonGroupIdColor: ChartConfig[\&quot;getRibbonGroupIdColor\&quot;] = (\n    sourceGroupId,\n    targetGroupId\n  ) =&gt; (state.selectedRegion === ALL_ID ? targetGroupId : sourceGroupId)\n\n  const getDisplayTypeOnGroupClick: ChartConfig[\&quot;getDisplayTypeOnGroupClick\&quot;] = (\n    chordGroupId\n  ) =&gt;\n    countries.includes(chordGroupId) ? DisplayType.Source : DisplayType.Target\n\n  const getRibbonType: ChartConfig[\&quot;getRibbonType\&quot;] = () =&gt;\n    state.selectedCountry !== ALL_ID &amp;&amp; state.selectedRegion !== ALL_ID\n      ? RibbonType.Common\n      : RibbonType.Arrow\n\n  return {\n    chordGroupsIds: names,\n    getChordGroupTitle,\n    getChordMatrix,\n    getChordTitle,\n    getDisplayTypeOnGroupClick,\n    getRibbonGroupIdColor,\n    getRibbonType,\n    rootElId: \&quot;chart\&quot;,\n  }\n}\n&quot;,&quot;fileName&quot;:&quot;expenses-chord-chart-data&quot;},{&quot;content&quot;:&quot;import {\n  Chord,\n  ChordGroup,\n  arc as arcD3,\n  chordDirected,\n  descending as descendingD3,\n  easeCircle,\n  interpolate,\n  ribbonArrow as ribbonArrowD3,\n  ribbon as ribbonD3,\n  scaleOrdinal,\n  schemeTableau10,\n  select,\n  zoom,\n} from \&quot;d3\&quot;\nimport { v1 as uuid } from \&quot;uuid\&quot;\n\nimport * as styles from \&quot;./expenses-chord.module.css\&quot;\n\nconst height = 800\n\nexport enum DisplayType {\n  Source = \&quot;source\&quot;,\n  Target = \&quot;target\&quot;,\n}\n\nexport enum RibbonType {\n  Arrow = \&quot;arrow\&quot;,\n  Common = \&quot;common\&quot;,\n}\n\ntype ChartState = {\n  lastFocused: string | null\n}\n\nconst durations = {\n  ribbonAnimation: 1000,\n  zoom: 500,\n} as const\n\nconst easingFn = easeCircle\n\nconst zoomed = function (this: Element, zoomEvent: any) {\n  select(this)\n    .transition()\n    .duration(durations.zoom)\n    .attr(\&quot;transform\&quot;, zoomEvent.transform)\n}\n\nexport type ChartConfig = {\n  chordGroupsIds: string[]\n  getChordGroupTitle: (groupId: string) =&gt; string\n  getChordMatrix: () =&gt; number[][]\n  getChordTitle: (\n    sourceIndex: number,\n    targetIndex: number,\n    sourceValue: number,\n    targetValue: number\n  ) =&gt; string\n  getDisplayTypeOnGroupClick: (chordGroupId: string) =&gt; DisplayType\n  getRibbonGroupIdColor: (\n    sourceGroupId: string,\n    targetGroupId: string\n  ) =&gt; string\n  getRibbonType: () =&gt; RibbonType\n  rootElId: string\n}\n\nexport const renderChart = (chartConfig: ChartConfig) =&gt; {\n  const { rootElId } = chartConfig\n\n  const chartState: ChartState = {\n    lastFocused: null,\n  }\n\n  const { chordGroupsIds } = chartConfig\n\n  const color = scaleOrdinal(chordGroupsIds, schemeTableau10)\n\n  const { width } = (document.getElementById(\n    rootElId\n  ) as HTMLElement).getBoundingClientRect()\n\n  const innerRadius = Math.min(width, height) * 0.5 - 20\n  const outerRadius = innerRadius + 20\n\n  const ribbonCommon = (r: any) =&gt;\n    r.radius(innerRadius - 0.5).padAngle(1 / innerRadius)\n\n  const ribbonArrow = ribbonCommon(ribbonArrowD3())\n  const ribbon = ribbonCommon(ribbonD3())\n\n  const zoomBehavior = zoom()\n    .extent([\n      [0, 0],\n      [width / 2, height / 2],\n    ])\n    .on(\&quot;end\&quot;, zoomed)\n\n  const totalHeight = height + 50\n\n  const svg = select(`#${rootElId}`)\n    .attr(\&quot;class\&quot;, styles.chartWrapper)\n    .append(\&quot;svg\&quot;)\n    .attr(\&quot;width\&quot;, width)\n    .attr(\&quot;height\&quot;, totalHeight)\n    .append(\&quot;g\&quot;)\n    .attr(\&quot;transform\&quot;, `translate(${width / 2}, ${totalHeight / 2})`)\n    .append(\&quot;g\&quot;)\n    .call(zoomBehavior as any)\n    .on(\&quot;dblclick.zoom\&quot;, null)\n\n  // this rect is to allow zooming\n  svg\n    .append(\&quot;rect\&quot;)\n    .attr(\&quot;fill\&quot;, \&quot;#fff\&quot;)\n    .attr(\&quot;width\&quot;, width)\n    .attr(\&quot;height\&quot;, height)\n    .attr(\&quot;transform\&quot;, `translate(-${width / 2}, -${totalHeight / 2})`)\n\n  const textId = uuid()\n\n  const chord = chordDirected()\n    .padAngle(12 / innerRadius)\n    .sortSubgroups(descendingD3)\n    .sortChords(descendingD3)\n\n  svg\n    .append(\&quot;path\&quot;)\n    .attr(\&quot;fill\&quot;, \&quot;none\&quot;)\n    .attr(\&quot;id\&quot;, textId)\n    .attr(\n      \&quot;d\&quot;,\n      arcD3()({\n        endAngle: 2 * Math.PI,\n        innerRadius: 0,\n        outerRadius,\n        startAngle: 0,\n      }) as string\n    )\n\n  const arc = arcD3&lt;d3.ChordGroup&gt;()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  const ribbonContainer = svg.append(\&quot;g\&quot;).attr(\&quot;fill-opacity\&quot;, 0.75)\n  const groupContainer = svg\n    .append(\&quot;g\&quot;)\n    .attr(\&quot;font-family\&quot;, \&quot;sans-serif\&quot;)\n    .attr(\&quot;font-size\&quot;, 10)\n\n  const renderItems = () =&gt; {\n    const usedRibbon =\n      chartConfig.getRibbonType() === RibbonType.Common ? ribbon : ribbonArrow\n\n    const matrix = chartConfig.getChordMatrix()\n    const chords = chord(matrix)\n\n    const initialRibbonsData = ribbonContainer\n      .selectAll&lt;SVGPathElement, Chord&gt;(`.${styles.ribbon}`)\n      .data()\n      .reduce((acc, ribbonNode) =&gt; {\n        acc[\n          `${ribbonNode.source.index}_${ribbonNode.target.index}`\n        ] = ribbonNode\n\n        return acc\n      }, {} as { [k: string]: Chord | undefined })\n\n    const fillRibbon = (d: Chord) =&gt;\n      color(\n        chartConfig.getRibbonGroupIdColor(\n          chordGroupsIds[d.source.index],\n          chordGroupsIds[d.target.index]\n        )\n      )\n\n    const ribbons = ribbonContainer\n      .selectAll&lt;SVGPathElement, Chord&gt;(`.${styles.ribbon}`)\n      .data&lt;Chord&gt;(chords, (d) =&gt; `${d.source.index}_${d.target.index}`)\n      .join(\n        (enter) =&gt; {\n          const el = enter\n            .append(\&quot;path\&quot;)\n            .attr(\&quot;class\&quot;, styles.ribbon)\n            .attr(\&quot;fill\&quot;, fillRibbon)\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .attrTween(\&quot;d\&quot;, (finalRibbon) =&gt; {\n              const initialRibbon = {\n                source: {\n                  endAngle: 0,\n                  startAngle: 0,\n                },\n                target: {\n                  endAngle: 0,\n                  startAngle: 0,\n                },\n              }\n              const interpolateSource = interpolate(\n                initialRibbon.source,\n                finalRibbon.source\n              )\n              const interpolateTarget = interpolate(\n                initialRibbon.target,\n                finalRibbon.target\n              )\n\n              return (t) =&gt; {\n                const interpolated = {\n                  source: interpolateSource(t),\n                  target: interpolateTarget(t),\n                }\n\n                return usedRibbon(interpolated)\n              }\n            })\n\n          return el\n        },\n        (update) =&gt; {\n          update\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .attr(\&quot;fill\&quot;, fillRibbon)\n            .attrTween(\&quot;d\&quot;, (finalRibbon) =&gt; {\n              const {\n                [`${finalRibbon.source.index}_${finalRibbon.target.index}`]: initialRibbon,\n              } = initialRibbonsData\n\n              if (!initialRibbon) {\n                return () =&gt; usedRibbon(finalRibbon)\n              }\n\n              const interpolateSource = interpolate(\n                initialRibbon.source,\n                finalRibbon.source\n              )\n              const interpolateTarget = interpolate(\n                initialRibbon.target,\n                finalRibbon.target\n              )\n\n              return (t) =&gt; {\n                const interpolated = {\n                  source: interpolateSource(t),\n                  target: interpolateTarget(t),\n                }\n\n                return usedRibbon(interpolated)\n              }\n            })\n\n          return update\n        }\n      )\n\n    ribbons\n      .attr(\&quot;title\&quot;, (d) =&gt;\n        chartConfig.getChordTitle(\n          d.source.index,\n          d.target.index,\n          d.source.value,\n          d.target.value\n        )\n      )\n      .on(\&quot;click\&quot;, function (_e, d) {\n        const el = select(this)\n        const chordGroupId = `${chordGroupsIds[d.source.index]}_${\n          chordGroupsIds[d.target.index]\n        }`\n\n        if (chartState.lastFocused === chordGroupId) {\n          ribbons.attr(\&quot;display\&quot;, \&quot;block\&quot;)\n          chartState.lastFocused = null\n        } else {\n          ribbons.attr(\&quot;display\&quot;, \&quot;none\&quot;)\n          el.attr(\&quot;display\&quot;, \&quot;block\&quot;)\n          chartState.lastFocused = chordGroupId\n        }\n      })\n\n    $(`.${styles.ribbon}`).tooltip({\n      track: true,\n    })\n\n    const getGroupText = (d: ChordGroup) =&gt; {\n      if (d.endAngle - d.startAngle &lt; 0.07) {\n        return \&quot;\&quot;\n      }\n\n      return chartConfig.getChordGroupTitle(chordGroupsIds[d.index])\n    }\n\n    const initialGroupData = groupContainer\n      .selectAll(`.${styles.chordGroup}`)\n      .data()\n\n    groupContainer\n      .selectAll&lt;SVGGElement, ChordGroup&gt;(`.${styles.chordGroup}`)\n      .data&lt;ChordGroup&gt;(chords.groups, (chordGroup) =&gt; chordGroup.index)\n      .join(\n        (enter) =&gt; {\n          const el = enter\n            .append(\&quot;g\&quot;)\n            .attr(\&quot;class\&quot;, styles.chordGroup)\n            .attr(\&quot;title\&quot;, (d) =&gt;\n              chartConfig.getChordGroupTitle(chordGroupsIds[d.index])\n            )\n\n          el.append(\&quot;path\&quot;)\n            .attr(\&quot;class\&quot;, \&quot;group-path\&quot;)\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .ease(easingFn)\n            .attrTween(\&quot;d\&quot;, (finalGroup) =&gt; {\n              const interpolateFn = interpolate&lt;ChordGroup&gt;(\n                {\n                  ...finalGroup,\n                  endAngle: 0,\n                  startAngle: 0,\n                },\n                finalGroup\n              )\n\n              return (t) =&gt; arc(interpolateFn(t))!\n            })\n            .attr(\&quot;fill\&quot;, (d) =&gt; color(chordGroupsIds[d.index]))\n            .attr(\&quot;stroke\&quot;, \&quot;#fff\&quot;)\n\n          el.append(\&quot;text\&quot;)\n            .attr(\&quot;dy\&quot;, -3)\n            .append(\&quot;textPath\&quot;)\n            .attr(\&quot;xlink:href\&quot;, `#${textId}`)\n            .attr(\&quot;class\&quot;, styles.groupText)\n            .text(getGroupText)\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .ease(easingFn)\n            .attr(\&quot;startOffset\&quot;, (d) =&gt; d.startAngle * outerRadius)\n\n          el.on(\&quot;click\&quot;, (_e, d) =&gt; {\n            const { [d.index]: chordGroupId } = chordGroupsIds\n            const latestRibbons = ribbonContainer.selectAll&lt;\n              SVGPathElement,\n              Chord\n            &gt;(`.${styles.ribbon}`)\n\n            if (chartState.lastFocused === chordGroupId) {\n              latestRibbons.attr(\&quot;display\&quot;, () =&gt; \&quot;block\&quot;)\n              chartState.lastFocused = null\n\n              return\n            }\n\n            chartState.lastFocused = chordGroupId\n\n            if (\n              chartConfig.getDisplayTypeOnGroupClick(chordGroupId) ===\n              DisplayType.Source\n            ) {\n              latestRibbons.attr(\&quot;display\&quot;, (d2) =&gt;\n                d2.source.index === d.index ? \&quot;block\&quot; : \&quot;none\&quot;\n              )\n\n              return\n            }\n\n            latestRibbons.attr(\&quot;display\&quot;, (d2) =&gt;\n              d2.target.index === d.index ? \&quot;block\&quot; : \&quot;none\&quot;\n            )\n          })\n\n          $(`.${styles.chordGroup}`).tooltip({\n            track: true,\n          })\n\n          return el\n        },\n        (update) =&gt; {\n          update\n            .select(\&quot;.group-path\&quot;)\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .attrTween(\&quot;d\&quot;, (finalGroup, idx) =&gt; {\n              const { [idx]: initialGroup } = initialGroupData\n              const interpolateFn = interpolate(initialGroup, finalGroup)\n\n              return (t) =&gt; arc(interpolateFn(t)) as string\n            })\n\n          update\n            .select(`.${styles.groupText}`)\n            .text(getGroupText)\n            .transition()\n            .duration(durations.ribbonAnimation)\n            .attr(\&quot;startOffset\&quot;, (d) =&gt; d.startAngle * outerRadius)\n\n          return update\n        },\n        (exit) =&gt; exit.remove()\n      )\n      .attr(\&quot;class\&quot;, styles.chordGroup)\n  }\n\n  renderItems()\n\n  return {\n    renderItems,\n  }\n}\n&quot;,&quot;fileName&quot;:&quot;expenses-chord-chart&quot;}],&quot;page&quot;:{&quot;content&quot;:&quot;import React from \&quot;react\&quot;\n\nimport { DemoPageProps } from \&quot;@/common\&quot;\n\nimport Demo from \&quot;@/components/demo\&quot;\n\nimport main from \&quot;@/demos/expenses-chord/expenses-chord\&quot;\nimport * as styles from \&quot;@/demos/expenses-chord/expenses-chord.module.css\&quot;\n\nconst ExpensesChord = ({ pageContext }: DemoPageProps) =&gt; (\n  &lt;Demo\n    links={[\&quot;/vendors/jquery-ui/themes/base/jquery-ui.min.css\&quot;]}\n    main={main}\n    pageContext={pageContext}\n    scripts={[\&quot;/vendors/jquery-ui/jquery-ui.min.js\&quot;]}\n  &gt;\n    &lt;div&gt;Time Item:&lt;/div&gt;\n    &lt;div className={styles.sliderTime} id=\&quot;slider-time\&quot; /&gt;\n    &lt;p&gt;\n      &lt;span&gt;Countries:&lt;/span&gt;\n      &lt;select className={styles.countriesSelect} id=\&quot;countries-select\&quot; /&gt;\n      &lt;span&gt;Regions:&lt;/span&gt;\n      &lt;select id=\&quot;regions-select\&quot; /&gt;\n    &lt;/p&gt;\n    &lt;div id=\&quot;chart\&quot; /&gt;\n  &lt;/Demo&gt;\n)\n\nexport default ExpensesChord\n&quot;,&quot;type&quot;:&quot;tsx&quot;}},&quot;key&quot;:&quot;expenses-chord&quot;},&quot;meta&quot;:{&quot;description&quot;:&quot;&quot;}}},&quot;staticQueryHashes&quot;:[]}</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 19 Aug 2021 23:11:45 GMT</p>
    </body>
  </html>
  