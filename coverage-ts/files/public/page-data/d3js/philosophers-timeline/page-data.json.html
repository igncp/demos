
  <!DOCTYPE html>
  <html>
    <head>
      <title>page-data.json</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">public/page-data/d3js/philosophers-timeline/page-data.json</td><td class="">100.00%</td><td class="">95%</td><td class="">0</td><td class="">0</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">{&quot;componentChunkName&quot;:&quot;component---src-pages-d-3-js-philosophers-timeline-tsx&quot;,&quot;path&quot;:&quot;/d3js/philosophers-timeline/&quot;,&quot;result&quot;:{&quot;pageContext&quot;:{&quot;demoInfo&quot;:{&quot;dataFiles&quot;:[&quot;data.csv&quot;],&quot;docs&quot;:[],&quot;isCompleted&quot;:true,&quot;name&quot;:&quot;Philosophers Timeline&quot;,&quot;notes&quot;:[&quot;Change to bootstrap tooltip&quot;,&quot;Add dynamic text lengths (adding two dots)&quot;,&quot;Improve performance (a lot) removing the drop-shadow while brushing&quot;,&quot;Click item to search&quot;,&quot;Window resize is not supported&quot;],&quot;sources&quot;:[&quot;http://bl.ocks.org/rengel-de/5603464&quot;],&quot;summary&quot;:[],&quot;category&quot;:&quot;d3js&quot;,&quot;files&quot;:{&quot;cssModule&quot;:&quot;.timelineChart {\n  text {\n    text-shadow: 0.5px 0.5px 0.5px #ccc;\n  }\n\n  .axis {\n    fill: #808080;\n    font-family: sans-serif;\n    font-size: 10px;\n  }\n\n  .axis line {\n    shape-rendering: crispEdges;\n    stroke: grey;\n    stroke-width: 1;\n  }\n\n  .axis path {\n    shape-rendering: crispEdges;\n    stroke: grey;\n    stroke-width: 1;\n  }\n\n  .band {\n    fill: #fff;\n  }\n\n  .bandLabel {\n    fill: #f0f0f0;\n    font: 10px sans-serif;\n    font-weight: bold;\n  }\n\n  .bandMinMaxLabel {\n    fill: #11aa6a;\n    font: 10px sans-serif;\n    font-weight: bold;\n  }\n\n  .bandMidLabel {\n    cursor: default;\n    fill: #bc79c5;\n    font: 10px sans-serif;\n    font-style: italic;\n    font-weight: bold;\n  }\n\n  .chart {\n    fill: #eee;\n  }\n\n  .interval {\n    cursor: default;\n    fill: #ecf7f7;\n    pointer-events: true;\n\n    rect {\n      stroke: black;\n      stroke-width: 0.5px;\n    }\n  }\n\n  .instant {\n    cursor: default;\n    fill: #afcae7;\n  }\n\n  .instantLabel {\n    fill: #7e7e7e;\n    font: 10px sans-serif;\n    shape-rendering: crispEdges;\n  }\n\n  .intervalLabel {\n    fill: black;\n    font: 10px sans-serif;\n    shape-rendering: crispEdges;\n  }\n}\n&quot;,&quot;demo&quot;:[{&quot;content&quot;:&quot;import { Timeline } from \&quot;./philosophers-timeline-chart\&quot;\nimport {\n  TimeBandItem,\n  fetchData,\n  getChartConfig,\n} from \&quot;./philosophers-timeline-chart-data\&quot;\n\nenum BandName {\n  Main = \&quot;mainBand\&quot;,\n  Navi = \&quot;naviBand\&quot;,\n}\n\nconst main = async () =&gt; {\n  const timelineData = await fetchData()\n  const chartConfig = getChartConfig()\n\n  new Timeline&lt;TimeBandItem&gt;(chartConfig)\n    .addChartData(timelineData)\n    .addBand({ bandName: BandName.Main, sizeFactor: 0.82 })\n    .addBand({ bandName: BandName.Navi, sizeFactor: 0.08 })\n    .xAxis(BandName.Main)\n    .xAxis(BandName.Navi)\n    .labels(BandName.Main)\n    .labels(BandName.Navi)\n    .addBrush({ brushBandName: BandName.Navi, targetBandName: BandName.Main })\n    .redraw()\n    .createTooltip()\n}\n\nexport default main\n&quot;,&quot;fileName&quot;:&quot;philosophers-timeline&quot;},{&quot;content&quot;:&quot;import { csv, timeParse } from \&quot;d3\&quot;\nimport qs from \&quot;query-string\&quot;\n\nimport { ChartConfig, SortOrder } from \&quot;./philosophers-timeline-chart\&quot;\n\nexport type TimeBandItem = {\n  end: Date\n  instant: boolean\n  label: string\n  start: Date\n  track: number\n}\n\nconst toYear = (date: Date) =&gt; {\n  const bcString = \&quot; BC\&quot;\n  const year = date.getUTCFullYear()\n\n  if (year &gt;= 0) {\n    return year.toString()\n  }\n\n  return bcString + Math.abs(year)\n}\n\nconst parseDate = function (dateString: string) {\n  const format = timeParse(\&quot;%Y-%m-%d\&quot;)\n\n  let date = format(dateString)\n\n  if (date !== null) {\n    return date\n  }\n\n  const year = isNaN(Number(dateString))\n    ? -dateString.replace(/[^0-9]/g, \&quot;\&quot;)\n    : +dateString\n\n  if (year &lt; 0 || year &gt; 99) {\n    date = new Date(year, 6, 1)\n  } else if (year === 0) {\n    date = new Date(-1, 6, 1)\n  } else {\n    date = new Date(year, 6, 1)\n    date.setUTCFullYear(year)\n  }\n\n  return date\n}\n\nconst yearMillis = 31622400000\n\nexport const fetchData = async (): Promise&lt;TimeBandItem[]&gt; =&gt; {\n  const timeBandItems = ((await csv(\n    `${ROOT_PATH}data/d3js/philosophers-timeline/data.csv`\n  )) as unknown) as TimeBandItem[]\n  const today = new Date()\n  const instantOffset = 100 * yearMillis\n\n  timeBandItems.forEach((timeBandItem) =&gt; {\n    timeBandItem.start = parseDate(timeBandItem.start.toString())\n\n    if ((timeBandItem.end as unknown) === \&quot;\&quot;) {\n      timeBandItem.end = new Date(timeBandItem.start.getTime() + instantOffset)\n      timeBandItem.instant = true\n    } else {\n      timeBandItem.end = parseDate(timeBandItem.end.toString())\n      timeBandItem.instant = false\n    }\n\n    if (timeBandItem.end &gt; today) {\n      timeBandItem.end = today\n    }\n  })\n\n  return timeBandItems\n}\n\ntype Config = ChartConfig&lt;TimeBandItem&gt;\n\nconst getItemLimitLeft: Config[\&quot;getItemLimitLeft\&quot;] = (timeBandItem) =&gt;\n  timeBandItem.start\n\nconst getItemLimitRight: Config[\&quot;getItemLimitRight\&quot;] = (timeBandItem) =&gt;\n  timeBandItem.end\n\nconst getSortFn: Config[\&quot;getSortFn\&quot;] = (sortOrder) =&gt; (\n  ...[timeBandItemA, timeBandItemB]: [TimeBandItem, TimeBandItem]\n) =&gt; {\n  const factor = sortOrder === SortOrder.Ascending ? 1 : -1\n  const startDiff = Number(timeBandItemA.start) - Number(timeBandItemB.start)\n\n  if (startDiff !== 0) {\n    return startDiff * factor\n  }\n\n  return (Number(timeBandItemB.end) - Number(timeBandItemA.end)) * factor\n}\n\nconst getItemText: Config[\&quot;getItemText\&quot;] = ({\n  chartItem: timeBandItem,\n  maxLetters,\n}) =&gt; {\n  if (timeBandItem.label.length &gt; maxLetters) {\n    return `${timeBandItem.label.substr(0, maxLetters - 1)}..`\n  }\n\n  return timeBandItem.label\n}\n\nconst getItemTitle: Config[\&quot;getItemTitle\&quot;] = (timeBandItem) =&gt; {\n  if (timeBandItem.instant) {\n    return `${timeBandItem.label}: ${toYear(timeBandItem.start)}`\n  }\n\n  return `${timeBandItem.label}: ${toYear(timeBandItem.start)} - ${toYear(\n    timeBandItem.end\n  )}`\n}\n\nconst onChartItemClick: Config[\&quot;onChartItemClick\&quot;] = (timelineChart) =&gt; {\n  const query = !timelineChart.instant\n    ? `Philosopher ${timelineChart.label} ${\n        (timelineChart.end as unknown) ? timelineChart.end.getFullYear() : \&quot;\&quot;\n      }`.trim()\n    : timelineChart.label\n\n  window.open(\n    `https://www.google.com/search?${qs.stringify({\n      q: query,\n    })}`\n  )\n}\n\nexport const getChartConfig = (): Config =&gt; ({\n  getItemLimitLeft,\n  getItemLimitRight,\n  getItemText,\n  getItemTitle,\n  getSortFn,\n  onChartItemClick,\n  rootElId: \&quot;chart\&quot;,\n})\n&quot;,&quot;fileName&quot;:&quot;philosophers-timeline-chart-data&quot;},{&quot;content&quot;:&quot;import {\n  BaseType,\n  ScaleTime,\n  Selection,\n  axisBottom,\n  brushX,\n  min as minD3,\n  scaleTime,\n  select,\n  selectAll,\n} from \&quot;d3\&quot;\n\nimport * as styles from \&quot;./philosophers-timeline.module.css\&quot;\n\nexport enum SortOrder {\n  Ascending = \&quot;ascending\&quot;,\n  Descending = \&quot;descending\&quot;,\n}\n\nenum TimeOrder {\n  Backward = \&quot;backward\&quot;,\n  Forward = \&quot;forward\&quot;,\n}\n\ntype RedrawComp = {\n  redraw?: () =&gt; void\n}\n\nconst margin = {\n  bottom: 0,\n  left: 20,\n  right: 20,\n  top: 60,\n}\n\ntype Band = RedrawComp &amp; {\n  g: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;\n  h: number\n  id: string\n  instantWidth: number\n  itemHeight: number\n  parts: RedrawComp[]\n  trackHeight: number\n  trackOffset: number\n  w: number\n  x: number\n  xScale: ScaleTime&lt;number, number, number&gt;\n  y: number\n  yScale: (track: number) =&gt; number\n}\n\nconst outerHeight = 700\nconst height = outerHeight - margin.top - margin.bottom\nconst bandGap = 25\n\nconst toYear = (date: Date) =&gt; {\n  const bcString = \&quot; BC\&quot;\n  const year = date.getUTCFullYear()\n\n  if (year &gt;= 0) {\n    return year.toString()\n  }\n\n  return bcString + Math.abs(year)\n}\n\nconst filterBlackOpacity = ({\n  deviation,\n  id,\n  slope,\n  svg,\n}: {\n  deviation: number\n  id: string\n  slope: number\n  svg: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;\n}) =&gt; {\n  const defs = svg.append(\&quot;defs\&quot;)\n  const filter = defs\n    .append(\&quot;filter\&quot;)\n    .attr(\&quot;height\&quot;, \&quot;500%\&quot;)\n    .attr(\&quot;id\&quot;, `drop-shadow-${id}`)\n    .attr(\&quot;width\&quot;, \&quot;500%\&quot;)\n    .attr(\&quot;x\&quot;, \&quot;-200%\&quot;)\n    .attr(\&quot;y\&quot;, \&quot;-200%\&quot;)\n\n  filter\n    .append(\&quot;feGaussianBlur\&quot;)\n    .attr(\&quot;in\&quot;, \&quot;SourceAlpha\&quot;)\n    .attr(\&quot;stdDeviation\&quot;, deviation)\n\n  filter.append(\&quot;feOffset\&quot;).attr(\&quot;dx\&quot;, 1).attr(\&quot;dy\&quot;, 1)\n  filter\n    .append(\&quot;feComponentTransfer\&quot;)\n    .append(\&quot;feFuncA\&quot;)\n    .attr(\&quot;slope\&quot;, slope)\n    .attr(\&quot;type\&quot;, \&quot;linear\&quot;)\n\n  const feMerge = filter.append(\&quot;feMerge\&quot;)\n\n  feMerge.append(\&quot;feMergeNode\&quot;)\n\n  feMerge.append(\&quot;feMergeNode\&quot;).attr(\&quot;in\&quot;, \&quot;SourceGraphic\&quot;)\n}\n\ntype ChartDataBase = {\n  instant: boolean\n  track: number\n}\n\nexport type ChartConfig&lt;ChartData extends ChartDataBase&gt; = {\n  getItemLimitLeft: (chartItem: ChartData) =&gt; Date\n  getItemLimitRight: (chartItem: ChartData) =&gt; Date\n  getItemText: (o: { chartItem: ChartData; maxLetters: number }) =&gt; string\n  getItemTitle: (chartItem: ChartData) =&gt; string\n  getSortFn: (\n    sortOrder: SortOrder\n  ) =&gt; (itemA: ChartData, itemB: ChartData) =&gt; number\n  onChartItemClick: (chartItem: ChartData) =&gt; void\n  rootElId: string\n}\n\nexport class Timeline&lt;ChartData extends ChartDataBase&gt; {\n  private readonly chart: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;\n\n  private bandY: number\n  private bandNum: number\n  private dataContent: {\n    chartItems?: ChartData[]\n    maxDate?: Date\n    minDate?: Date\n    nTracks?: number\n  }\n\n  private readonly components: RedrawComp[]\n  private bands: { [k: string]: Band }\n  private readonly width: number\n  private readonly chartConfig: ChartConfig&lt;ChartData&gt;\n\n  public constructor(chartConfig: ChartConfig&lt;ChartData&gt;) {\n    this.chartConfig = chartConfig\n\n    const rootEl = document.getElementById(chartConfig.rootElId) as HTMLElement\n\n    rootEl.classList.add(styles.timelineChart)\n\n    const { width: outerWidth } = rootEl.getBoundingClientRect()\n\n    this.width = outerWidth - margin.left - margin.right\n\n    this.bandY = 0\n    this.bandNum = 0\n\n    this.dataContent = {}\n    this.components = []\n    this.bands = {}\n\n    const svg = select(`#${chartConfig.rootElId}`)\n      .text(\&quot;\&quot;)\n      .append(\&quot;svg\&quot;)\n      .attr(\&quot;height\&quot;, outerHeight + margin.top + margin.bottom)\n      .attr(\&quot;width\&quot;, outerWidth + margin.left + margin.right)\n      .append(\&quot;g\&quot;)\n      .attr(\&quot;transform\&quot;, `translate(${margin.left},${margin.top})`)\n\n    svg\n      .append(\&quot;text\&quot;)\n      .attr(\&quot;class\&quot;, \&quot;chart-title\&quot;)\n      .attr(\&quot;text-anchor\&quot;, \&quot;middle\&quot;)\n      .attr(\&quot;transform\&quot;, `translate(${outerWidth / 2},-20)`)\n      .text(\&quot;Philosophers through History\&quot;)\n      .style(\&quot;font-weight\&quot;, \&quot;bold\&quot;)\n\n    filterBlackOpacity({ deviation: 1, id: \&quot;intervals\&quot;, slope: 0.2, svg })\n\n    svg\n      .append(\&quot;clipPath\&quot;)\n      .attr(\&quot;id\&quot;, \&quot;chart-area\&quot;)\n      .append(\&quot;rect\&quot;)\n      .attr(\&quot;width\&quot;, this.width)\n      .attr(\&quot;height\&quot;, height)\n\n    svg.on(\&quot;mouseup\&quot;, () =&gt;\n      selectAll(`.${styles.interval} rect`).style(\n        \&quot;filter\&quot;,\n        \&quot;url(#drop-shadow-intervals)\&quot;\n      )\n    )\n\n    this.chart = svg\n      .append(\&quot;g\&quot;)\n      .attr(\&quot;class\&quot;, styles.chart)\n      .attr(\&quot;clip-path\&quot;, \&quot;url(#chart-area)\&quot;)\n  }\n\n  public addChartData(timelineItems: ChartData[]) {\n    const tracks: Date[] = []\n\n    this.dataContent.chartItems = timelineItems\n\n    const calculateTracks = ({\n      chartItems,\n      sortOrderInitial,\n      timeOrderInitial,\n    }: {\n      chartItems: ChartData[]\n      sortOrderInitial?: SortOrder\n      timeOrderInitial?: TimeOrder\n    }) =&gt; {\n      const sortOrder = sortOrderInitial ?? SortOrder.Descending\n      const timeOrder = timeOrderInitial ?? TimeOrder.Forward\n\n      const sortBackward = () =&gt; {\n        chartItems.forEach((chartItem) =&gt; {\n          let trackIndex = 0\n\n          for (trackIndex = 0; trackIndex &lt; tracks.length; trackIndex += 1) {\n            if (\n              this.chartConfig.getItemLimitRight(chartItem) &lt; tracks[trackIndex]\n            ) {\n              break\n            }\n          }\n\n          chartItem.track = trackIndex\n          tracks[trackIndex] = this.chartConfig.getItemLimitLeft(chartItem)\n        })\n      }\n\n      const sortForward = () =&gt; {\n        chartItems.forEach((chartItem) =&gt; {\n          let trackIndex = 0\n\n          for (trackIndex = 0; trackIndex &lt; tracks.length; trackIndex += 1) {\n            if (\n              this.chartConfig.getItemLimitLeft(chartItem) &gt; tracks[trackIndex]\n            ) {\n              break\n            }\n          }\n\n          chartItem.track = trackIndex\n\n          tracks[trackIndex] = this.chartConfig.getItemLimitRight(chartItem)\n        })\n      }\n\n      const sortFn = this.chartConfig.getSortFn(sortOrder)\n\n      this.dataContent.chartItems!.sort(sortFn)\n\n      if (timeOrder === TimeOrder.Forward) {\n        sortForward()\n\n        return\n      }\n\n      sortBackward()\n    }\n\n    calculateTracks({\n      chartItems: this.dataContent.chartItems,\n      sortOrderInitial: SortOrder.Descending,\n      timeOrderInitial: TimeOrder.Backward,\n    })\n\n    this.dataContent.nTracks = tracks.length\n    this.dataContent.minDate = minD3(\n      this.dataContent.chartItems,\n      this.chartConfig.getItemLimitLeft\n    )\n    this.dataContent.maxDate = new Date()\n\n    return this\n  }\n\n  public xAxis(bandName: string) {\n    const {\n      bands: { [bandName]: band },\n    } = this\n\n    const axis = axisBottom&lt;Date&gt;(band.xScale)\n      .tickSize(6)\n      .tickFormat((axisTick) =&gt; toYear(axisTick))\n\n    const xAxis: RedrawComp &amp;\n      Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt; = this.chart\n      .append(\&quot;g\&quot;)\n      .attr(\&quot;class\&quot;, styles.axis)\n      .attr(\&quot;transform\&quot;, `translate(0,${band.y + band.h})`)\n\n    xAxis.redraw = function () {\n      xAxis.call(axis)\n    }\n\n    band.parts.push(xAxis)\n    this.components.push(xAxis)\n\n    return this\n  }\n\n  public createTooltip() {\n    $(`.part.${styles.instant}, .part.${styles.interval}`).tooltip({\n      track: true,\n    })\n\n    return this\n  }\n\n  public addBand({\n    bandName,\n    sizeFactor,\n  }: {\n    bandName: string\n    sizeFactor: number\n  }) {\n    const band: Partial&lt;Band&gt; = {}\n\n    band.id = `band${this.bandNum}`\n    band.x = 0\n    band.y = this.bandY\n    band.w = this.width\n    band.h = height * (sizeFactor || 1)\n    band.trackOffset = 0\n    band.trackHeight = Math.min(\n      (band.h - band.trackOffset) / this.dataContent.nTracks!,\n      20\n    )\n    band.itemHeight = band.trackHeight * 0.7\n    band.parts = []\n    band.instantWidth = 100\n    band.xScale = scaleTime()\n      .domain([this.dataContent.minDate!, this.dataContent.maxDate!])\n      .range([0, band.w])\n\n    band.yScale = (track: number) =&gt;\n      band.trackOffset! + track * band.trackHeight!\n\n    band.g = this.chart\n      .append(\&quot;g\&quot;)\n      .attr(\&quot;id\&quot;, band.id)\n      .attr(\&quot;transform\&quot;, `translate(0,${band.y})`)\n\n    band.g\n      .append(\&quot;rect\&quot;)\n      .attr(\&quot;class\&quot;, styles.band)\n      .attr(\&quot;width\&quot;, band.w)\n      .attr(\&quot;height\&quot;, band.h)\n\n    const bandElements = band.g\n      .selectAll(\&quot;g\&quot;)\n      .data&lt;ChartData&gt;(this.dataContent.chartItems!)\n      .enter()\n      .append&lt;SVGSVGElement&gt;(\&quot;svg\&quot;)\n      .attr(\&quot;y\&quot;, (chartItem) =&gt; band.yScale!(chartItem.track))\n      .attr(\&quot;height\&quot;, band.itemHeight)\n      .attr(\&quot;title\&quot;, this.chartConfig.getItemTitle)\n      .attr(\n        \&quot;class\&quot;,\n        (chartItem) =&gt;\n          `part ${chartItem.instant ? styles.instant : styles.interval}`\n      )\n\n    const intervals = select(`#band${this.bandNum}`).selectAll&lt;\n      BaseType,\n      ChartData\n    &gt;(`.${styles.interval}`)\n\n    const instants = select(`#band${this.bandNum}`).selectAll&lt;\n      BaseType,\n      ChartData\n    &gt;(`.${styles.instant}`)\n\n    intervals\n      .append(\&quot;rect\&quot;)\n      .attr(\&quot;height\&quot;, \&quot;100%\&quot;)\n      .attr(\&quot;width\&quot;, \&quot;100%\&quot;)\n      .attr(\&quot;x\&quot;, \&quot;1px\&quot;)\n      .attr(\&quot;y\&quot;, \&quot;.5px\&quot;)\n      .style(\&quot;filter\&quot;, \&quot;url(#drop-shadow-intervals)\&quot;)\n\n    intervals\n      .append(\&quot;text\&quot;)\n      .attr(\&quot;class\&quot;, styles.intervalLabel)\n      .attr(\&quot;x\&quot;, 3)\n      .attr(\&quot;y\&quot;, 9.5)\n\n    instants\n      .append(\&quot;circle\&quot;)\n      .attr(\&quot;cx\&quot;, band.itemHeight / 2)\n      .attr(\&quot;cy\&quot;, band.itemHeight / 2)\n      .attr(\&quot;r\&quot;, 5)\n\n    instants\n      .append(\&quot;text\&quot;)\n      .attr(\&quot;class\&quot;, styles.instantLabel)\n      .attr(\&quot;x\&quot;, 15)\n      .attr(\&quot;y\&quot;, 10)\n\n    const itemsSelections = [intervals, instants]\n\n    itemsSelections.forEach((selection) =&gt; {\n      selection.on(\&quot;click\&quot;, (...[, chartItem]) =&gt;\n        this.chartConfig.onChartItemClick(chartItem)\n      )\n      selection.style(\&quot;cursor\&quot;, \&quot;pointer\&quot;)\n    })\n\n    const {\n      chartConfig: { getItemLimitLeft, getItemLimitRight },\n    } = this\n\n    band.redraw = () =&gt; {\n      bandElements\n        .attr(\&quot;x\&quot;, (chartItem: ChartData) =&gt;\n          band.xScale!(getItemLimitLeft(chartItem))\n        )\n        .attr(\n          \&quot;width\&quot;,\n          (chartItem: ChartData) =&gt;\n            band.xScale!(getItemLimitRight(chartItem)) -\n            band.xScale!(getItemLimitLeft(chartItem))\n        )\n        .select(\&quot;text\&quot;)\n        .text((chartItem: ChartData) =&gt; {\n          const scale =\n            band.xScale!(getItemLimitRight(chartItem)) -\n            band.xScale!(getItemLimitLeft(chartItem))\n          const maxLetters = scale / 9\n\n          return this.chartConfig.getItemText({ chartItem, maxLetters })\n        })\n\n      band.parts!.forEach((part) =&gt; part.redraw!())\n    }\n\n    this.bands[bandName] = band as Band\n    this.components.push(band)\n    this.bandY += band.h + bandGap\n    this.bandNum += 1\n\n    return this\n  }\n\n  public labels(bandName: string) {\n    const {\n      bands: { [bandName]: band },\n    } = this\n    const labelWidth = 46\n    const labelHeight = 20\n    const labelTop = band.y + band.h - 10\n    const yText = 15\n\n    type LabelDef = {\n      className: string\n      getText: (min: Date, max: Date) =&gt; string\n      id: string\n      left: number\n      textAnchor: string\n      textLeft: number\n      top: number\n    }\n\n    const labelDefs: LabelDef[] = [\n      {\n        className: styles.bandMinMaxLabel,\n        getText: (min: Date) =&gt; toYear(min),\n        id: \&quot;Start of the selected interval\&quot;,\n        left: 0,\n        textAnchor: \&quot;start\&quot;,\n        textLeft: 4,\n        top: labelTop,\n      },\n      {\n        className: styles.bandMinMaxLabel,\n        getText: (...[, max]: [unknown, Date]) =&gt; toYear(max),\n        id: \&quot;End of the selected interval\&quot;,\n        left: band.w - labelWidth,\n        textAnchor: \&quot;end\&quot;,\n        textLeft: band.w - 4,\n        top: labelTop,\n      },\n      {\n        className: styles.bandMidLabel,\n        getText: (...[min, max]: [Date, Date]) =&gt;\n          (max.getUTCFullYear() - min.getUTCFullYear()).toString(),\n        id: \&quot;Length of the selected interval\&quot;,\n        left: (band.w - labelWidth) / 2,\n        textAnchor: \&quot;middle\&quot;,\n        textLeft: band.w / 2,\n        top: labelTop,\n      },\n    ]\n\n    const bandLabels = this.chart\n      .append(\&quot;g\&quot;)\n      .attr(\&quot;id\&quot;, `${bandName}Labels`)\n      .attr(\&quot;transform\&quot;, `translate(0,${band.y + band.h + 1})`)\n      .selectAll(`#${bandName}Labels`)\n      .data(labelDefs)\n      .enter()\n      .append(\&quot;g\&quot;)\n\n    bandLabels\n      .append(\&quot;rect\&quot;)\n      .attr(\&quot;class\&quot;, styles.bandLabel)\n      .attr(\&quot;x\&quot;, (label) =&gt; label.left)\n      .attr(\&quot;width\&quot;, labelWidth)\n      .attr(\&quot;height\&quot;, labelHeight)\n      .style(\&quot;opacity\&quot;, 1)\n\n    const labels: RedrawComp &amp;\n      Selection&lt;SVGTextElement, LabelDef, SVGGElement, unknown&gt; = bandLabels\n      .append(\&quot;text\&quot;)\n      .attr(\&quot;class\&quot;, (label) =&gt; label.className)\n      .attr(\&quot;id\&quot;, (label) =&gt; label.id)\n      .attr(\&quot;x\&quot;, (label) =&gt; label.textLeft)\n      .attr(\&quot;y\&quot;, yText)\n      .attr(\&quot;text-anchor\&quot;, (label) =&gt; label.textAnchor)\n\n    labels.redraw = () =&gt; {\n      const min = band.xScale.domain()[0]\n      const max = band.xScale.domain()[1]\n\n      labels.text((label) =&gt; label.getText(min, max))\n    }\n\n    band.parts.push(labels)\n    this.components.push(labels)\n\n    return this\n  }\n\n  public addBrush({\n    brushBandName,\n    targetBandName,\n  }: {\n    brushBandName: string\n    targetBandName: string\n  }) {\n    const {\n      bands: { [brushBandName]: brushBand },\n    } = this\n    const brush = brushX()\n\n    const {\n      dataContent: { maxDate, minDate },\n    } = this\n    const totalRange = [minDate!.getTime(), maxDate!.getTime()]\n\n    const selectionScale = scaleTime&lt;number, Date&gt;()\n      .domain([0, this.width])\n      .range(totalRange)\n\n    brush.on(\&quot;brush\&quot;, (brushEvent) =&gt; {\n      let newDomain = brushBand.xScale.domain()\n\n      if (brushEvent.selection) {\n        const {\n          selection: [selectionStart, selectionEnd],\n        } = brushEvent\n\n        newDomain = [\n          selectionScale(Math.max(0, selectionStart)),\n          selectionScale(Math.min(this.width, selectionEnd)),\n        ]\n      }\n\n      selectAll(`.${styles.interval} rect`).style(\&quot;filter\&quot;, \&quot;none\&quot;)\n\n      this.bands[targetBandName].xScale.domain(newDomain)\n      this.bands[targetBandName].redraw!()\n    })\n\n    const xBrush = brushBand.g\n      .append(\&quot;svg\&quot;)\n      .attr(\&quot;class\&quot;, `x`)\n      .call(brush as any) // eslint-disable-line @typescript-eslint/no-explicit-any\n\n    xBrush\n      .selectAll(\&quot;rect\&quot;)\n      .attr(\&quot;y\&quot;, 1)\n      .attr(\&quot;height\&quot;, brushBand.h - 1)\n\n    return this\n  }\n\n  public redraw() {\n    this.components.forEach((component: RedrawComp) =&gt; component.redraw!())\n\n    return this\n  }\n}\n&quot;,&quot;fileName&quot;:&quot;philosophers-timeline-chart&quot;}],&quot;page&quot;:{&quot;content&quot;:&quot;import React from \&quot;react\&quot;\n\nimport { DemoPageProps } from \&quot;@/common\&quot;\n\nimport Demo from \&quot;@/components/demo\&quot;\n\nimport main from \&quot;@/demos/philosophers-timeline/philosophers-timeline\&quot;\n\nconst PhilosophersTimeline = ({ pageContext }: DemoPageProps) =&gt; (\n  &lt;Demo\n    links={[\&quot;/vendors/jquery-ui/themes/base/jquery-ui.min.css\&quot;]}\n    main={main}\n    pageContext={pageContext}\n    scripts={[\&quot;/vendors/jquery-ui/jquery-ui.min.js\&quot;]}\n  &gt;\n    &lt;div id=\&quot;chart\&quot; /&gt;\n  &lt;/Demo&gt;\n)\n\nexport default PhilosophersTimeline\n&quot;,&quot;type&quot;:&quot;tsx&quot;}},&quot;key&quot;:&quot;philosophers-timeline&quot;},&quot;meta&quot;:{&quot;description&quot;:&quot;Example of historical timeline using D3.js, where a legend is place to ease the navigation, as well as a more depurated style with tooltips.&quot;}}},&quot;staticQueryHashes&quot;:[]}</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Wed, 01 Sep 2021 22:07:32 GMT</p>
    </body>
  </html>
  