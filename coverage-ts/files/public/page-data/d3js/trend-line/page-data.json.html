
  <!DOCTYPE html>
  <html>
    <head>
      <title>page-data.json</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">public/page-data/d3js/trend-line/page-data.json</td><td class="">100.00%</td><td class="">95%</td><td class="">0</td><td class="">0</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">{&quot;componentChunkName&quot;:&quot;component---src-pages-d-3-js-trend-line-tsx&quot;,&quot;path&quot;:&quot;/d3js/trend-line/&quot;,&quot;result&quot;:{&quot;pageContext&quot;:{&quot;demoInfo&quot;:{&quot;dataFiles&quot;:[&quot;data.tsv&quot;],&quot;docs&quot;:[],&quot;isCompleted&quot;:true,&quot;name&quot;:&quot;Trend line&quot;,&quot;notes&quot;:[&quot;Added both line animations&quot;,&quot;Changed y scale domain&quot;],&quot;sources&quot;:[&quot;http://codepen.io/arundhaj/pen/ouyjd&quot;,&quot;http://big-elephants.com/2014-06/unrolling-line-charts-d3js/&quot;],&quot;summary&quot;:[],&quot;category&quot;:&quot;d3js&quot;,&quot;files&quot;:{&quot;cssModule&quot;:&quot;.trendLineChart {\n  .axis {\n    font: 10px sans-serif;\n  }\n\n  .axis path,\n  line {\n    fill: none;\n    shape-rendering: crispEdges;\n    stroke: #000;\n  }\n\n  .line {\n    fill: none;\n    stroke: steelblue;\n    stroke-width: 1.5px;\n  }\n\n  .rline {\n    fill: none;\n    stroke: red;\n    stroke-dasharray: 5, 5;\n    stroke-width: 1.5px;\n  }\n}\n&quot;,&quot;demo&quot;:[{&quot;content&quot;:&quot;import {\n  Line,\n  axisBottom,\n  axisLeft,\n  line as d3Line,\n  extent,\n  max,\n  min,\n  range,\n  scaleLinear,\n  scaleQuantile,\n  scaleTime,\n  select,\n  selectAll,\n  timeParse,\n  tsv,\n} from \&quot;d3\&quot;\n\nimport * as styles from \&quot;./trend-line.module.css\&quot;\n\ntype InitialDataItem = {\n  occurred: string\n  value: string // eslint-disable-line id-denylist\n}\n\ntype DataItem = {\n  arbitraryValue: number\n  occurred: Date\n}\n\nconst fetchData = async (): Promise&lt;DataItem[]&gt; =&gt; {\n  const response = (await tsv(\n    `${ROOT_PATH}data/d3js/trend-line/data.tsv`\n  )) as InitialDataItem[]\n\n  const timeFormat = timeParse(\&quot;%Y-%m-%d\&quot;)\n\n  return response.map((responseItem) =&gt; ({\n    arbitraryValue: +responseItem.value,\n    occurred: timeFormat(responseItem.occurred)!,\n  }))\n}\n\nconst margin = {\n  bottom: 50,\n  left: 50,\n  right: 50,\n  top: 50,\n}\n\nconst height = 500 - margin.top - margin.bottom\n\nconst animationTime = 2000\n\nconst getInterpolation = ({\n  line,\n  lineData,\n}: {\n  line: Line&lt;DataItem&gt;\n  lineData: DataItem[]\n}) =&gt; () =&gt; {\n  const interpolate = scaleQuantile()\n    .domain([0, 1])\n    .range(range(1, lineData.length + 1))\n\n  return (t: number): string =&gt; {\n    const interpolatedLine = lineData.slice(0, interpolate(t))\n\n    return line(interpolatedLine)!\n  }\n}\n\nconst createLinearRegression = (lineData: DataItem[]) =&gt; {\n  const linearRegression: {\n    intercept?: number\n    r2?: number\n    slope?: number\n  } = {}\n  const { length: itemsNum } = lineData\n\n  let sumX = 0\n  let sumY = 0\n  let sumXY = 0\n  let sumXX = 0\n  let sumYY = 0\n\n  lineData.forEach((lineItem) =&gt; {\n    sumY += lineItem.arbitraryValue\n    sumYY += lineItem.arbitraryValue * lineItem.arbitraryValue\n    sumXY += lineItem.occurred.getTime() * lineItem.arbitraryValue\n\n    sumX += lineItem.occurred.getTime()\n    sumXX += lineItem.occurred.getTime() * lineItem.occurred.getTime()\n  })\n\n  linearRegression.slope =\n    (itemsNum * sumXY - sumX * sumY) / (itemsNum * sumXX - sumX * sumX)\n  linearRegression.intercept = (sumY - linearRegression.slope * sumX) / itemsNum\n  linearRegression.r2 = Math.pow(\n    (itemsNum * sumXY - sumX * sumY) /\n      Math.sqrt(\n        (itemsNum * sumXX - sumX * sumX) * (itemsNum * sumYY - sumY * sumY)\n      ),\n    2\n  )\n\n  return linearRegression\n}\n\nconst renderGraph = ({\n  initialZoomed,\n  lineData,\n  rootElId,\n}: {\n  initialZoomed: boolean\n  lineData: DataItem[]\n  rootElId: string\n}) =&gt; {\n  const container = document.getElementById(rootElId) as HTMLElement\n\n  container.classList.add(styles.trendLineChart)\n\n  const width =\n    container.getBoundingClientRect().width - margin.left - margin.right\n\n  const renderContent = (isZoomed: boolean) =&gt; {\n    const svg = select(`#${rootElId}`)\n      .text(\&quot;\&quot;)\n      .append(\&quot;svg\&quot;)\n      .attr(\&quot;height\&quot;, height + margin.top + margin.bottom)\n      .attr(\&quot;width\&quot;, width + margin.left + margin.right)\n      .append(\&quot;g\&quot;)\n      .attr(\&quot;transform\&quot;, `translate(${margin.left},${margin.right})`)\n\n    const x = scaleTime().range([0, width])\n    const y = scaleLinear().range([height, 0])\n    const xAxis = axisBottom(x)\n    const yAxis = axisLeft(y)\n\n    const line = d3Line&lt;DataItem&gt;()\n      .x((lineItem) =&gt; x(lineItem.occurred))\n      .y((lineItem) =&gt; y(lineItem.arbitraryValue))\n\n    x.domain(extent(lineData, (lineItem) =&gt; lineItem.occurred) as [Date, Date])\n    y.domain([\n      isZoomed\n        ? (min(lineData, (lineItem) =&gt; lineItem.arbitraryValue) as number)\n        : 0,\n      max(lineData, (lineItem) =&gt; lineItem.arbitraryValue) as number,\n    ])\n\n    svg\n      .append(\&quot;g\&quot;)\n      .attr(\&quot;class\&quot;, `x ${styles.axis}`)\n      .attr(\&quot;transform\&quot;, `translate(0,${height})`)\n      .call(xAxis)\n    svg.append(\&quot;g\&quot;).attr(\&quot;class\&quot;, `y ${styles.axis}`).call(yAxis)\n\n    svg\n      .append(\&quot;path\&quot;)\n      .datum(lineData)\n      .transition()\n      .duration(animationTime)\n      .attrTween(\n        \&quot;d\&quot;,\n        getInterpolation({\n          line,\n          lineData,\n        })\n      )\n      .attr(\&quot;class\&quot;, styles.line)\n\n    const linearRegression = createLinearRegression(lineData)\n\n    const regressionLine = d3Line&lt;DataItem&gt;()\n      .x((lineItem) =&gt; x(lineItem.occurred))\n      .y((lineItem) =&gt;\n        y(\n          linearRegression.intercept! +\n            linearRegression.slope! * +lineItem.occurred\n        )\n      )\n\n    svg\n      .append(\&quot;path\&quot;)\n      .datum(lineData)\n      .transition()\n      .delay(animationTime)\n      .duration(animationTime)\n      .attrTween(\n        \&quot;d\&quot;,\n        getInterpolation({\n          line: regressionLine,\n          lineData,\n        })\n      )\n      .attr(\&quot;class\&quot;, styles.rline)\n\n    svg\n      .append(\&quot;text\&quot;)\n      .attr(\&quot;transform\&quot;, `translate(${width * 0.7},${height * 0.7})`)\n      .style(\&quot;opacity\&quot;, 0)\n      .transition()\n      .delay(animationTime * 2)\n      .text(`Slope: ${linearRegression.slope!.toExponential(3)}`)\n      .style(\&quot;opacity\&quot;, 1)\n  }\n\n  renderContent(initialZoomed)\n\n  return {\n    renderContent,\n  }\n}\n\nconst main = async () =&gt; {\n  const rootElId = \&quot;chart\&quot;\n  const lineData = await fetchData()\n\n  const getIsZoomed = () =&gt;\n    (document.querySelector(&#x27;input[value=\&quot;zoom\&quot;]&#x27;) as HTMLInputElement).checked\n\n  const { renderContent } = renderGraph({\n    initialZoomed: getIsZoomed(),\n    lineData,\n    rootElId,\n  })\n\n  selectAll(&#x27;input[name=\&quot;mode\&quot;]&#x27;).on(\&quot;change\&quot;, () =&gt; {\n    const isZoomed = getIsZoomed()\n\n    renderContent(isZoomed)\n  })\n}\n\nexport default main\n&quot;,&quot;fileName&quot;:&quot;trend-line&quot;}],&quot;page&quot;:{&quot;content&quot;:&quot;import React from \&quot;react\&quot;\n\nimport { DemoPageProps } from \&quot;@/common\&quot;\n\nimport Demo from \&quot;@/components/demo\&quot;\n\nimport main from \&quot;@/demos/trend-line/trend-line\&quot;\n\nconst TrendLine = ({ pageContext }: DemoPageProps) =&gt; (\n  &lt;Demo main={main} pageContext={pageContext}&gt;\n    &lt;form&gt;\n      &lt;label&gt;\n        &lt;input defaultChecked name=\&quot;mode\&quot; type=\&quot;radio\&quot; value=\&quot;zoom\&quot; /&gt; Zoom\n      &lt;/label&gt;\n      &lt;label&gt;\n        &lt;input name=\&quot;mode\&quot; type=\&quot;radio\&quot; value=\&quot;normal\&quot; /&gt; Normal\n      &lt;/label&gt;\n    &lt;/form&gt;\n    &lt;div id=\&quot;chart\&quot; /&gt;\n  &lt;/Demo&gt;\n)\n\nexport default TrendLine\n&quot;,&quot;type&quot;:&quot;tsx&quot;}},&quot;key&quot;:&quot;trend-line&quot;},&quot;meta&quot;:{&quot;description&quot;:&quot;Example of trend-line using D3.js, with extra animations.&quot;}}},&quot;staticQueryHashes&quot;:[]}</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Mon, 30 Aug 2021 23:07:34 GMT</p>
    </body>
  </html>
  