
  <!DOCTYPE html>
  <html>
    <head>
      <title>page-data.json</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">public/page-data/d3js/partition/page-data.json</td><td class="">100.00%</td><td class="">95%</td><td class="">0</td><td class="">0</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">{&quot;componentChunkName&quot;:&quot;component---src-pages-d-3-js-partition-tsx&quot;,&quot;path&quot;:&quot;/d3js/partition/&quot;,&quot;result&quot;:{&quot;pageContext&quot;:{&quot;demoInfo&quot;:{&quot;dataFiles&quot;:[&quot;flare.json&quot;],&quot;docs&quot;:[[&quot;d3-ease API reference&quot;,&quot;https://github.com/d3/d3-ease#api-reference&quot;],[&quot;d3-ease Types&quot;,&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-ease/index.d.ts&quot;],[&quot;d3-ease functions examples&quot;,&quot;https://bl.ocks.org/d3noob/1ea51d03775b9650e8dfd03474e202fe&quot;],[&quot;d3-fetch API reference&quot;,&quot;https://github.com/d3/d3-fetch#api-reference&quot;],[&quot;d3-fetch Types&quot;,&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-fetch/index.d.ts&quot;],[&quot;d3-hierarchy API reference&quot;,&quot;https://github.com/d3/d3-hierarchy#api-reference&quot;],[&quot;d3-hierarchy Types&quot;,&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-hierarchy/index.d.ts&quot;],[&quot;d3-interpolate API reference&quot;,&quot;https://github.com/d3/d3-interpolate#api-reference&quot;],[&quot;d3-interpolate Types&quot;,&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-interpolate/index.d.ts&quot;],[&quot;d3-scale API reference&quot;,&quot;https://github.com/d3/d3-scale#api-reference&quot;],[&quot;d3-scale Types&quot;,&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-scale/index.d.ts&quot;],[&quot;d3-selection API reference&quot;,&quot;https://github.com/d3/d3-selection#api-reference&quot;],[&quot;d3-selection Types&quot;,&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-selection/index.d.ts&quot;],[&quot;d3-transition API reference&quot;,&quot;https://github.com/d3/d3-transition#api-reference&quot;],[&quot;d3-transition Types&quot;,&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-transition/index.d.ts&quot;]],&quot;isCompleted&quot;:true,&quot;name&quot;:&quot;Partition&quot;,&quot;notes&quot;:[&quot;Added title attributes, labels and change colors with events&quot;,&quot;Added bounce ease function&quot;],&quot;sources&quot;:[&quot;http://bl.ocks.org/mbostock/4063423&quot;],&quot;summary&quot;:[&quot;This is a good example of how to uses hierarchies in combination with arc shapes. It includes a couple of ways of generating the hierarchy: via the size (value) of each leaf or via the count.&quot;,&quot;It is also illustrative about how to create custom tween functions for transitions. One possible improvement is the effect of the texts when flipping the direction during a transition due to being oriented vertical.&quot;,&quot;The chart displays the common flow for updating elements bound to data. Removing exited elements, adding new elements and applying the tween function to the selection.&quot;],&quot;category&quot;:&quot;d3js&quot;,&quot;files&quot;:{&quot;cssModule&quot;:&quot;&quot;,&quot;demo&quot;:[{&quot;content&quot;:&quot;import {\n  HierarchyRectangularNode,\n  Selection,\n  arc as arcD3,\n  easeBounce,\n  hierarchy,\n  interpolate,\n  json,\n  partition as partitionD3,\n  scaleOrdinal,\n  schemePastel2,\n  select,\n} from \&quot;d3\&quot;\n\ntype DataNode = {\n  children: DataNode[]\n  name: string\n  size?: number\n}\n\ntype HierarchyRectNode = HierarchyRectangularNode&lt;DataNode&gt;\ntype PartitionType = \&quot;count\&quot; | \&quot;size\&quot;\n\nconst fetchData = () =&gt;\n  (json(\n    `${ROOT_PATH}data/d3js/partition/flare.json`\n  ) as unknown) as Promise&lt;DataNode&gt;\n\nconst height = 700\nconst overColor = \&quot;#de7c03\&quot;\nconst transitionDuration = 2000\nconst easeFn = easeBounce\n\nconst addTitle = &lt;SVGComp extends SVGElement, SVGParent extends SVGElement&gt;(\n  selector: Selection&lt;SVGComp, HierarchyRectNode, SVGParent, unknown&gt;\n) =&gt; {\n  selector.append(\&quot;title\&quot;).text((node) =&gt; `${node.data.name}\\n${node.value}`)\n}\n\nconst getNodeText = (node: HierarchyRectNode) =&gt; {\n  const dx = Math.abs(node.x0 - node.x1)\n\n  if (dx &gt; 0.07 &amp;&amp; node.parent &amp;&amp; node.data.name.length &lt; 10) {\n    return node.data.name\n  }\n\n  return \&quot;\&quot;\n}\n\ntype RenderChart = (o: {\n  partitionType: PartitionType\n  rootData: DataNode\n  rootElId: string\n}) =&gt; {\n  updatePartition: (partitionType: PartitionType) =&gt; void\n}\n\nconst getDataHierarchy = ({\n  partitionType,\n  radius,\n  rootData,\n}: {\n  partitionType: PartitionType\n  radius: number\n  rootData: DataNode\n}) =&gt; {\n  const dataHierarchySize = hierarchy(rootData).sum(\n    (node: DataNode) =&gt; node.size ?? 0\n  )\n  const dataHierarchyCount = hierarchy(rootData).sum(() =&gt; 1)\n  const partition = partitionD3&lt;DataNode&gt;().size([2 * Math.PI, radius])\n\n  const hierarchyResult = partition(\n    partitionType === \&quot;size\&quot; ? dataHierarchySize : dataHierarchyCount\n  )\n\n  return hierarchyResult.descendants()\n}\n\nconst extractTweenObj = (node: HierarchyRectNode) =&gt; ({\n  depth: node.depth,\n  x0: node.x0,\n  x1: node.x1,\n  y0: node.y0,\n  y1: node.y1,\n})\n\nconst getInterpolatorFn = ({\n  fn,\n  initialData,\n}: {\n  fn: (node: HierarchyRectNode) =&gt; string | null\n  initialData: HierarchyRectNode[]\n}) =&gt; (...[finalNode, nodeIndex]: [HierarchyRectNode, number]) =&gt; {\n  const { [nodeIndex]: initialNode } = initialData\n\n  const interpolateFn = interpolate(\n    extractTweenObj(initialNode),\n    extractTweenObj(finalNode)\n  )\n\n  return (t: number) =&gt; {\n    const transitientState = interpolateFn(t)\n\n    return fn(transitientState as HierarchyRectNode)!\n  }\n}\n\nconst addFilter = (\n  svg: Selection&lt;SVGGElement, unknown, HTMLElement, unknown&gt;\n) =&gt; {\n  const defs = svg.append(\&quot;defs\&quot;)\n  const filter = defs.append(\&quot;filter\&quot;)\n\n  filter.attr(\&quot;id\&quot;, \&quot;drop-shadow\&quot;)\n  filter\n    .append(\&quot;feGaussianBlur\&quot;)\n    .attr(\&quot;in\&quot;, \&quot;SourceAlpha\&quot;)\n    .attr(\&quot;stdDeviation\&quot;, 9)\n  filter.append(\&quot;feOffset\&quot;).attr(\&quot;dx\&quot;, 2).attr(\&quot;dy\&quot;, 5)\n  filter\n    .append(\&quot;feComponentTransfer\&quot;)\n    .append(\&quot;feFuncA\&quot;)\n    .attr(\&quot;slope\&quot;, \&quot;.5\&quot;)\n    .attr(\&quot;type\&quot;, \&quot;linear\&quot;)\n\n  const feMerge = filter.append(\&quot;feMerge\&quot;)\n\n  feMerge.append(\&quot;feMergeNode\&quot;)\n  feMerge.append(\&quot;feMergeNode\&quot;).attr(\&quot;in\&quot;, \&quot;SourceGraphic\&quot;)\n}\n\nconst renderChart: RenderChart = ({ partitionType, rootData, rootElId }) =&gt; {\n  const { width } = (document.getElementById(\n    \&quot;chart\&quot;\n  ) as HTMLElement).getBoundingClientRect()\n  const radius = Math.min(width, height) / 2\n  const colorScale = scaleOrdinal(schemePastel2)\n\n  const color = (node: HierarchyRectNode) =&gt;\n    node.children\n      ? colorScale(node.data.name)\n      : colorScale(node.parent!.data.name)\n\n  const svg = select(`#${rootElId}`)\n    .append(\&quot;svg\&quot;)\n    .text(\&quot;\&quot;)\n    .attr(\&quot;width\&quot;, width)\n    .attr(\&quot;height\&quot;, height)\n    .append(\&quot;g\&quot;)\n    .attr(\&quot;transform\&quot;, `translate(${width / 2},${height * 0.52})`)\n\n  addFilter(svg)\n\n  const descendants = getDataHierarchy({\n    partitionType,\n    radius,\n    rootData,\n  })\n\n  const arc = arcD3&lt;HierarchyRectNode&gt;()\n    .startAngle((node) =&gt; node.x0)\n    .endAngle((node) =&gt; node.x1)\n    .innerRadius((node) =&gt; node.y0)\n    .outerRadius((node) =&gt; node.y1)\n\n  const textsTransform = (node: HierarchyRectNode) =&gt; {\n    if (!node.depth) {\n      return \&quot;\&quot;\n    }\n\n    const centroid = arc.centroid(node)\n    const rotationDeg = (() =&gt; {\n      const rotation =\n        90 + ((node.x0 + (node.x1 - node.x0) / 2) * 180) / Math.PI\n\n      return rotation &gt; 90 &amp;&amp; rotation &lt; 270 ? rotation - 180 : rotation\n    })()\n\n    return [\n      `rotate(${rotationDeg},${centroid[0]},${centroid[1]})`,\n      `translate(${centroid[0]},${centroid[1]})`,\n    ].join(\&quot; \&quot;)\n  }\n\n  const renderDescendants = (\n    usedDescendants: Array&lt;HierarchyRectangularNode&lt;DataNode&gt;&gt;\n  ) =&gt; {\n    const pathSel = svg.selectAll&lt;SVGPathElement, HierarchyRectNode&gt;(\&quot;path\&quot;)\n    const pathInitialData = pathSel.data()\n    const path = pathSel.data(usedDescendants)\n\n    path.exit().remove()\n\n    const pathEnter = path\n      .enter()\n      .append(\&quot;path\&quot;)\n      .attr(\&quot;display\&quot;, (node) =&gt; (node.depth ? null : \&quot;none\&quot;))\n      .attr(\&quot;data-index\&quot;, (...[, nodeIndex]) =&gt; nodeIndex)\n      .style(\&quot;stroke\&quot;, \&quot;#000\&quot;)\n      .style(\&quot;stroke-width\&quot;, \&quot;0.5px\&quot;)\n      .style(\&quot;stroke-dasharray\&quot;, \&quot;1,3\&quot;)\n      .style(\&quot;fill\&quot;, color)\n      .style(\&quot;filter\&quot;, (...[, nodeIndex]) =&gt;\n        // not adding drop-shadow in all to avoid too much saturation\n        nodeIndex % 3 !== 0 ? \&quot;url(#drop-shadow)\&quot; : null\n      )\n      .attr(\&quot;d\&quot;, arc)\n\n    path\n      .transition()\n      .duration(transitionDuration)\n      .ease(easeFn)\n      .attrTween(\n        \&quot;d\&quot;,\n        getInterpolatorFn({ fn: arc, initialData: pathInitialData })\n      )\n\n    const textsSel = svg.selectAll&lt;SVGTextElement, HierarchyRectNode&gt;(\&quot;text\&quot;)\n    const textsInitialData = textsSel.data()\n    const texts = textsSel.data(usedDescendants)\n\n    texts.exit().remove()\n\n    const textsEnter = texts\n      .enter()\n      .append(\&quot;text\&quot;)\n      .text(getNodeText)\n      .attr(\&quot;transform\&quot;, textsTransform)\n      .attr(\&quot;data-index\&quot;, (...[, nodeIndex]) =&gt; nodeIndex)\n      .style(\&quot;fill\&quot;, \&quot;#333\&quot;)\n      .attr(\&quot;text-anchor\&quot;, \&quot;middle\&quot;)\n      .style(\&quot;font\&quot;, \&quot;bold 12px Arial\&quot;)\n      .style(\&quot;cursor\&quot;, \&quot;default\&quot;)\n      .attr(\&quot;transform\&quot;, textsTransform)\n\n    texts\n      .transition()\n      .duration(transitionDuration)\n      .ease(easeFn)\n      .attrTween(\n        \&quot;transform\&quot;,\n        getInterpolatorFn({ fn: textsTransform, initialData: textsInitialData })\n      )\n\n    const updatedGroups = [pathEnter, textsEnter]\n\n    updatedGroups.forEach((set) =&gt; {\n      set.on(\&quot;mouseover\&quot;, function () {\n        const nodeIndex = select(this).attr(\&quot;data-index\&quot;)\n\n        select(`path[data-index=\&quot;${nodeIndex}\&quot;]`).style(\&quot;fill\&quot;, overColor)\n        select(`text[data-index=\&quot;${nodeIndex}\&quot;]`).style(\&quot;fill\&quot;, \&quot;white\&quot;)\n      })\n\n      set.on(\&quot;mouseout\&quot;, function () {\n        const nodeIndex = select(this).attr(\&quot;data-index\&quot;)\n\n        select&lt;SVGPathElement, HierarchyRectNode&gt;(\n          `path[data-index=\&quot;${nodeIndex}\&quot;]`\n        ).style(\&quot;fill\&quot;, color)\n        select(`text[data-index=\&quot;${nodeIndex}\&quot;]`).style(\&quot;fill\&quot;, \&quot;#000\&quot;)\n      })\n    })\n\n    addTitle(path)\n    addTitle(texts)\n  }\n\n  renderDescendants(descendants)\n\n  return {\n    updatePartition: (newPartitionType: PartitionType) =&gt; {\n      const newDescendants = getDataHierarchy({\n        partitionType: newPartitionType,\n        radius,\n        rootData,\n      })\n\n      renderDescendants(newDescendants)\n    },\n  }\n}\n\nconst main = async () =&gt; {\n  const rootData = await fetchData()\n\n  const formEl = document.getElementById(\&quot;type-form\&quot;) as HTMLFormElement\n\n  const getCurrentSelectedRadio = (): PartitionType =&gt; {\n    const selectedRadio = Array.from(\n      (formEl.elements as unknown) as HTMLInputElement[]\n    ).find((formElement: HTMLInputElement) =&gt; formElement.checked)\n\n    return selectedRadio!.value as PartitionType\n  }\n\n  const partitionType = getCurrentSelectedRadio()\n\n  const { updatePartition } = renderChart({\n    partitionType,\n    rootData,\n    rootElId: \&quot;chart\&quot;,\n  })\n\n  formEl.addEventListener(\&quot;change\&quot;, () =&gt; {\n    const newPartitionType = getCurrentSelectedRadio()\n\n    updatePartition(newPartitionType)\n  })\n}\n\nexport default main\n&quot;,&quot;fileName&quot;:&quot;partition&quot;}],&quot;page&quot;:{&quot;content&quot;:&quot;import React from \&quot;react\&quot;\n\nimport { DemoPageProps } from \&quot;@/common\&quot;\n\nimport Demo from \&quot;@/components/demo\&quot;\n\nimport main from \&quot;@/demos/partition/partition\&quot;\n\nconst Partition = ({ pageContext }: DemoPageProps) =&gt; (\n  &lt;Demo main={main} pageContext={pageContext}&gt;\n    &lt;form id=\&quot;type-form\&quot;&gt;\n      &lt;label&gt;\n        &lt;input name=\&quot;mode\&quot; type=\&quot;radio\&quot; value=\&quot;size\&quot; /&gt; Size\n      &lt;/label&gt;\n      &lt;label&gt;\n        &lt;input defaultChecked name=\&quot;mode\&quot; type=\&quot;radio\&quot; value=\&quot;count\&quot; /&gt; Count\n      &lt;/label&gt;\n    &lt;/form&gt;\n    &lt;div id=\&quot;chart\&quot; /&gt;\n  &lt;/Demo&gt;\n)\n\nexport default Partition\n&quot;,&quot;type&quot;:&quot;tsx&quot;}},&quot;key&quot;:&quot;partition&quot;},&quot;meta&quot;:{&quot;description&quot;:&quot;Radial treemap example using D3.js, with data from a partition, where labels, mouse events and titles are added.&quot;}}},&quot;staticQueryHashes&quot;:[]}</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Wed, 01 Sep 2021 08:00:00 GMT</p>
    </body>
  </html>
  