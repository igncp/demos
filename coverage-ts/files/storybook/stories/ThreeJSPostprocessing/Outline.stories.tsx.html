
  <!DOCTYPE html>
  <html>
    <head>
      <title>Outline.stories.tsx</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">storybook/stories/ThreeJSPostprocessing/Outline.stories.tsx</td><td class="">98.50%</td><td class="">95%</td><td class="">665</td><td class="">655</td><td class="">10</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import React from &quot;react&quot;
import {
  AmbientLight,
  Color,
  DirectionalLight,
  DoubleSide,
  Group,
  LoadingManager,
  Mesh,
  MeshLambertMaterial,
  MeshPhongMaterial,
  Object3D,
  PerspectiveCamera,
  PlaneGeometry,
  Raycaster,
  RepeatWrapping,
  Scene,
  SphereGeometry,
  TextureLoader,
  TorusGeometry,
  Vector2,
  WebGLRenderer,
} from &quot;three&quot;
import { OrbitControls } from &quot;three/examples/jsm/controls/OrbitControls.js&quot;
import { OBJLoader } from &quot;three/examples/jsm/loaders/OBJLoader.js&quot;
import { EffectComposer } from &quot;three/examples/jsm/postprocessing/EffectComposer.js&quot;
import { OutlinePass } from &quot;three/examples/jsm/postprocessing/OutlinePass.js&quot;
import { RenderPass } from &quot;three/examples/jsm/postprocessing/RenderPass.js&quot;
import { ShaderPass } from &quot;three/examples/jsm/postprocessing/ShaderPass.js&quot;
import { FXAAShader } from &quot;three/examples/jsm/shaders/FXAAShader.js&quot;

import { StoryInfo, TemplateType, createRangeControl } from &quot;../common&quot;

import { ROOT_ID } from &quot;./constants&quot;

type State = {
  rafId: number | null
}

type SimulationElements = {
  camera: PerspectiveCamera
  composer: EffectComposer
  controls: OrbitControls
  group: Group
  mouse: Vector2
  obj3d: Object3D
  outlinePass: OutlinePass
  raycaster: Raycaster
  renderer: WebGLRenderer
  scene: Scene
}

type Props = {
  edgeGlow: number
  edgeStrength: number
  edgeThickness: number
  pulsePeriod: number
  rotate: boolean
  usePatternTexture: boolean
}

const getContainer = () =&gt; {
  const container = document.getElementById(ROOT_ID) as HTMLElement

  return container
}

class Simulation {
  private readonly state: State
  private readonly elements: SimulationElements
  private readonly dimensions: { height: number; width: number }

  private props: Props
  private selectedObjects: Mesh[]

  public constructor(props: Props) {
    this.state = {
      rafId: null,
    }

    this.props = props

    const container = getContainer()
    const { width } = container.getBoundingClientRect()
    const height = 500

    this.dimensions = {
      height,
      width,
    }

    document.body.appendChild(container)

    const camera = new PerspectiveCamera(45, width / height, 0.1, 100)
    const renderer = new WebGLRenderer()
    const scene = new Scene()

    scene.background = new Color(0xffffff)

    scene.add(new AmbientLight(0xaaaaaa, 0.2))

    const light = new DirectionalLight(0xddffdd, 0.6)

    light.position.set(1, 1, 1)
    light.castShadow = true
    light.shadow.mapSize.width = 1024
    light.shadow.mapSize.height = 1024

    const lightDistance = 10

    light.shadow.camera.left = -lightDistance
    light.shadow.camera.right = lightDistance
    light.shadow.camera.top = lightDistance
    light.shadow.camera.bottom = -lightDistance
    light.shadow.camera.far = 1000

    scene.add(light)

    renderer.shadowMap.enabled = true
    renderer.setSize(width, height)
    container.appendChild(renderer.domElement)

    camera.position.set(0, 0, 8)

    const controls = new OrbitControls(camera, renderer.domElement)

    controls.minDistance = 5
    controls.maxDistance = 20
    controls.enablePan = false
    controls.enableDamping = true
    controls.dampingFactor = 0.05

    const raycaster = new Raycaster()
    const mouse = new Vector2()

    const obj3d = new Object3D()
    const group = new Group()

    const composer = new EffectComposer(renderer)

    scene.add(group)
    group.add(obj3d)

    this.selectedObjects = []

    const outlinePass = new OutlinePass(
      new Vector2(width, height),
      scene,
      camera
    )

    this.elements = {
      camera,
      composer,
      controls,
      group,
      mouse,
      obj3d,
      outlinePass,
      raycaster,
      renderer,
      scene,
    }

    this.init()
    this.animate()
  }

  public stop() {
    this.clearRafId()
  }

  public restart(props: Props) {
    this.clearRafId()
    this.props = props
    this.updateOutlinePass()
    this.animate()
  }

  private clearRafId() {
    const {
      state: { rafId },
    } = this

    if (rafId !== null) {
      cancelAnimationFrame(rafId)
      this.state.rafId = null
    }
  }

  private animate() {
    this.state.rafId = requestAnimationFrame(() =&gt; {
      this.animate()
    })

    const {
      elements: { composer, controls, group },
    } = this

    const timer = performance.now()

    if (this.props.rotate) {
      group.rotation.y = timer * 0.0001
    }

    controls.update()
    composer.render()
  }

  private updateOutlinePass() {
    const {
      elements: { outlinePass },
    } = this

    outlinePass.edgeStrength = this.props.edgeStrength
    outlinePass.edgeGlow = this.props.edgeGlow
    outlinePass.edgeThickness = this.props.edgeThickness
    outlinePass.usePatternTexture = this.props.usePatternTexture
    outlinePass.pulsePeriod = this.props.pulsePeriod
  }

  private init() {
    const loadingManager = new LoadingManager()

    const {
      elements: {
        camera,
        composer,
        group,
        mouse,
        obj3d,
        outlinePass,
        raycaster,
        renderer,
        scene,
      },
    } = this

    const loader = new OBJLoader(loadingManager)

    loader.load(&quot;models/tree.obj&quot;, (object) =&gt; {
      let scale = 1.0

      object.traverse((child) =&gt; {
        if (child instanceof Mesh) {
          child.geometry.center()
          child.geometry.computeBoundingSphere()
          scale = 0.2 * child.geometry.boundingSphere.radius

          const phongMaterial = new MeshPhongMaterial({
            color: 0xffffff,
            shininess: 5,
            specular: 0x111111,
          })

          child.material = phongMaterial // eslint-disable-line id-denylist
          child.receiveShadow = true
          child.castShadow = true
        }
      })

      object.position.y = 1
      object.scale.divideScalar(scale)
      obj3d.add(object)
    })

    const sphereGeometry = new SphereGeometry(3, 48, 24)

    Array.from({ length: 20 }).forEach(() =&gt; {
      const sphereMaterial = new MeshLambertMaterial()

      sphereMaterial.color.setHSL(Math.random(), 1.0, 0.3)

      const sphereMesh = new Mesh(sphereGeometry, sphereMaterial)

      sphereMesh.position.x =
        Math.random() * 8 * (Math.random() &gt; 0.5 ? 1 : -1) - 2
      sphereMesh.position.y = Math.random() * 5 - 1
      sphereMesh.position.z =
        Math.random() * 8 * (Math.random() &gt; 0.5 ? 1 : -1) - 2
      sphereMesh.receiveShadow = true
      sphereMesh.castShadow = true
      sphereMesh.scale.multiplyScalar(Math.random() * 0.3 + 0.1)

      group.add(sphereMesh)
    })

    const floorMaterial = new MeshLambertMaterial({
      color: 0x00ff00,
      side: DoubleSide,
    })

    const floorGeometry = new PlaneGeometry(50, 50)
    const floorMesh = new Mesh(floorGeometry, floorMaterial)

    floorMesh.rotation.x -= Math.PI * 0.5
    floorMesh.position.y -= 1.5
    floorMesh.receiveShadow = true

    group.add(floorMesh)

    const torusGeometry = new TorusGeometry(1, 0.3, 16, 100)
    const torusMaterial = new MeshPhongMaterial({ color: 0xffaaff })
    const torus = new Mesh(torusGeometry, torusMaterial)

    torus.position.z = -4
    group.add(torus)
    torus.receiveShadow = true
    torus.castShadow = true

    const renderPass = new RenderPass(scene, camera)

    composer.addPass(renderPass)

    this.updateOutlinePass()

    composer.addPass(outlinePass)

    const textureLoader = new TextureLoader()

    textureLoader.load(&quot;textures/tri_pattern.jpg&quot;, (texture) =&gt; {
      outlinePass.patternTexture = texture
      texture.wrapS = RepeatWrapping
      texture.wrapT = RepeatWrapping
    })

    // https://blog.codinghorror.com/fast-approximate-anti-aliasing-fxaa/
    const effectFXAA = new ShaderPass(FXAAShader)

    const {
      dimensions: { height, width },
    } = this

    effectFXAA.uniforms[&quot;resolution&quot;].value.set(1 / width, 1 / height)
    composer.addPass(effectFXAA)

    const checkIntersection = () =&gt; {
      raycaster.setFromCamera(mouse, camera)

      const intersects = raycaster.intersectObject(scene, true)

      if (intersects.length &gt; 0) {
        const [{ object: selectedObject }] = intersects

        this.selectedObjects = [selectedObject as Mesh]
      } else {
        this.selectedObjects = []
      }

      outlinePass.selectedObjects = this.selectedObjects
    }

    const onPointerMove = (pointerEvent: PointerEvent) =&gt; {
      if (!pointerEvent.isPrimary) {
        return
      }

      const { left, top } = getContainer().getBoundingClientRect()

      mouse.x = ((pointerEvent.clientX - left) / width) * 2 - 1
      mouse.y = -((pointerEvent.clientY - top) / height) * 2 + 1

      checkIntersection()
    }

    renderer.domElement.style.touchAction = &quot;none&quot;
    renderer.domElement.addEventListener(&quot;pointermove&quot;, onPointerMove)
  }
}

const Outline = (props: Props) =&gt; {
  const simulationRef = React.useRef&lt;Simulation | null&gt;(null)

  React.useEffect(() =&gt; {
    if (simulationRef.current) {
      simulationRef.current.restart(props)
    } else {
      simulationRef.current = new Simulation(props)
    }

    return () =&gt; {
      simulationRef.current!.stop()
    }
  }, [props])

  React.useEffect(
    () =&gt; () =&gt; {
      const container = getContainer()

      container.innerHTML = &quot;&quot;
    },
    []
  )

  return (
    &lt;div&gt;
      &lt;StoryInfo
        docs={[
          {
            link: &quot;https://blog.codinghorror.com/fast-approximate-anti-aliasing-fxaa/&quot;,
            name: &quot;FXAA Shader&quot;,
          },
          {
            link: &quot;https://threejs.org/docs/#examples/en/postprocessing/EffectComposer&quot;,
            name: &quot;EffectComposer&quot;,
          },
        ]}
        source={[
          &quot;https://github.com/mrdoob/three.js/blob/dev/examples/webgl_postprocessing_outline.html&quot;,
          &quot;https://threejs.org/examples/#webgl_postprocessing_outline&quot;,
        ]}
        storyName={[&quot;ThreeJSPostprocessing&quot;, &quot;Outline&quot;]}
      /&gt;
      &lt;div id={ROOT_ID} /&gt;
    &lt;/div&gt;
  )
}

const Template = ((props: Props) =&gt; (
  &lt;Outline {...props} /&gt;
)) as TemplateType&lt;Props&gt;

const Common = Template.bind({})

const [edgeStrengthArg, edgeStrengthControls] = createRangeControl({
  diffMax: 5,
  diffMin: 2,
  initialValue: 3,
  step: 1,
})

const [edgeGlowArg, edgeGlowControls] = createRangeControl({
  diffMax: 5,
  diffMin: 0,
  initialValue: 0,
  step: 1,
})

const [edgeThicknessArg, edgeThicknessControls] = createRangeControl({
  diffMax: 5,
  diffMin: 1,
  initialValue: 1,
  step: 0.1,
})

const [pulsePeriodArg, pulsePeriodControls] = createRangeControl({
  diffMax: 5,
  diffMin: 0,
  initialValue: 0,
  step: 1,
})

const args: Props = {
  edgeGlow: edgeGlowArg,
  edgeStrength: edgeStrengthArg,
  edgeThickness: edgeThicknessArg,
  pulsePeriod: pulsePeriodArg,
  rotate: false,
  usePatternTexture: false,
}

Common.args = args

export default {
  argTypes: {
    edgeGlow: edgeGlowControls,
    edgeStrength: edgeStrengthControls,
    edgeThickness: edgeThicknessControls,
    pulsePeriod: pulsePeriodControls,
  },
  component: Outline,
  title: &quot;ThreeJS/Postprocessing/Outline&quot;,
}

export { Common }
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;storybook/stories/ThreeJSPostprocessing/Outline.stories.tsx&quot;,&quot;line&quot;:245,&quot;character&quot;:16,&quot;text&quot;:&quot;geometry&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;storybook/stories/ThreeJSPostprocessing/Outline.stories.tsx&quot;,&quot;line&quot;:245,&quot;character&quot;:25,&quot;text&quot;:&quot;center&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;storybook/stories/ThreeJSPostprocessing/Outline.stories.tsx&quot;,&quot;line&quot;:246,&quot;character&quot;:16,&quot;text&quot;:&quot;geometry&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;storybook/stories/ThreeJSPostprocessing/Outline.stories.tsx&quot;,&quot;line&quot;:246,&quot;character&quot;:25,&quot;text&quot;:&quot;computeBoundingSphere&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;storybook/stories/ThreeJSPostprocessing/Outline.stories.tsx&quot;,&quot;line&quot;:247,&quot;character&quot;:30,&quot;text&quot;:&quot;geometry&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;storybook/stories/ThreeJSPostprocessing/Outline.stories.tsx&quot;,&quot;line&quot;:247,&quot;character&quot;:39,&quot;text&quot;:&quot;boundingSphere&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;storybook/stories/ThreeJSPostprocessing/Outline.stories.tsx&quot;,&quot;line&quot;:247,&quot;character&quot;:54,&quot;text&quot;:&quot;radius&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;storybook/stories/ThreeJSPostprocessing/Outline.stories.tsx&quot;,&quot;line&quot;:255,&quot;character&quot;:16,&quot;text&quot;:&quot;material&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;storybook/stories/ThreeJSPostprocessing/Outline.stories.tsx&quot;,&quot;line&quot;:333,&quot;character&quot;:38,&quot;text&quot;:&quot;value&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;storybook/stories/ThreeJSPostprocessing/Outline.stories.tsx&quot;,&quot;line&quot;:333,&quot;character&quot;:44,&quot;text&quot;:&quot;set&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Sat, 05 Feb 2022 17:11:36 GMT</p>
    </body>
  </html>
  