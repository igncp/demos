
  <!DOCTYPE html>
  <html>
    <head>
      <title>ThreeJSReflectiveSpheres.stories.tsx</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">storybook/stories/ThreeJSReflectiveSpheres/ThreeJSReflectiveSpheres.stories.tsx</td><td class="">100.00%</td><td class="">95%</td><td class="">557</td><td class="">557</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import { scalePow } from &quot;d3&quot;
import React from &quot;react&quot;
import {
  ACESFilmicToneMapping,
  AmbientLight,
  Color,
  DirectionalLight,
  Mesh,
  MeshBasicMaterial,
  MeshPhysicalMaterial,
  PerspectiveCamera,
  PointLight,
  Raycaster,
  Scene,
  SphereGeometry,
  Vector2,
  Vector3,
  WebGLRenderer,
  sRGBEncoding,
} from &quot;three&quot;
import fontData from &quot;three/examples/fonts/gentilis_regular.typeface.json&quot;
import { OrbitControls } from &quot;three/examples/jsm/controls/OrbitControls.js&quot;
import { TextGeometry } from &quot;three/examples/jsm/geometries/TextGeometry&quot;
import { Font } from &quot;three/examples/jsm/loaders/FontLoader&quot;

import {
  StoryInfo,
  TemplateType,
  createRangeControl,
  threeDocs,
} from &quot;../common&quot;

type Sphere = Mesh&lt;SphereGeometry, MeshPhysicalMaterial&gt;

type Props = {
  automaticCamera: boolean
  lightPointSpeed: number
}

type State = {
  currentTime: number
  isStopped: boolean
  selectedSphereUuid: string
}

type Simulation = {
  camera: PerspectiveCamera
  particleLight: Mesh&lt;SphereGeometry, MeshBasicMaterial&gt;
  props: Props
  renderer: WebGLRenderer
  scene: Scene
  spheresList: Sphere[]
  state: State
  stop: () =&gt; void
}

const ROOT_ID = &quot;example&quot;

const cubeWidth = 400
const numberOfSphersPerSide = 5
const sphereRadius = (cubeWidth / numberOfSphersPerSide) * 0.8 * 0.5
const stepSize = 1.0 / numberOfSphersPerSide

const render = (simulation: Simulation) =&gt; {
  const {
    camera,
    particleLight,
    props: { automaticCamera },
    renderer,
    scene,
  } = simulation

  if (automaticCamera) {
    const timer = Date.now() * 0.00025

    camera.position.x = Math.cos(timer) * 800
    camera.position.z = Math.sin(timer) * 800
    camera.lookAt(scene.position)
  }

  const {
    state: { currentTime },
  } = simulation

  particleLight.position.x = Math.sin(currentTime * 7) * 300
  particleLight.position.y = Math.cos(currentTime * 5) * 400
  particleLight.position.z = Math.cos(currentTime * 3) * 300

  renderer.render(scene, camera)
}

const speedScale = scalePow().exponent(3).domain([0, 100]).range([0, 20_000])

const animate = (simulation: Simulation) =&gt; {
  if (simulation.state.isStopped) {
    return
  }

  requestAnimationFrame(() =&gt; animate(simulation))

  simulation.state.currentTime +=
    speedScale(simulation.props.lightPointSpeed) / 1_000_000

  render(simulation)
}

const font = new Font(fontData)

type CreateDemo = (config: {
  prevSimulation: Simulation | null
  props: Props
}) =&gt; Simulation

const createDemo: CreateDemo = ({ prevSimulation, props }) =&gt; {
  const container = document.getElementById(ROOT_ID) as HTMLElement
  const containerRect = container.getBoundingClientRect()
  const { width } = containerRect
  const height = 600

  const renderer =
    prevSimulation?.renderer ?? new WebGLRenderer({ antialias: true })
  const camera =
    prevSimulation?.camera ?? new PerspectiveCamera(40, width / height, 1, 2500)
  const scene = prevSimulation?.scene ?? new Scene()
  const spheresList: Sphere[] = prevSimulation?.spheresList ?? []
  const mouse = new Vector2()

  const state: State = {
    currentTime: prevSimulation?.state.currentTime ?? 0,
    isStopped: false,
    selectedSphereUuid: prevSimulation?.state.selectedSphereUuid ?? &quot;&quot;,
  }

  const onClick = (clickEvent: MouseEvent) =&gt; {
    clickEvent.preventDefault()

    mouse.x =
      ((clickEvent.clientX - containerRect.left) /
        renderer.domElement.clientWidth) *
        2 -
      1
    mouse.y =
      -(
        (clickEvent.clientY - containerRect.top) /
        renderer.domElement.clientHeight
      ) *
        2 +
      1

    const raycaster = new Raycaster()

    raycaster.setFromCamera(mouse, camera)

    const intersects = raycaster.intersectObjects(scene.children)

    if (!intersects.length) {
      return
    }

    const clickedSphere = spheresList.find(
      (s) =&gt; s.uuid === intersects[0].object.uuid
    )

    if (!clickedSphere) {
      return
    }

    if (clickedSphere.uuid === state.selectedSphereUuid) {
      spheresList.forEach((sphere) =&gt; {
        if (sphere.uuid === clickedSphere.uuid) {
          return
        }

        scene.add(sphere)
      })
      state.selectedSphereUuid = &quot;&quot;
    } else {
      spheresList.forEach((sphere) =&gt; {
        if (sphere.uuid === clickedSphere.uuid) {
          return
        }

        scene.remove(sphere)
      })
      state.selectedSphereUuid = clickedSphere.uuid
    }
  }

  const particleLight =
    prevSimulation?.particleLight ??
    new Mesh(
      new SphereGeometry(20, 8, 8),
      new MeshBasicMaterial({ color: 0xffa500 })
    )

  container.addEventListener(&quot;click&quot;, onClick)

  const createSimulation = (): Simulation =&gt; ({
    camera,
    particleLight,
    props,
    renderer,
    scene,
    spheresList,
    state,
    stop: () =&gt; {
      container.removeEventListener(&quot;click&quot;, onClick)
      state.isStopped = true
    },
  })

  if (prevSimulation) {
    const simulation = createSimulation()

    animate(simulation)

    return simulation
  }

  container.innerHTML = &quot;&quot;
  container.setAttribute(&quot;height&quot;, `${height}px`)
  container.setAttribute(&quot;width&quot;, `${width}px`)
  container.style.border = &quot;1px solid black&quot;

  camera.position.set(0.0, 400, 400 * 3.5)

  scene.background = new Color(0xffffff)

  const sphereGeometry = new SphereGeometry(sphereRadius, 32, 16)

  for (let alpha = 0; alpha &lt;= 1.0; alpha += stepSize) {
    for (let beta = 0; beta &lt;= 1.0; beta += stepSize) {
      for (let gamma = 0; gamma &lt;= 1.0; gamma += stepSize) {
        const diffuseColor = new Color().setRGB(alpha, beta, gamma)

        const sphereMaterial = new MeshPhysicalMaterial({
          clearcoat: 1.0 - alpha,
          clearcoatRoughness: 1.0 - beta,
          color: diffuseColor,
          envMap: null,
          metalness: 0,
          reflectivity: 1.0 - gamma,
          roughness: 0.5,
        })

        const sphereMesh = new Mesh(sphereGeometry, sphereMaterial)

        sphereMesh.position.x = alpha * 400 - 200
        sphereMesh.position.y = beta * 400 - 200
        sphereMesh.position.z = gamma * 400 - 200

        scene.add(sphereMesh)

        spheresList.push(sphereMesh)
      }
    }
  }

  type AddLabel = (options: { location: Vector3; name: string }) =&gt; void

  const addLabel: AddLabel = ({ location, name }) =&gt; {
    const textGeo = new TextGeometry(name, {
      curveSegments: 1,
      font,
      height: 1,
      size: 40,
    })

    const textMaterial = new MeshBasicMaterial({
      color: 0x000000,
    })
    const textMesh = new Mesh(textGeo, textMaterial)

    textMesh.position.copy(location)
    scene.add(textMesh)
  }

  addLabel({ location: new Vector3(-550, 0, 0), name: &quot;+clearcoat&quot; })
  addLabel({ location: new Vector3(350, 0, 0), name: &quot;-clearcoat&quot; })

  addLabel({
    location: new Vector3(-200, -300, 0),
    name: &quot;+clearcoatRoughness&quot;,
  })
  addLabel({ location: new Vector3(-200, 300, 0), name: &quot;-clearcoatRoughness&quot; })

  addLabel({ location: new Vector3(-150, 0, -300), name: &quot;+reflectivity&quot; })
  addLabel({ location: new Vector3(-150, 0, 300), name: &quot;-reflectivity&quot; })

  const directionalLightIntensity = 1
  const directionalLight = new DirectionalLight(
    0xffffff,
    directionalLightIntensity
  )

  const pointLightIntensity = 2
  const pointLightDistance = 800
  const pointLight = new PointLight(
    0xffa500,
    pointLightIntensity,
    pointLightDistance
  )

  directionalLight.position.set(1, 1, 1).normalize()
  particleLight.add(pointLight)

  scene.add(particleLight)
  scene.add(new AmbientLight(0x222222))
  scene.add(directionalLight)

  renderer.setPixelRatio(window.devicePixelRatio)
  renderer.setSize(width, height)
  renderer.outputEncoding = sRGBEncoding
  renderer.toneMapping = ACESFilmicToneMapping
  renderer.toneMappingExposure = 0.75
  renderer.setClearColor(0xffffff, 0)

  const controls = new OrbitControls(camera, renderer.domElement)

  controls.minDistance = 200
  controls.maxDistance = 2000

  container.appendChild(renderer.domElement)

  const newSimulation = createSimulation()

  animate(newSimulation)

  return newSimulation
}

const ThreeJSReflectiveSpheres = (props: Props) =&gt; {
  const [prevSimulation, setPrevSimulation] = React.useState&lt;Simulation | null&gt;(
    null
  )

  React.useEffect(() =&gt; {
    const newSimulation = createDemo({ prevSimulation, props })

    setPrevSimulation(newSimulation)

    return () =&gt; {
      newSimulation.stop()
    }
  }, [props])

  return (
    &lt;div&gt;
      &lt;StoryInfo
        docs={[threeDocs.meshPhysicalMaterial]}
        source=&quot;https://github.com/mrdoob/three.js/blob/dev/examples/webgl_materials_variations_physical.html&quot;
        storyName=&quot;ThreeJSReflectiveSpheres&quot;
      /&gt;
      &lt;p&gt;
        You can click on a sphere to select it and hide the rest. This
        functionality is new and not present in the example.
      &lt;/p&gt;
      &lt;div id={ROOT_ID} /&gt;
    &lt;/div&gt;
  )
}

const Template = ((props: Props) =&gt; (
  &lt;ThreeJSReflectiveSpheres {...props} /&gt;
)) as TemplateType&lt;Props&gt;

const Common = Template.bind({})

const [lightPointSpeedArg, lightPointSpeedControls] = createRangeControl({
  diffMin: 50,
  initialValue: 50,
  step: 1,
})

const args: Props = {
  automaticCamera: false,
  lightPointSpeed: lightPointSpeedArg,
}

Common.args = args

export default {
  argTypes: {
    lightPointSpeed: lightPointSpeedControls,
  },
  component: ThreeJSReflectiveSpheres,
  title: &quot;ThreeJS/Reflective Spheres&quot;,
}

export { Common }
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Mon, 01 Nov 2021 00:06:47 GMT</p>
    </body>
  </html>
  